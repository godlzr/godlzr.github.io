{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/anatole/source/js/jquery.appear.js","path":"js/jquery.appear.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","path":"js/jquery-migrate-1.2.1.min.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/blog_basic.css","path":"css/blog_basic.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo@2x.png","path":"images/logo@2x.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/IMG_20130614_002648.png","path":"images/IMG_20130614_002648.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/Sublime Text Build 3126.dmg","path":"images/Sublime Text Build 3126.dmg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/anatole/.gitignore","hash":"9fcbb05b158b5d3ba1ee60d38889e05e8b0f3f2a","modified":1549934188467},{"_id":"themes/anatole/LICENSE","hash":"359cb81298c1fdbccf531548fc097466b0151be4","modified":1549934188467},{"_id":"themes/anatole/README.md","hash":"5ef1c5ac9fff9526a37446dd47d8fc81481c9219","modified":1549934188467},{"_id":"themes/anatole/_config.sample.yml","hash":"b8e5af630f61ed223ca01bcc2919d60b2e6617fe","modified":1549947487000},{"_id":"themes/anatole/package-lock.json","hash":"00b98712db31e7a3e94d1e031158a2e5b2f38a87","modified":1549934574344},{"_id":"themes/anatole/package.json","hash":"4bba1dde846b87f2c970feb4fbf908eb766fbfe8","modified":1549934574340},{"_id":"source/_drafts/Build-eclipse-cdt4-project-with-cmake.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549818669900},{"_id":"source/_drafts/Knowledge-Based-Chapter-14-Java.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549818669900},{"_id":"source/_drafts/Roadmap-of-Weibo-User-Positon-Visualizaiton（WUPV）.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1549818669900},{"_id":"source/_posts/CCI_Chapter1.md","hash":"7f29a848b1c4f50b38d6dcbfc8f79b51fca8ad1a","modified":1549818669900},{"_id":"source/_posts/BitOperation.md","hash":"2edf5fe129b44f166eb96856ba36249b6e14d7f4","modified":1549818669900},{"_id":"source/_posts/CCI_Chapter13.md","hash":"8516f3cfae46495b9e6f68f726ca5a57828a9cc7","modified":1549818669900},{"_id":"source/_posts/CCI_Chapter2.md","hash":"dcdf4e4403defd49f3b8e0169ad48cbf8080a0ad","modified":1549818669900},{"_id":"source/_posts/CallbackFunction.md","hash":"9ea05bf09ad3d91f3a36c8aaf4edd9f802b55dd6","modified":1549818669904},{"_id":"source/_posts/CantFindeCCppProjectOptionInEclipse.md","hash":"e4e7d820334b3a83ca6978354baa7cfad3d64b6c","modified":1549931787000},{"_id":"source/_posts/CCI_Chapter4.md","hash":"ec37a96c25d6b14282d750b069df436b579f546b","modified":1549818669900},{"_id":"source/_posts/CCI_Chapter3.md","hash":"51042a0dafde9eb7c443a13dd8a386ce43ec9ce8","modified":1549818669900},{"_id":"source/_posts/ClaraV2Player.md","hash":"adff05c750eb588551b14ad62dc5e24cd048084f","modified":1549818669904},{"_id":"source/_posts/CleanUpMyBlog.md","hash":"8932793e5b6f593ed373dbdba6fea14c53eb8452","modified":1549818669904},{"_id":"source/_posts/DesignPattern_Behavioural.md","hash":"fee11344f91a73bb71f5de661c1f30c1bc5d780f","modified":1549818669904},{"_id":"source/_posts/DesignPattern_Behavioural2.md","hash":"2f853c1b4640937bd93aea97efb5c3b8116044fc","modified":1549818669904},{"_id":"source/_posts/DesignPattern_Behavioural3.md","hash":"7f2cc9e443cfd2d27b3c45da937b004d2814956f","modified":1549818669904},{"_id":"source/_posts/DesignPattern_Creational1.md","hash":"1c5e45c57fd4527a3b62ec625678902c7824301e","modified":1549818669904},{"_id":"source/_posts/DesignPattern_Creational2.md","hash":"8bfce82f1f6ad858e7b533dd49aa1448461531f2","modified":1549818669904},{"_id":"source/_posts/DesignPattern_Structural2.md","hash":"f9b8c126af0ccea0bac2e0b79cae4e4de7bc3717","modified":1549818669904},{"_id":"source/_posts/DesignPattern_Structural.md","hash":"8187c94562795e7782de449fabbb489342590b37","modified":1549818669904},{"_id":"source/_posts/DesignPattern_Structural3.md","hash":"32c091ef2b302c179a3b4f850140d9b8d3386110","modified":1549818669904},{"_id":"source/_posts/Eegeo.md","hash":"5a9716c6bc04ba8b77b2b6cffcbd457bad4aa8c2","modified":1549818669904},{"_id":"source/_posts/GUNToolchina.md","hash":"5ac4ead4a56f7bfd32d1189fa2d6214983e73c56","modified":1549818669904},{"_id":"source/_posts/GPU.md","hash":"389540fcb51284a99c6beb2a7f861f4c26193756","modified":1549818669904},{"_id":"source/_posts/GitCommands.md","hash":"452f2d06644a6e13baf89a9b0469c80180e6ca87","modified":1549818669904},{"_id":"source/_posts/GoogleTest.md","hash":"82788a9d4f69d00d86513b698b443246b05348e1","modified":1549818669904},{"_id":"source/_posts/HeaderLibDLL.md","hash":"9caac352964a4c041cad464f9ed2f81a6917cc93","modified":1549818669904},{"_id":"source/_posts/JavaAbstractClassInterface.md","hash":"e8d7f724a45afceb63e64d5ac9681703ec543e6a","modified":1549818669904},{"_id":"source/_posts/IELTSListening.md","hash":"0cfcbf9c8344c1b1be1b2df03e81a68f68cd1efd","modified":1549931882000},{"_id":"source/_posts/LinuxFhsCat.md","hash":"dd410db8a22b5a37280fb543361bb1b5b303dc72","modified":1549931865000},{"_id":"source/_posts/JavaObjectRelease.md","hash":"a5cb2830f5769bbe042c2f54f554e86d0e7fc72c","modified":1549818669904},{"_id":"source/_posts/OpenGLFlowchart.md","hash":"d8015e6e9cb20e02d7ba23153d64b2a1195ed7d5","modified":1549818669904},{"_id":"source/_posts/OPFSRIP.md","hash":"b29aca888ff881297eeff09dd8bf84b5a947de24","modified":1549818669904},{"_id":"source/_posts/OpenGLOpenGLES.md","hash":"b2f61baaa018d9307fc4875490123ba8a407b696","modified":1549818669904},{"_id":"source/_posts/OpenGLShaderBasics.md","hash":"91b6c35864d1d1c13163a54407a813317c867bef","modified":1549931851000},{"_id":"source/_posts/OpenGLPipeline.md","hash":"57a002d1b2022f918f161d6ea5c865afd0570e6e","modified":1549818669904},{"_id":"source/_posts/PointersAsFuncReturn.md","hash":"4c8278acf09a015616a65c1397bdf5382dcbafa3","modified":1549818669904},{"_id":"source/_posts/QTCreatorNotAllowPtrace.md","hash":"8e789b93da1a5cffb31b94d5dcfa76ecf38652b5","modified":1549931712000},{"_id":"source/_posts/SortAlgorithm.md","hash":"0509e36f372b7e26449a38e0a4fc3bfdf3f75041","modified":1549818669904},{"_id":"source/_posts/PBR.md","hash":"ddda2f546a864fbce54e37ac60a94c3325d6f574","modified":1549818669904},{"_id":"source/_posts/OpenGLStateMachine.md","hash":"c79a4c8dcceccbf0daf77ce3e57fb5f2af747390","modified":1549818669904},{"_id":"source/_posts/UbuntuRecover.md","hash":"80486a6a79870cd91bc8d28b85aa579e31218ad1","modified":1549931832000},{"_id":"source/_posts/UbuntuPHPError.md","hash":"2ef33c1ce572ae3fa936e855c3e0f9fb3e8509b1","modified":1549931768000},{"_id":"source/_posts/STLVectorList.md","hash":"74fbf43a29911d8c98c904980752b97bc03f4a4c","modified":1549818669904},{"_id":"source/_posts/[Video]平淡日子里的刺.md","hash":"c9d1c89fe7bc071a5b9fcc5b6b0a2dcd2b4aab78","modified":1549931804000},{"_id":"source/_posts/XcodeCantSeeLocalVariable.md","hash":"b0b33557f894eb19f27a8df4566380a35806227c","modified":1549931697000},{"_id":"source/_posts/UnionStruct.md","hash":"2b2ed9dcc638f4b7284d1718e7fa1ebcf5a1ceaa","modified":1549818669904},{"_id":"source/_posts/[Video]我想和你虚度时光.md","hash":"b07f7adb8759152700edd59e23886cd3d504e532","modified":1549818669904},{"_id":"source/_posts/[Video]牡丹亭外.md","hash":"8bb7695b2fa9048ddadc07723deb9b0470c38631","modified":1549818669904},{"_id":"source/archive/index.md","hash":"b563df86f19d024bb18c89ac4159d808cabff078","modified":1549818669904},{"_id":"source/_posts_archive/[interview]alcatel-lucent-customer-application-engineer-may-27-ef-bc-8c2015.md","hash":"cab76d6b5d6bc5c817d7a3da5eec303a92e1f46f","modified":1549818669904},{"_id":"source/_posts_archive/[interview]apirl-2-ef-bc-8ccorel-phone-interview.md","hash":"a5df4a5f92621ab40cf8b8ab5b13286359719cb2","modified":1549818669904},{"_id":"source/_posts/ViCommands.md","hash":"57a39eda6ed6c1936c0ad4ed17b0ea6622278f21","modified":1549818669904},{"_id":"source/about/index.md","hash":"217a182e5c1038476d53c975c3aaf0a90f895a69","modified":1549818669904},{"_id":"source/_posts_archive/[interview]april-1st-sulon-tech-phone-screen-questions.md","hash":"f3b6743a42453a0cce610ad35c6eccb98ad5d2d5","modified":1549818669904},{"_id":"source/_posts_archive/[interview]april-13-2015-shopify-on-site-interview.md","hash":"55b40dc417d9d8229a1615b0b70b3d5dc4b6f13e","modified":1549818669904},{"_id":"source/_posts_archive/[interview]april-9th-stilo-phone-interview.md","hash":"72b941b992cb40eca3490ce9a631562f730197de","modified":1549818669904},{"_id":"source/_posts_archive/[interview]august-7th-rip-entertainment-phone-screening.md","hash":"0b349f63a4d58ed063a285ff55ec085ef8b16318","modified":1549818669904},{"_id":"source/_posts_archive/[interview]exocortex-interview-september-14-2015.md","hash":"6f7bf1abf1e1e6c0ee9e7e4cb3363084f66c36e9","modified":1549818669904},{"_id":"source/_posts_archive/[interview]august-7th-brinx-interview.md","hash":"01a2732e3e4b679e4a40476b99eb29726c9e07f1","modified":1549818669904},{"_id":"source/_posts_archive/[interview]ibm-phone-interview-question-march-9th-2015.md","hash":"6cfd8af91d7b20d8e61c68875fe16512611e8487","modified":1549818669904},{"_id":"source/_posts_archive/[interview]june-17th-2015-cisco-interview.md","hash":"b3cad1672c9b73aa3511e9e1cb5bbbb06e99164c","modified":1549818669904},{"_id":"source/_posts_archive/[interview]june-17th-cisco-on-site-interview.md","hash":"92d5931b0fd8b9f477e0016c17a6c777550fc383","modified":1549818669904},{"_id":"source/_posts_archive/[interview]expected-cisco-questions.md","hash":"b653a933130a11435205aab17a19b8c8fcb1b7f0","modified":1549818669904},{"_id":"source/_posts_archive/[interview]questions-for-your-interviewer.md","hash":"c0736166cdb2a5bba52f47d89c298af910fd90f3","modified":1549818669904},{"_id":"source/_posts_archive/[interview]expected-blackberryqnx-interview-questions.md","hash":"2ec3d83f09fb7eff26be88987c46f54bdbe8f0f6","modified":1549818669904},{"_id":"source/_posts_archive/[interview]xyz-rgb-interview.md","hash":"be5a4aad371c6051540e51817bf8fd86fd92c673","modified":1549818669904},{"_id":"source/_posts_archive/[photo]back-to-quebec-city.md","hash":"ee05caf0c1c0022e6954c1363be65f36fdfb4dc8","modified":1549818669904},{"_id":"source/_posts_archive/[photo]bigfish.md","hash":"6e3e11504576d5d3965276d53d13194ec4729350","modified":1549818669904},{"_id":"source/_posts_archive/[photo]e5-98-bf.md","hash":"3c02c9927898a75d5e36f097d5ccfa08ec864755","modified":1549818669904},{"_id":"source/_posts_archive/[photo]ottawariver.md","hash":"9d788a00ec1dda50431ba06f6c5625978c7d8efd","modified":1549818669904},{"_id":"source/_posts_archive/[photo]haiyan.md","hash":"1da6d6457da5dca7860feb6da21b313e14dcd769","modified":1549818669904},{"_id":"source/_posts_archive/[photo]rainbow.md","hash":"cd40d2981791f9acce6158ea624f5f2660f43fcc","modified":1549818669904},{"_id":"source/_posts_archive/[interview]my-interview-questions.md","hash":"578ee784c9fc6dc484191d93a35f438107cb895a","modified":1549818669904},{"_id":"source/_posts_archive/[photo]sea.md","hash":"c06b21e436675ec2dbbc5a8dee893a3f315c8db0","modified":1549818669904},{"_id":"source/_posts_archive/[photo]tadoussac-001.md","hash":"3ce5af883b1e10278d4c83e047ce731049a287c6","modified":1549818669904},{"_id":"source/_posts_archive/[photo]tadoussac-september-2015.md","hash":"b7576a215d09576c5639d841fab1ebbfdf033f14","modified":1549818669904},{"_id":"source/_posts_archive/[photo]well-whale.md","hash":"06adcdaa3696cfb77acf898fe3467825cc534232","modified":1549818669904},{"_id":"source/_posts_archive/[photo]together.md","hash":"8bc58ab2097d03dde8213f880054b3c6e385105a","modified":1549818669904},{"_id":"source/_posts_archive/[photo]white-opium.md","hash":"f20e86838903ae1ff4007600e7a2f5a621d0f3f4","modified":1549818669904},{"_id":"source/_posts_archive/[posted]1-adapter-and-proxy-patterns.md","hash":"9d698f390b46baee184304c454a69ba636a8294e","modified":1549818669904},{"_id":"source/_posts_archive/[posted]1-chain-of-responsibility-iterator-and-mediator.md","hash":"2388baea492939a7bae91a49698ca900e3fa78dc","modified":1549818669904},{"_id":"source/_posts_archive/[posted]3-facade-and-flyweight.md","hash":"90940541ecd07c11588e6b2c7d22ab25d8b38559","modified":1549818669904},{"_id":"source/_posts_archive/[posted]3-state-observer-and-memento.md","hash":"eb6bfc1dccc1afcce505b8e1be2b1b6e77806450","modified":1549818669904},{"_id":"source/_posts_archive/[posted]c-bit-operation.md","hash":"1173c6b915110e7144ffa138f0d8e01776f7189e","modified":1549818669904},{"_id":"source/_posts_archive/[posted]cant-find-the-cc-project-option-in-eclipse-after-install-cdt-on-mac-os.md","hash":"ad7b1fa5161141ccb9da646a32aac2d9157bfec7","modified":1549818669904},{"_id":"source/_posts_archive/[posted]bridge-ef-bc-8cdecorator-and-composite.md","hash":"b9112c9cb203ae5d8d016f4d76b1eddbca813776","modified":1549818669904},{"_id":"source/_posts_archive/[posted]callback-function.md","hash":"cff718eab6c7a7e37af27b90e575d6b888a79bd4","modified":1549818669904},{"_id":"source/_posts_archive/[posted]data-structure-chapter-3-stacks-and-queues.md","hash":"7394224ef018b3a5cc048e99470f76add0055754","modified":1549818669904},{"_id":"source/_posts_archive/[posted]data-structure-chapter-4-tree-and-graph.md","hash":"b96f5f2fd7c026d1349f8ae0a7dd7e47596f9d32","modified":1549818669904},{"_id":"source/_posts_archive/[posted]data-structures-chapter-1-arrays-and-strings.md","hash":"a79a3c12c228ae0f6d772fb47ff42a20390df2a5","modified":1549818669904},{"_id":"source/_posts_archive/[posted]data-structures-chapter-2-linked-list.md","hash":"aeb1913a68a2057efc7aa2c473fc6bb713ca40c8","modified":1549818669904},{"_id":"source/_posts_archive/[posted]glsl-attributes-uniforms-and-varyings.md","hash":"d95e6da1193a6a7be1c35bd1c5ab8575c6e8cf86","modified":1549818669904},{"_id":"source/_posts_archive/[posted]git-command.md","hash":"ea7fa9eac8d3f97cdaddcf461a8b328716f55438","modified":1549818669904},{"_id":"source/_posts_archive/[posted]gnu-toolchain.md","hash":"99ee6d646125893bc00eed850451aec42fbee943","modified":1549818669904},{"_id":"source/_posts_archive/[posted]factor-builder-prototype.md","hash":"743244aa8f650d495854f4d37cd168d7c9237889","modified":1549818669904},{"_id":"source/_posts_archive/[posted]header-files-libraries-and-dlls.md","hash":"35072ef6e6ab61eeaca5b839c3199098ec953b1d","modified":1549818669904},{"_id":"source/_posts_archive/[posted]java-difference-between-abstract-class-and-interface.md","hash":"652ee5d038761f74dddf157371f3c7304821214e","modified":1549818669904},{"_id":"source/_posts_archive/[posted]ielts-listening.md","hash":"51c306ad4d90b02712bb4535f6377c89b74526c9","modified":1549818669904},{"_id":"source/_posts_archive/[posted]linux-fhs2-3-cat.md","hash":"a5d995dfa2fbedaef87f03866fdb7bb65edb590c","modified":1549818669904},{"_id":"source/_posts_archive/[posted]opengl-and-opengl-es.md","hash":"2f7746e07d7a8522ceb87946508c8c6959fa242e","modified":1549818669904},{"_id":"source/_posts_archive/[posted]knowledge-based-chapter-13-c-and-c.md","hash":"22b84c61b5f3cc94e88dcdaaf01d5aa85e440342","modified":1549818669904},{"_id":"source/_posts_archive/[posted]gpu.md","hash":"35221774b4efeefaa5815a27da8be5a9a458260b","modified":1549818669904},{"_id":"source/_posts_archive/[posted]java-object-release.md","hash":"cadfcc7a75b2f7fd17f7718748c1a61e8276836f","modified":1549818669904},{"_id":"source/_posts_archive/[posted]opengl-pipeline.md","hash":"3812d3931c3ec355343bdf737d5d1ec0678b930a","modified":1549818669904},{"_id":"source/_posts_archive/[posted]opengl-shader-basics.md","hash":"ef49f602d8ef28ebfd98578572f9f1a0e8bdd540","modified":1549818669904},{"_id":"source/_posts_archive/[posted]opfs-and-rip.md","hash":"a52becee02a8604b5f7f4ec8c12a22b5c1738eb8","modified":1549818669904},{"_id":"source/_posts_archive/[posted]pointers-as-function-return.md","hash":"419ea580f5c0b0a53d5ba561fec9ccdd6ae91584","modified":1549818669904},{"_id":"source/_posts_archive/[posted]qtcreater-debugging-no-ptrace.md","hash":"6069fd5ef1c31917cdf4ce556953fb73848c28ca","modified":1549818669904},{"_id":"source/_posts_archive/[posted]opengl-state-machine.md","hash":"8b74ad85ebc7fba4f38f8697b01ca5071bd06248","modified":1549818669904},{"_id":"source/_posts_archive/[posted]pbr.md","hash":"381d921a1e49dcbd12a2f630f582a5d8dc2d3018","modified":1549818669904},{"_id":"source/_posts_archive/[posted]recover-ubuntu-initilization.md","hash":"a61dbc50a683da7d9f9272730a33553a78772b36","modified":1549818669904},{"_id":"source/_posts_archive/[posted]sort-algorithm.md","hash":"87ea9695f56f4a753e7ddac4c19afd380bd59456","modified":1549818669904},{"_id":"source/_posts_archive/[posted]the-best-figure-to-describe-the-opengl-flowchart.md","hash":"36cdd20601ff69e8e99398670d40ea1e881ffae5","modified":1549818669904},{"_id":"source/_posts_archive/[posted]turn-on-ubuntu-php-error-indicator.md","hash":"33f0d44425cc446f7f0bd2f24a37c8a95fbc716e","modified":1549818669904},{"_id":"source/_posts_archive/[posted]stl-vector-n-list.md","hash":"0b3e38737404cfb51e82e0645bec6295c182f5e4","modified":1549818669904},{"_id":"source/_posts_archive/[posted]singleton.md","hash":"fbce67c93a352c4150a1f597fe71b839adc8c1ed","modified":1549818669904},{"_id":"source/_posts_archive/[posted]ubuntu-install-googletest.md","hash":"e6be84962dbe2c96f5c2c4b32456b5c058c4aa55","modified":1549818669904},{"_id":"source/_posts_archive/[posted]xcode-debugging-cannot-see-the-value-of-the-local-variable.md","hash":"6725efa87a1ea2db1a766e64e2cd2a566aa4074b","modified":1549818669904},{"_id":"source/_posts_archive/[video]mudantingwai.md","hash":"bbf31f518075b613b4f6772762c4b8e05bbb8e9e","modified":1549818669904},{"_id":"source/_posts_archive/[posted]union-struct.md","hash":"0deea724819d116331ccce13baae8d6bc3facab3","modified":1549818669904},{"_id":"source/_posts_archive/[posted]visitor-and-strategy.md","hash":"a2f2cf23c615eb7c28902a9037f6edd890126b3e","modified":1549818669904},{"_id":"source/_posts_archive/[video]pingdanrizilideci.md","hash":"f14a46fa061b452af01a571d80fee0362c532239","modified":1549818669904},{"_id":"source/_posts_archive/[video]woxianghenixudushiguang.md","hash":"16a1978fd194e524ae580b6ff1ab461140f501e9","modified":1549818669904},{"_id":"source/_posts_archive/[posted]vi-commands.md","hash":"4c0b0fbed5b73ddc8bcb3cfe43f124b61546c44c","modified":1549818669904},{"_id":"source/_posts_archive/differences-between-sending-cvmat-const-cvmat-const-cvmat-or-cvmat-as-arguments-to-a-function.md","hash":"348ff2b807258f69e23026327516edf66fbeb183","modified":1549818669904},{"_id":"source/_posts_archive/sql-mod-del-2.md","hash":"dcc509dcbfe22ad8c408a781d959b864d79ef171","modified":1549818669904},{"_id":"source/_posts_archive/sql-mod-del.md","hash":"e74b70a5e322a4dee2a4d4af27bed2aac4707d5d","modified":1549818669904},{"_id":"source/_posts_archive/sql-select.md","hash":"5236d46c1a53fb97570b95c388d4c86d96d064f4","modified":1549818669904},{"_id":"source/_posts_archive/sql-others.md","hash":"03a2d51ace2cb522b8ddf053d570c7cef192ad85","modified":1549818669904},{"_id":"source/_posts_archive/projection-matrix.md","hash":"a763841b0f1d5f5374186157eb0ad5858122ac73","modified":1549818669904},{"_id":"source/_posts_archive/opencv2-4-8-components.md","hash":"21311cf997c566e6707ed1a3cd947b517d776609","modified":1549818669904},{"_id":"themes/anatole/languages/default.yml","hash":"c49a11a3d2262810bd6f1cb4d86cb8d0edd9176e","modified":1549934188467},{"_id":"themes/anatole/layout/index.jade","hash":"53da3cfd498951148acb33de1574df80ae282dc5","modified":1549934188467},{"_id":"themes/anatole/layout/archive.jade","hash":"8f58996b55dc3db3c96d69e88b0a6db4167d025b","modified":1549934188467},{"_id":"themes/anatole/layout/category.jade","hash":"2f2f113e99eb1ebdac475edba23a330dbd2e77bd","modified":1549934188467},{"_id":"themes/anatole/layout/page.jade","hash":"300e3fa98fd7cb2627589d3555ab4863cfeedd0c","modified":1549934188467},{"_id":"themes/anatole/layout/tag.jade","hash":"b2dde91815560830b6a0f1dfbdd83aca88aba969","modified":1549934188467},{"_id":"themes/anatole/layout/post.jade","hash":"0b830bf13f3c82a936fa44c687b3911606cd8bec","modified":1549934188467},{"_id":"themes/anatole/layout/mixins.jade","hash":"1350478dce8698fa804a776ffdc2cf69b00dbd44","modified":1549934188467},{"_id":"themes/anatole/layout/partial/footer.jade","hash":"ed3c11ca3b2a1c34fa9d1179923ee478a2ca8cdd","modified":1549934188467},{"_id":"themes/anatole/layout/partial/comments.jade","hash":"ee43e2fa9bed77868f2340435e455a3e647428df","modified":1549934188467},{"_id":"themes/anatole/layout/partial/head.jade","hash":"3d6126d0b53a889a46ad61eb8cc0ab1b35446c49","modified":1549934188467},{"_id":"themes/anatole/layout/partial/layout.jade","hash":"174050fa9ee919f5bcb2c5426224ec1968db672c","modified":1549934188467},{"_id":"themes/anatole/layout/partial/nav.jade","hash":"062d8eafb33884d97992022ed037dd884b5fb09c","modified":1549934188467},{"_id":"themes/anatole/layout/partial/sidebar.jade","hash":"abe3226c9639f362311e754f401e8f802742e83e","modified":1549947910000},{"_id":"themes/anatole/source/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1549934188467},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1549934188467},{"_id":"themes/anatole/source/css/font-awesome.min.css","hash":"95d0b0c4d11105c81be1857b744076a1d2bed918","modified":1549934188467},{"_id":"themes/anatole/source/css/blog_basic.css","hash":"b671a346765f5882504d626101dadf65c04a41da","modified":1549934188467},{"_id":"themes/anatole/source/css/style.css","hash":"c2deaa091f46280c03fd1fbc89c57ac221b1480e","modified":1549934188467},{"_id":"themes/anatole/source/css/style.scss","hash":"175c9237798207f705c62777b5f51509adec6d0a","modified":1549934188467},{"_id":"themes/anatole/source/images/avatar.jpg","hash":"5fc71096d46298cc9edd5c863a726d0ae39b92a4","modified":1549934188471},{"_id":"themes/anatole/source/images/favicon.png","hash":"c49a2925aa14de12f06a805e772d6f05cd10bc3a","modified":1549934188467},{"_id":"themes/anatole/source/images/logo.png","hash":"41bdf2ebd8cc193ad82a211758af827d891b1a90","modified":1549934188467},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1549934188467},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1549934188467},{"_id":"themes/anatole/source/images/logo@2x.png","hash":"7b6c1ad23baf8db2ef50498e7d9b3f6c3d820a97","modified":1549934188467},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1549934188467},{"_id":"themes/anatole/source/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1549934188467},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1549934188467},{"_id":"themes/anatole/source/images/IMG_20130614_002648.png","hash":"7980ae7da9655c9d7e38ceab8b4cbac01c06e8d7","modified":1549934188467},{"_id":"themes/anatole/source/images/Sublime Text Build 3126.dmg","hash":"c0f8d975d3b6892b4a55615707d5badad81e4ddf","modified":1549934188495},{"_id":"themes/anatole/_config.yml","hash":"7b6e0e2b861dbbcde6389daedb1a7d07a42bbf71","modified":1549947875000}],"Category":[{"name":"Cracking the Coding Interview (Fifth edition)","_id":"cjs1amk0t0007lkguvbnd5c6o"},{"name":"C/C++","_id":"cjs1amk0x000clkguvdyvwhjr"},{"name":"Issues Solution","_id":"cjs1amk14000slkguyny6jt96"},{"name":"Computer Graphics","_id":"cjs1amk160010lkgupk1jsx5b"},{"name":"Design Patterns","_id":"cjs1amk170016lkguxff5wgdt"},{"name":"Design Pattern","_id":"cjs1amk19001blkguoyw799ir"},{"name":"Desing Pattern","_id":"cjs1amk1c001klkgu6d8dmjpm"},{"name":"Operating System","_id":"cjs1amk1k0027lkguxdohqpwa"},{"name":"Tech","_id":"cjs1amk1l002flkguyuomfg7z"},{"name":"Java","_id":"cjs1amk1o002olkgu322zbhrj"},{"name":"Ubuntu","_id":"cjs1amk1p002vlkguxr1oz5c1"},{"name":"Others","_id":"cjs1amk1v0039lkguogmb84sr"},{"name":"Networking and Protocol","_id":"cjs1amk1x003hlkguuka7dld5"},{"name":"OpenGL","_id":"cjs1amk1z003plkguhxfgbcn2"},{"name":"Algorithm","_id":"cjs1amk21003vlkguyigouna6"},{"name":"Computer Vision/Graphics","_id":"cjs1amk21003ylkgunftyv0k4"},{"name":"Music","_id":"cjs1amk220041lkguqao7rzi4"}],"Data":[],"Page":[{"title":"archive","layout":"page-archive","date":"2016-06-26T16:23:57.000Z","_content":"","source":"archive/index.md","raw":"---\ntitle: archive\nlayout: page-archive\ndate: 2016-06-26 12:23:57\n---\n","updated":"2019-02-10T17:11:09.904Z","path":"archive/index.html","comments":1,"_id":"cjs1amk0s0004lkgupdcx7lz8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2016-06-26T16:26:45.000Z","_content":"\n\n# ZHONGRUI LI [ Full-Stack and 3D Developer ]\n* 1112-1285 RICHMOND RD, Ottawa, Ontario, K2B7Z4\n* Phone:+1-613-869-6136 \n* Email: zli6136@gmail.com \n* Website: [godlzr.com](http://www.godlzr.com) \n\n## SKILLS\n*    Javascript, Java, C++, C#, Python, HTML, CSS\n*    Nodejs, RESTAPI, Threejs, WebGL, OpenGL, OpenCV, React, Redux, Android SDK, Cordova.\n*    Git, Ubuntu, Windows, AWS\n\n## PROFESSIONAL EXPERIENCE\n##### Software Developer [ Sep 2015 – PRESENT ]\n* [Exocortex Technologies Inc.](http://exocortex.com/)- Ottawa, Canada \n    -    Developed backend REST API, Nodejs and .Net SDK of [clara.io](https://www.clara.io).\n    -    Designed and developed Frontend and UI with Backbone, React, Redux.\n    -    Developed WebGL based 3D modeling system and tools with threejs.\n    -    Developed exporter, importer (FBX, Blender, JSON, OBJ)\n    -    Algorithm design Memory management, debugging and for high performance rendering and modeling in an environment with limited memory.\n\n##### Research/aaaTeaching Assistant [ Sep 2012 - Mar 2015 ]\n* [University of Ottawa](https://www.uottawa.ca/en) - Ottawa, Canada\n    -    Researched in 3D hair modeling using depth camera.\n    -    Experiment design and coded data acquisition software and 3D modeling algorithm      using C++, Python and Matlab.\n    -    Published two papers for the research work.\n    -    TA of courses Introduction to Data Communications and Network, Design and Analysis Algorithm\n    -    Prepared and lead tutorials and labs, graded assignments and lab reports.\n\n##### Java Developer Intern [ May 2011 - Jul 2011 ]\n* [ChinaSoft International](http://www.chinasofti.com/en/index.shtml) – Chongqing, China \n    -    Built Web based financial management system using J2EE\n    -    Designed and built the system database with Oracle 10g. \n    -    Designed the full life cycle of the system with Struts, Spring and Hibernate integration framework.\n    -    Developed DAO and Service Layers\n\n## EDUCATION\n##### M.A.Sc in Electrical and Computer Engineering [ Aug 2012 - Mar 2015 ]\n* [University of Ottawa](https://www.uottawa.ca/en) - Ottawa, Canada \n    - Thesis: [Particle based 3D Hair Reconstruction using Kinect and High Resolution Camera](https://www.ruor.uottawa.ca/handle/10393/32068) \n    - GPA 9.0/10.0\n    \n##### B.E in Software Engineering [ Aug 2008 - Jul 2012 ]\n* [Sichuan University](http://www.scu.edu.cn/en/) - Chengdu, China \n    - Graduation Design: OpenGL base OBJ format 3D mesh viewer \n    - GPA 3.1/4.0\n\n## PUBLICATIONS\n* [**Hair Modeling using Kinect Sensors and DSLR Cameras**](http://ieeexplore.ieee.org/document/7057514/), **Li, Z.**, Sun, C., Lee, W., and Kim, I., URAI 2014, Nov,2014 (First Author)\n* [**Relatively straight medium to long hair reconstruction using Kinect Sensors**](http://www.scitepress.org/DigitalLibrary/Link.aspx?doi=10.5220/0005312301580164), Sun, C., **Li，Z.**, Lee, W., GRAPP 2015, March 2015 (Equal Contribution First Author)\n\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-06-26 12:26:45\n---\n\n\n# ZHONGRUI LI [ Full-Stack and 3D Developer ]\n* 1112-1285 RICHMOND RD, Ottawa, Ontario, K2B7Z4\n* Phone:+1-613-869-6136 \n* Email: zli6136@gmail.com \n* Website: [godlzr.com](http://www.godlzr.com) \n\n## SKILLS\n*    Javascript, Java, C++, C#, Python, HTML, CSS\n*    Nodejs, RESTAPI, Threejs, WebGL, OpenGL, OpenCV, React, Redux, Android SDK, Cordova.\n*    Git, Ubuntu, Windows, AWS\n\n## PROFESSIONAL EXPERIENCE\n##### Software Developer [ Sep 2015 – PRESENT ]\n* [Exocortex Technologies Inc.](http://exocortex.com/)- Ottawa, Canada \n    -    Developed backend REST API, Nodejs and .Net SDK of [clara.io](https://www.clara.io).\n    -    Designed and developed Frontend and UI with Backbone, React, Redux.\n    -    Developed WebGL based 3D modeling system and tools with threejs.\n    -    Developed exporter, importer (FBX, Blender, JSON, OBJ)\n    -    Algorithm design Memory management, debugging and for high performance rendering and modeling in an environment with limited memory.\n\n##### Research/aaaTeaching Assistant [ Sep 2012 - Mar 2015 ]\n* [University of Ottawa](https://www.uottawa.ca/en) - Ottawa, Canada\n    -    Researched in 3D hair modeling using depth camera.\n    -    Experiment design and coded data acquisition software and 3D modeling algorithm      using C++, Python and Matlab.\n    -    Published two papers for the research work.\n    -    TA of courses Introduction to Data Communications and Network, Design and Analysis Algorithm\n    -    Prepared and lead tutorials and labs, graded assignments and lab reports.\n\n##### Java Developer Intern [ May 2011 - Jul 2011 ]\n* [ChinaSoft International](http://www.chinasofti.com/en/index.shtml) – Chongqing, China \n    -    Built Web based financial management system using J2EE\n    -    Designed and built the system database with Oracle 10g. \n    -    Designed the full life cycle of the system with Struts, Spring and Hibernate integration framework.\n    -    Developed DAO and Service Layers\n\n## EDUCATION\n##### M.A.Sc in Electrical and Computer Engineering [ Aug 2012 - Mar 2015 ]\n* [University of Ottawa](https://www.uottawa.ca/en) - Ottawa, Canada \n    - Thesis: [Particle based 3D Hair Reconstruction using Kinect and High Resolution Camera](https://www.ruor.uottawa.ca/handle/10393/32068) \n    - GPA 9.0/10.0\n    \n##### B.E in Software Engineering [ Aug 2008 - Jul 2012 ]\n* [Sichuan University](http://www.scu.edu.cn/en/) - Chengdu, China \n    - Graduation Design: OpenGL base OBJ format 3D mesh viewer \n    - GPA 3.1/4.0\n\n## PUBLICATIONS\n* [**Hair Modeling using Kinect Sensors and DSLR Cameras**](http://ieeexplore.ieee.org/document/7057514/), **Li, Z.**, Sun, C., Lee, W., and Kim, I., URAI 2014, Nov,2014 (First Author)\n* [**Relatively straight medium to long hair reconstruction using Kinect Sensors**](http://www.scitepress.org/DigitalLibrary/Link.aspx?doi=10.5220/0005312301580164), Sun, C., **Li，Z.**, Lee, W., GRAPP 2015, March 2015 (Equal Contribution First Author)\n\n\n","updated":"2019-02-10T17:11:09.904Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjs1amk0t0006lkgulrrke02g","content":"<h1 id=\"ZHONGRUI-LI-Full-Stack-and-3D-Developer\"><a href=\"#ZHONGRUI-LI-Full-Stack-and-3D-Developer\" class=\"headerlink\" title=\"ZHONGRUI LI [ Full-Stack and 3D Developer ]\"></a>ZHONGRUI LI [ Full-Stack and 3D Developer ]</h1><ul>\n<li>1112-1285 RICHMOND RD, Ottawa, Ontario, K2B7Z4</li>\n<li>Phone:+1-613-869-6136 </li>\n<li>Email: <a href=\"mailto:zli6136@gmail.com\" target=\"_blank\" rel=\"noopener\">zli6136@gmail.com</a> </li>\n<li>Website: <a href=\"http://www.godlzr.com\" target=\"_blank\" rel=\"noopener\">godlzr.com</a> </li>\n</ul>\n<h2 id=\"SKILLS\"><a href=\"#SKILLS\" class=\"headerlink\" title=\"SKILLS\"></a>SKILLS</h2><ul>\n<li>Javascript, Java, C++, C#, Python, HTML, CSS</li>\n<li>Nodejs, RESTAPI, Threejs, WebGL, OpenGL, OpenCV, React, Redux, Android SDK, Cordova.</li>\n<li>Git, Ubuntu, Windows, AWS</li>\n</ul>\n<h2 id=\"PROFESSIONAL-EXPERIENCE\"><a href=\"#PROFESSIONAL-EXPERIENCE\" class=\"headerlink\" title=\"PROFESSIONAL EXPERIENCE\"></a>PROFESSIONAL EXPERIENCE</h2><h5 id=\"Software-Developer-Sep-2015-–-PRESENT\"><a href=\"#Software-Developer-Sep-2015-–-PRESENT\" class=\"headerlink\" title=\"Software Developer [ Sep 2015 – PRESENT ]\"></a>Software Developer [ Sep 2015 – PRESENT ]</h5><ul>\n<li><a href=\"http://exocortex.com/\" target=\"_blank\" rel=\"noopener\">Exocortex Technologies Inc.</a>- Ottawa, Canada <ul>\n<li>Developed backend REST API, Nodejs and .Net SDK of <a href=\"https://www.clara.io\" target=\"_blank\" rel=\"noopener\">clara.io</a>.</li>\n<li>Designed and developed Frontend and UI with Backbone, React, Redux.</li>\n<li>Developed WebGL based 3D modeling system and tools with threejs.</li>\n<li>Developed exporter, importer (FBX, Blender, JSON, OBJ)</li>\n<li>Algorithm design Memory management, debugging and for high performance rendering and modeling in an environment with limited memory.</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Research-aaaTeaching-Assistant-Sep-2012-Mar-2015\"><a href=\"#Research-aaaTeaching-Assistant-Sep-2012-Mar-2015\" class=\"headerlink\" title=\"Research/aaaTeaching Assistant [ Sep 2012 - Mar 2015 ]\"></a>Research/aaaTeaching Assistant [ Sep 2012 - Mar 2015 ]</h5><ul>\n<li><a href=\"https://www.uottawa.ca/en\" target=\"_blank\" rel=\"noopener\">University of Ottawa</a> - Ottawa, Canada<ul>\n<li>Researched in 3D hair modeling using depth camera.</li>\n<li>Experiment design and coded data acquisition software and 3D modeling algorithm      using C++, Python and Matlab.</li>\n<li>Published two papers for the research work.</li>\n<li>TA of courses Introduction to Data Communications and Network, Design and Analysis Algorithm</li>\n<li>Prepared and lead tutorials and labs, graded assignments and lab reports.</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Java-Developer-Intern-May-2011-Jul-2011\"><a href=\"#Java-Developer-Intern-May-2011-Jul-2011\" class=\"headerlink\" title=\"Java Developer Intern [ May 2011 - Jul 2011 ]\"></a>Java Developer Intern [ May 2011 - Jul 2011 ]</h5><ul>\n<li><a href=\"http://www.chinasofti.com/en/index.shtml\" target=\"_blank\" rel=\"noopener\">ChinaSoft International</a> – Chongqing, China <ul>\n<li>Built Web based financial management system using J2EE</li>\n<li>Designed and built the system database with Oracle 10g. </li>\n<li>Designed the full life cycle of the system with Struts, Spring and Hibernate integration framework.</li>\n<li>Developed DAO and Service Layers</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"EDUCATION\"><a href=\"#EDUCATION\" class=\"headerlink\" title=\"EDUCATION\"></a>EDUCATION</h2><h5 id=\"M-A-Sc-in-Electrical-and-Computer-Engineering-Aug-2012-Mar-2015\"><a href=\"#M-A-Sc-in-Electrical-and-Computer-Engineering-Aug-2012-Mar-2015\" class=\"headerlink\" title=\"M.A.Sc in Electrical and Computer Engineering [ Aug 2012 - Mar 2015 ]\"></a>M.A.Sc in Electrical and Computer Engineering [ Aug 2012 - Mar 2015 ]</h5><ul>\n<li><a href=\"https://www.uottawa.ca/en\" target=\"_blank\" rel=\"noopener\">University of Ottawa</a> - Ottawa, Canada <ul>\n<li>Thesis: <a href=\"https://www.ruor.uottawa.ca/handle/10393/32068\" target=\"_blank\" rel=\"noopener\">Particle based 3D Hair Reconstruction using Kinect and High Resolution Camera</a> </li>\n<li>GPA 9.0/10.0</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-E-in-Software-Engineering-Aug-2008-Jul-2012\"><a href=\"#B-E-in-Software-Engineering-Aug-2008-Jul-2012\" class=\"headerlink\" title=\"B.E in Software Engineering [ Aug 2008 - Jul 2012 ]\"></a>B.E in Software Engineering [ Aug 2008 - Jul 2012 ]</h5><ul>\n<li><a href=\"http://www.scu.edu.cn/en/\" target=\"_blank\" rel=\"noopener\">Sichuan University</a> - Chengdu, China <ul>\n<li>Graduation Design: OpenGL base OBJ format 3D mesh viewer </li>\n<li>GPA 3.1/4.0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PUBLICATIONS\"><a href=\"#PUBLICATIONS\" class=\"headerlink\" title=\"PUBLICATIONS\"></a>PUBLICATIONS</h2><ul>\n<li><a href=\"http://ieeexplore.ieee.org/document/7057514/\" target=\"_blank\" rel=\"noopener\"><strong>Hair Modeling using Kinect Sensors and DSLR Cameras</strong></a>, <strong>Li, Z.</strong>, Sun, C., Lee, W., and Kim, I., URAI 2014, Nov,2014 (First Author)</li>\n<li><a href=\"http://www.scitepress.org/DigitalLibrary/Link.aspx?doi=10.5220/0005312301580164\" target=\"_blank\" rel=\"noopener\"><strong>Relatively straight medium to long hair reconstruction using Kinect Sensors</strong></a>, Sun, C., <strong>Li，Z.</strong>, Lee, W., GRAPP 2015, March 2015 (Equal Contribution First Author)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ZHONGRUI-LI-Full-Stack-and-3D-Developer\"><a href=\"#ZHONGRUI-LI-Full-Stack-and-3D-Developer\" class=\"headerlink\" title=\"ZHONGRUI LI [ Full-Stack and 3D Developer ]\"></a>ZHONGRUI LI [ Full-Stack and 3D Developer ]</h1><ul>\n<li>1112-1285 RICHMOND RD, Ottawa, Ontario, K2B7Z4</li>\n<li>Phone:+1-613-869-6136 </li>\n<li>Email: <a href=\"mailto:zli6136@gmail.com\" target=\"_blank\" rel=\"noopener\">zli6136@gmail.com</a> </li>\n<li>Website: <a href=\"http://www.godlzr.com\" target=\"_blank\" rel=\"noopener\">godlzr.com</a> </li>\n</ul>\n<h2 id=\"SKILLS\"><a href=\"#SKILLS\" class=\"headerlink\" title=\"SKILLS\"></a>SKILLS</h2><ul>\n<li>Javascript, Java, C++, C#, Python, HTML, CSS</li>\n<li>Nodejs, RESTAPI, Threejs, WebGL, OpenGL, OpenCV, React, Redux, Android SDK, Cordova.</li>\n<li>Git, Ubuntu, Windows, AWS</li>\n</ul>\n<h2 id=\"PROFESSIONAL-EXPERIENCE\"><a href=\"#PROFESSIONAL-EXPERIENCE\" class=\"headerlink\" title=\"PROFESSIONAL EXPERIENCE\"></a>PROFESSIONAL EXPERIENCE</h2><h5 id=\"Software-Developer-Sep-2015-–-PRESENT\"><a href=\"#Software-Developer-Sep-2015-–-PRESENT\" class=\"headerlink\" title=\"Software Developer [ Sep 2015 – PRESENT ]\"></a>Software Developer [ Sep 2015 – PRESENT ]</h5><ul>\n<li><a href=\"http://exocortex.com/\" target=\"_blank\" rel=\"noopener\">Exocortex Technologies Inc.</a>- Ottawa, Canada <ul>\n<li>Developed backend REST API, Nodejs and .Net SDK of <a href=\"https://www.clara.io\" target=\"_blank\" rel=\"noopener\">clara.io</a>.</li>\n<li>Designed and developed Frontend and UI with Backbone, React, Redux.</li>\n<li>Developed WebGL based 3D modeling system and tools with threejs.</li>\n<li>Developed exporter, importer (FBX, Blender, JSON, OBJ)</li>\n<li>Algorithm design Memory management, debugging and for high performance rendering and modeling in an environment with limited memory.</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Research-aaaTeaching-Assistant-Sep-2012-Mar-2015\"><a href=\"#Research-aaaTeaching-Assistant-Sep-2012-Mar-2015\" class=\"headerlink\" title=\"Research/aaaTeaching Assistant [ Sep 2012 - Mar 2015 ]\"></a>Research/aaaTeaching Assistant [ Sep 2012 - Mar 2015 ]</h5><ul>\n<li><a href=\"https://www.uottawa.ca/en\" target=\"_blank\" rel=\"noopener\">University of Ottawa</a> - Ottawa, Canada<ul>\n<li>Researched in 3D hair modeling using depth camera.</li>\n<li>Experiment design and coded data acquisition software and 3D modeling algorithm      using C++, Python and Matlab.</li>\n<li>Published two papers for the research work.</li>\n<li>TA of courses Introduction to Data Communications and Network, Design and Analysis Algorithm</li>\n<li>Prepared and lead tutorials and labs, graded assignments and lab reports.</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Java-Developer-Intern-May-2011-Jul-2011\"><a href=\"#Java-Developer-Intern-May-2011-Jul-2011\" class=\"headerlink\" title=\"Java Developer Intern [ May 2011 - Jul 2011 ]\"></a>Java Developer Intern [ May 2011 - Jul 2011 ]</h5><ul>\n<li><a href=\"http://www.chinasofti.com/en/index.shtml\" target=\"_blank\" rel=\"noopener\">ChinaSoft International</a> – Chongqing, China <ul>\n<li>Built Web based financial management system using J2EE</li>\n<li>Designed and built the system database with Oracle 10g. </li>\n<li>Designed the full life cycle of the system with Struts, Spring and Hibernate integration framework.</li>\n<li>Developed DAO and Service Layers</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"EDUCATION\"><a href=\"#EDUCATION\" class=\"headerlink\" title=\"EDUCATION\"></a>EDUCATION</h2><h5 id=\"M-A-Sc-in-Electrical-and-Computer-Engineering-Aug-2012-Mar-2015\"><a href=\"#M-A-Sc-in-Electrical-and-Computer-Engineering-Aug-2012-Mar-2015\" class=\"headerlink\" title=\"M.A.Sc in Electrical and Computer Engineering [ Aug 2012 - Mar 2015 ]\"></a>M.A.Sc in Electrical and Computer Engineering [ Aug 2012 - Mar 2015 ]</h5><ul>\n<li><a href=\"https://www.uottawa.ca/en\" target=\"_blank\" rel=\"noopener\">University of Ottawa</a> - Ottawa, Canada <ul>\n<li>Thesis: <a href=\"https://www.ruor.uottawa.ca/handle/10393/32068\" target=\"_blank\" rel=\"noopener\">Particle based 3D Hair Reconstruction using Kinect and High Resolution Camera</a> </li>\n<li>GPA 9.0/10.0</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-E-in-Software-Engineering-Aug-2008-Jul-2012\"><a href=\"#B-E-in-Software-Engineering-Aug-2008-Jul-2012\" class=\"headerlink\" title=\"B.E in Software Engineering [ Aug 2008 - Jul 2012 ]\"></a>B.E in Software Engineering [ Aug 2008 - Jul 2012 ]</h5><ul>\n<li><a href=\"http://www.scu.edu.cn/en/\" target=\"_blank\" rel=\"noopener\">Sichuan University</a> - Chengdu, China <ul>\n<li>Graduation Design: OpenGL base OBJ format 3D mesh viewer </li>\n<li>GPA 3.1/4.0</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PUBLICATIONS\"><a href=\"#PUBLICATIONS\" class=\"headerlink\" title=\"PUBLICATIONS\"></a>PUBLICATIONS</h2><ul>\n<li><a href=\"http://ieeexplore.ieee.org/document/7057514/\" target=\"_blank\" rel=\"noopener\"><strong>Hair Modeling using Kinect Sensors and DSLR Cameras</strong></a>, <strong>Li, Z.</strong>, Sun, C., Lee, W., and Kim, I., URAI 2014, Nov,2014 (First Author)</li>\n<li><a href=\"http://www.scitepress.org/DigitalLibrary/Link.aspx?doi=10.5220/0005312301580164\" target=\"_blank\" rel=\"noopener\"><strong>Relatively straight medium to long hair reconstruction using Kinect Sensors</strong></a>, Sun, C., <strong>Li，Z.</strong>, Lee, W., GRAPP 2015, March 2015 (Equal Contribution First Author)</li>\n</ul>\n"}],"Post":[{"_content":"","source":"_drafts/Build-eclipse-cdt4-project-with-cmake.md","raw":"","slug":"Build-eclipse-cdt4-project-with-cmake","published":0,"date":"2019-02-10T17:11:09.900Z","updated":"2019-02-10T17:11:09.900Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk090000lkgugkoqjjv3","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_drafts/Knowledge-Based-Chapter-14-Java.md","raw":"","slug":"Knowledge-Based-Chapter-14-Java","published":0,"date":"2019-02-10T17:11:09.900Z","updated":"2019-02-10T17:11:09.900Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk0d0001lkguk0ralu6n","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_drafts/Roadmap-of-Weibo-User-Positon-Visualizaiton（WUPV）.md","raw":"","slug":"Roadmap-of-Weibo-User-Positon-Visualizaiton（WUPV）","published":0,"date":"2019-02-10T17:11:09.900Z","updated":"2019-02-10T17:11:09.900Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk0e0002lkguctdar03e","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Cracking the Coding Interview - Chapter 1 Arrays and Strings","id":"26","date":"2015-03-28T01:48:08.000Z","_content":"# Chapter 1 Arrays and Strings\n\n###### 1.1 Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?\n\n*   首先确定构成字符串的字符集有多大？是ASCII字符，还是只是26个字母？ 还是有更大的字符集，对于不同的情况，我们可能会有不同的解决方案。\n*   ASCII：标准ASCII 码也叫基础ASCII码，使用8 位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符， ASCII 码表共有**258**位字符。\n*   如果我们假设字符集是ASCII字符，那么我们可以开一个大小为256的bool数组来表征每个字符的出现。数组初始化为false，遍历一遍字符串中的字符，当bool数组对应位置的值为真， 表明该字符在之前已经出现过，即可得出该字符串中有重复字符。否则将该位置的bool数组 值置为true。\n*   [Q1.1_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java \"Implementation\")\n\n###### 1.2 Implement a function void reverse(char *str) in C or C++ which reverses a null terminated string.\n\n*   使用C++位操作,做地址交换。\n\n```\n\ta1              0101110101\n\tb1              1011101011\n\ta2 = a1^b1      1110011110\n\tb2 = a2^b1      0101110101(a1)\n\ta3 = a2^b2      1011101011(b1)\n```\n\n*   获取字符串长度，从首尾两端开始两两交换。\n*   [Q1.2_Implementation](https://github.com/godlzr/CrackingCodingInterviewCpp/blob/master/CrackingCodingInterviewCpp/stringHelper.cpp \"Q1.2_Imp\")\n\n###### 1.3 Given two strings, write a method to decide if one is a permutation of the other.\n\n*   将字符串转换成字符数组（toCharArray()）后排序(Arrays.sort())\n*   然后比较两个字符数组(Arrays.equals(string a, string b))\n*   [Q1.3_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java \"Implementation\")\n\n###### 1.4 Write a method to replace all spaces in a string with '%20'. You may assume that the string has sufficient space at the end of the string to hold the additional characters, and that you are given the \"true\" length of the string.(Note: if implementing in Java, please use a character array so that you can perform this operation in place.)\n\nEXAMPLE\n\nInput: \"Mr_John_Smith\",13\n\nOutput:\"Mr%20John%20Smith\"\n\n*   首先遍历字符串记录空格个数，计算新的 字符串长度=原长度+2*空格数\n*   将原字符串的内容以此填入新的字符串，遇到空格填入“%20”\n*   [Q1.4_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java \"Implementation\")\n\n###### 1.5 Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabccccccaaa would become a2b1c5a3\\. If the \"compressed\" string would not become smaller than the original string, you method should return the original string. You can assume the string has only upper and lower case.\n\n*   建立一个新的StringBuffer字符串newstr，和count.\n*   遍历字符串str, 计算压缩后的长度, 判断两个字符串长度，如果newstr长度不小于str长度，输出str.\n*   第一个字符写入newstr\n*   后一个字符和前一个字符相同则count++，不同则将数字写入newstr，后count=0，写入新的字符\n*   遍历完成，输出newstr\n*   [Q1.5_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java \"Implementation\")\n\n###### 1.6 Given an image represented by an NxN matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees. Can you do this in place?\n\n*   Do this in place, 即不开辟新的空间，在原数据结构中操作\n*   我们可以将matrix由外之内分层，一层一层进行旋转操作\n*   ![](https://lh5.googleusercontent.com/-PYq_I9DzGWo/VRnY2DG2GHI/AAAAAAAAANc/k3vpW6fQHaI/w1258-h1230-no/IMG_20150330_191308~2.jpg)\n*   [Q1.6_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/matrixHelper.java)\n\n###### 1.7 Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0\n\n*   建立两个一维数组，分别对应矩阵的长和宽，并赋值false\n*   遍历矩阵，遇到0，将对应长款数组中的元素赋值为true\n*   遍历矩阵，如果当前元素的行号列号在长宽数组中为true，将该元素置为0\n*   [Q1.7_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/matrixHelper.java)\n\n###### 1.8 Assume you have a method _isSubstring( )_ which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to _isString( ) _(e.g., \"waterbottle\" is a rotation of \"erbottlewat\").\n\n*   isSubstring( )可以用 String.isContatin()实现\n*   如果字符串是一个旋转字符串，则首位应该相连，如“erbottlewat”中 “er”与“wat”相连\n*   如果将这个字符串，复制拼接“erbottle**wat**”+“**erbottle**wat”=“erbottle**waterbottle**wat”，则其中一定含有一个完整的字串\n*   所以判断(s1+s1).isSubString(s2)\n*   [Q1.8_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java \"im\")","source":"_posts/CCI_Chapter1.md","raw":"---\ntitle: Cracking the Coding Interview - Chapter 1 Arrays and Strings\nid: 26\ncategories:\n  - Cracking the Coding Interview (Fifth edition)\ndate: 2015-03-27 21:48:08\ntags:\n---\n# Chapter 1 Arrays and Strings\n\n###### 1.1 Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?\n\n*   首先确定构成字符串的字符集有多大？是ASCII字符，还是只是26个字母？ 还是有更大的字符集，对于不同的情况，我们可能会有不同的解决方案。\n*   ASCII：标准ASCII 码也叫基础ASCII码，使用8 位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符， ASCII 码表共有**258**位字符。\n*   如果我们假设字符集是ASCII字符，那么我们可以开一个大小为256的bool数组来表征每个字符的出现。数组初始化为false，遍历一遍字符串中的字符，当bool数组对应位置的值为真， 表明该字符在之前已经出现过，即可得出该字符串中有重复字符。否则将该位置的bool数组 值置为true。\n*   [Q1.1_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java \"Implementation\")\n\n###### 1.2 Implement a function void reverse(char *str) in C or C++ which reverses a null terminated string.\n\n*   使用C++位操作,做地址交换。\n\n```\n\ta1              0101110101\n\tb1              1011101011\n\ta2 = a1^b1      1110011110\n\tb2 = a2^b1      0101110101(a1)\n\ta3 = a2^b2      1011101011(b1)\n```\n\n*   获取字符串长度，从首尾两端开始两两交换。\n*   [Q1.2_Implementation](https://github.com/godlzr/CrackingCodingInterviewCpp/blob/master/CrackingCodingInterviewCpp/stringHelper.cpp \"Q1.2_Imp\")\n\n###### 1.3 Given two strings, write a method to decide if one is a permutation of the other.\n\n*   将字符串转换成字符数组（toCharArray()）后排序(Arrays.sort())\n*   然后比较两个字符数组(Arrays.equals(string a, string b))\n*   [Q1.3_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java \"Implementation\")\n\n###### 1.4 Write a method to replace all spaces in a string with '%20'. You may assume that the string has sufficient space at the end of the string to hold the additional characters, and that you are given the \"true\" length of the string.(Note: if implementing in Java, please use a character array so that you can perform this operation in place.)\n\nEXAMPLE\n\nInput: \"Mr_John_Smith\",13\n\nOutput:\"Mr%20John%20Smith\"\n\n*   首先遍历字符串记录空格个数，计算新的 字符串长度=原长度+2*空格数\n*   将原字符串的内容以此填入新的字符串，遇到空格填入“%20”\n*   [Q1.4_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java \"Implementation\")\n\n###### 1.5 Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabccccccaaa would become a2b1c5a3\\. If the \"compressed\" string would not become smaller than the original string, you method should return the original string. You can assume the string has only upper and lower case.\n\n*   建立一个新的StringBuffer字符串newstr，和count.\n*   遍历字符串str, 计算压缩后的长度, 判断两个字符串长度，如果newstr长度不小于str长度，输出str.\n*   第一个字符写入newstr\n*   后一个字符和前一个字符相同则count++，不同则将数字写入newstr，后count=0，写入新的字符\n*   遍历完成，输出newstr\n*   [Q1.5_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java \"Implementation\")\n\n###### 1.6 Given an image represented by an NxN matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees. Can you do this in place?\n\n*   Do this in place, 即不开辟新的空间，在原数据结构中操作\n*   我们可以将matrix由外之内分层，一层一层进行旋转操作\n*   ![](https://lh5.googleusercontent.com/-PYq_I9DzGWo/VRnY2DG2GHI/AAAAAAAAANc/k3vpW6fQHaI/w1258-h1230-no/IMG_20150330_191308~2.jpg)\n*   [Q1.6_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/matrixHelper.java)\n\n###### 1.7 Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0\n\n*   建立两个一维数组，分别对应矩阵的长和宽，并赋值false\n*   遍历矩阵，遇到0，将对应长款数组中的元素赋值为true\n*   遍历矩阵，如果当前元素的行号列号在长宽数组中为true，将该元素置为0\n*   [Q1.7_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/matrixHelper.java)\n\n###### 1.8 Assume you have a method _isSubstring( )_ which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to _isString( ) _(e.g., \"waterbottle\" is a rotation of \"erbottlewat\").\n\n*   isSubstring( )可以用 String.isContatin()实现\n*   如果字符串是一个旋转字符串，则首位应该相连，如“erbottlewat”中 “er”与“wat”相连\n*   如果将这个字符串，复制拼接“erbottle**wat**”+“**erbottle**wat”=“erbottle**waterbottle**wat”，则其中一定含有一个完整的字串\n*   所以判断(s1+s1).isSubString(s2)\n*   [Q1.8_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java \"im\")","slug":"CCI_Chapter1","published":1,"updated":"2019-02-10T17:11:09.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk0r0003lkguszcp8qx4","content":"<h1 id=\"Chapter-1-Arrays-and-Strings\"><a href=\"#Chapter-1-Arrays-and-Strings\" class=\"headerlink\" title=\"Chapter 1 Arrays and Strings\"></a>Chapter 1 Arrays and Strings</h1><h6 id=\"1-1-Implement-an-algorithm-to-determine-if-a-string-has-all-unique-characters-What-if-you-cannot-use-additional-data-structures\"><a href=\"#1-1-Implement-an-algorithm-to-determine-if-a-string-has-all-unique-characters-What-if-you-cannot-use-additional-data-structures\" class=\"headerlink\" title=\"1.1 Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?\"></a>1.1 Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?</h6><ul>\n<li>首先确定构成字符串的字符集有多大？是ASCII字符，还是只是26个字母？ 还是有更大的字符集，对于不同的情况，我们可能会有不同的解决方案。</li>\n<li>ASCII：标准ASCII 码也叫基础ASCII码，使用8 位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符， ASCII 码表共有<strong>258</strong>位字符。</li>\n<li>如果我们假设字符集是ASCII字符，那么我们可以开一个大小为256的bool数组来表征每个字符的出现。数组初始化为false，遍历一遍字符串中的字符，当bool数组对应位置的值为真， 表明该字符在之前已经出现过，即可得出该字符串中有重复字符。否则将该位置的bool数组 值置为true。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java\" title=\"Implementation\" target=\"_blank\" rel=\"noopener\">Q1.1_Implementation</a></li>\n</ul>\n<h6 id=\"1-2-Implement-a-function-void-reverse-char-str-in-C-or-C-which-reverses-a-null-terminated-string\"><a href=\"#1-2-Implement-a-function-void-reverse-char-str-in-C-or-C-which-reverses-a-null-terminated-string\" class=\"headerlink\" title=\"1.2 Implement a function void reverse(char *str) in C or C++ which reverses a null terminated string.\"></a>1.2 Implement a function void reverse(char *str) in C or C++ which reverses a null terminated string.</h6><ul>\n<li>使用C++位操作,做地址交换。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1              0101110101</span><br><span class=\"line\">b1              1011101011</span><br><span class=\"line\">a2 = a1^b1      1110011110</span><br><span class=\"line\">b2 = a2^b1      0101110101(a1)</span><br><span class=\"line\">a3 = a2^b2      1011101011(b1)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取字符串长度，从首尾两端开始两两交换。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterviewCpp/blob/master/CrackingCodingInterviewCpp/stringHelper.cpp\" title=\"Q1.2_Imp\" target=\"_blank\" rel=\"noopener\">Q1.2_Implementation</a></li>\n</ul>\n<h6 id=\"1-3-Given-two-strings-write-a-method-to-decide-if-one-is-a-permutation-of-the-other\"><a href=\"#1-3-Given-two-strings-write-a-method-to-decide-if-one-is-a-permutation-of-the-other\" class=\"headerlink\" title=\"1.3 Given two strings, write a method to decide if one is a permutation of the other.\"></a>1.3 Given two strings, write a method to decide if one is a permutation of the other.</h6><ul>\n<li>将字符串转换成字符数组（toCharArray()）后排序(Arrays.sort())</li>\n<li>然后比较两个字符数组(Arrays.equals(string a, string b))</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java\" title=\"Implementation\" target=\"_blank\" rel=\"noopener\">Q1.3_Implementation</a></li>\n</ul>\n<h6 id=\"1-4-Write-a-method-to-replace-all-spaces-in-a-string-with-‘-20’-You-may-assume-that-the-string-has-sufficient-space-at-the-end-of-the-string-to-hold-the-additional-characters-and-that-you-are-given-the-“true”-length-of-the-string-Note-if-implementing-in-Java-please-use-a-character-array-so-that-you-can-perform-this-operation-in-place\"><a href=\"#1-4-Write-a-method-to-replace-all-spaces-in-a-string-with-‘-20’-You-may-assume-that-the-string-has-sufficient-space-at-the-end-of-the-string-to-hold-the-additional-characters-and-that-you-are-given-the-“true”-length-of-the-string-Note-if-implementing-in-Java-please-use-a-character-array-so-that-you-can-perform-this-operation-in-place\" class=\"headerlink\" title=\"1.4 Write a method to replace all spaces in a string with ‘%20’. You may assume that the string has sufficient space at the end of the string to hold the additional characters, and that you are given the “true” length of the string.(Note: if implementing in Java, please use a character array so that you can perform this operation in place.)\"></a>1.4 Write a method to replace all spaces in a string with ‘%20’. You may assume that the string has sufficient space at the end of the string to hold the additional characters, and that you are given the “true” length of the string.(Note: if implementing in Java, please use a character array so that you can perform this operation in place.)</h6><p>EXAMPLE</p>\n<p>Input: “Mr_John_Smith”,13</p>\n<p>Output:”Mr%20John%20Smith”</p>\n<ul>\n<li>首先遍历字符串记录空格个数，计算新的 字符串长度=原长度+2*空格数</li>\n<li>将原字符串的内容以此填入新的字符串，遇到空格填入“%20”</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java\" title=\"Implementation\" target=\"_blank\" rel=\"noopener\">Q1.4_Implementation</a></li>\n</ul>\n<h6 id=\"1-5-Implement-a-method-to-perform-basic-string-compression-using-the-counts-of-repeated-characters-For-example-the-string-aabccccccaaa-would-become-a2b1c5a3-If-the-“compressed”-string-would-not-become-smaller-than-the-original-string-you-method-should-return-the-original-string-You-can-assume-the-string-has-only-upper-and-lower-case\"><a href=\"#1-5-Implement-a-method-to-perform-basic-string-compression-using-the-counts-of-repeated-characters-For-example-the-string-aabccccccaaa-would-become-a2b1c5a3-If-the-“compressed”-string-would-not-become-smaller-than-the-original-string-you-method-should-return-the-original-string-You-can-assume-the-string-has-only-upper-and-lower-case\" class=\"headerlink\" title=\"1.5 Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabccccccaaa would become a2b1c5a3. If the “compressed” string would not become smaller than the original string, you method should return the original string. You can assume the string has only upper and lower case.\"></a>1.5 Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabccccccaaa would become a2b1c5a3. If the “compressed” string would not become smaller than the original string, you method should return the original string. You can assume the string has only upper and lower case.</h6><ul>\n<li>建立一个新的StringBuffer字符串newstr，和count.</li>\n<li>遍历字符串str, 计算压缩后的长度, 判断两个字符串长度，如果newstr长度不小于str长度，输出str.</li>\n<li>第一个字符写入newstr</li>\n<li>后一个字符和前一个字符相同则count++，不同则将数字写入newstr，后count=0，写入新的字符</li>\n<li>遍历完成，输出newstr</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java\" title=\"Implementation\" target=\"_blank\" rel=\"noopener\">Q1.5_Implementation</a></li>\n</ul>\n<h6 id=\"1-6-Given-an-image-represented-by-an-NxN-matrix-where-each-pixel-in-the-image-is-4-bytes-write-a-method-to-rotate-the-image-by-90-degrees-Can-you-do-this-in-place\"><a href=\"#1-6-Given-an-image-represented-by-an-NxN-matrix-where-each-pixel-in-the-image-is-4-bytes-write-a-method-to-rotate-the-image-by-90-degrees-Can-you-do-this-in-place\" class=\"headerlink\" title=\"1.6 Given an image represented by an NxN matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees. Can you do this in place?\"></a>1.6 Given an image represented by an NxN matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees. Can you do this in place?</h6><ul>\n<li>Do this in place, 即不开辟新的空间，在原数据结构中操作</li>\n<li>我们可以将matrix由外之内分层，一层一层进行旋转操作</li>\n<li><img src=\"https://lh5.googleusercontent.com/-PYq_I9DzGWo/VRnY2DG2GHI/AAAAAAAAANc/k3vpW6fQHaI/w1258-h1230-no/IMG_20150330_191308~2.jpg\" alt=\"\"></li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/matrixHelper.java\" target=\"_blank\" rel=\"noopener\">Q1.6_Implementation</a></li>\n</ul>\n<h6 id=\"1-7-Write-an-algorithm-such-that-if-an-element-in-an-MxN-matrix-is-0-its-entire-row-and-column-are-set-to-0\"><a href=\"#1-7-Write-an-algorithm-such-that-if-an-element-in-an-MxN-matrix-is-0-its-entire-row-and-column-are-set-to-0\" class=\"headerlink\" title=\"1.7 Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0\"></a>1.7 Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0</h6><ul>\n<li>建立两个一维数组，分别对应矩阵的长和宽，并赋值false</li>\n<li>遍历矩阵，遇到0，将对应长款数组中的元素赋值为true</li>\n<li>遍历矩阵，如果当前元素的行号列号在长宽数组中为true，将该元素置为0</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/matrixHelper.java\" target=\"_blank\" rel=\"noopener\">Q1.7_Implementation</a></li>\n</ul>\n<h6 id=\"1-8-Assume-you-have-a-method-isSubstring-which-checks-if-one-word-is-a-substring-of-another-Given-two-strings-s1-and-s2-write-code-to-check-if-s2-is-a-rotation-of-s1-using-only-one-call-to-isString-e-g-“waterbottle”-is-a-rotation-of-“erbottlewat”\"><a href=\"#1-8-Assume-you-have-a-method-isSubstring-which-checks-if-one-word-is-a-substring-of-another-Given-two-strings-s1-and-s2-write-code-to-check-if-s2-is-a-rotation-of-s1-using-only-one-call-to-isString-e-g-“waterbottle”-is-a-rotation-of-“erbottlewat”\" class=\"headerlink\" title=\"1.8 Assume you have a method isSubstring( ) which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to _isString( ) _(e.g., “waterbottle” is a rotation of “erbottlewat”).\"></a>1.8 Assume you have a method <em>isSubstring( )</em> which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to _isString( ) _(e.g., “waterbottle” is a rotation of “erbottlewat”).</h6><ul>\n<li>isSubstring( )可以用 String.isContatin()实现</li>\n<li>如果字符串是一个旋转字符串，则首位应该相连，如“erbottlewat”中 “er”与“wat”相连</li>\n<li>如果将这个字符串，复制拼接“erbottle<strong>wat</strong>”+“<strong>erbottle</strong>wat”=“erbottle<strong>waterbottle</strong>wat”，则其中一定含有一个完整的字串</li>\n<li>所以判断(s1+s1).isSubString(s2)</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java\" title=\"im\" target=\"_blank\" rel=\"noopener\">Q1.8_Implementation</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Chapter-1-Arrays-and-Strings\"><a href=\"#Chapter-1-Arrays-and-Strings\" class=\"headerlink\" title=\"Chapter 1 Arrays and Strings\"></a>Chapter 1 Arrays and Strings</h1><h6 id=\"1-1-Implement-an-algorithm-to-determine-if-a-string-has-all-unique-characters-What-if-you-cannot-use-additional-data-structures\"><a href=\"#1-1-Implement-an-algorithm-to-determine-if-a-string-has-all-unique-characters-What-if-you-cannot-use-additional-data-structures\" class=\"headerlink\" title=\"1.1 Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?\"></a>1.1 Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?</h6><ul>\n<li>首先确定构成字符串的字符集有多大？是ASCII字符，还是只是26个字母？ 还是有更大的字符集，对于不同的情况，我们可能会有不同的解决方案。</li>\n<li>ASCII：标准ASCII 码也叫基础ASCII码，使用8 位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符， ASCII 码表共有<strong>258</strong>位字符。</li>\n<li>如果我们假设字符集是ASCII字符，那么我们可以开一个大小为256的bool数组来表征每个字符的出现。数组初始化为false，遍历一遍字符串中的字符，当bool数组对应位置的值为真， 表明该字符在之前已经出现过，即可得出该字符串中有重复字符。否则将该位置的bool数组 值置为true。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java\" title=\"Implementation\" target=\"_blank\" rel=\"noopener\">Q1.1_Implementation</a></li>\n</ul>\n<h6 id=\"1-2-Implement-a-function-void-reverse-char-str-in-C-or-C-which-reverses-a-null-terminated-string\"><a href=\"#1-2-Implement-a-function-void-reverse-char-str-in-C-or-C-which-reverses-a-null-terminated-string\" class=\"headerlink\" title=\"1.2 Implement a function void reverse(char *str) in C or C++ which reverses a null terminated string.\"></a>1.2 Implement a function void reverse(char *str) in C or C++ which reverses a null terminated string.</h6><ul>\n<li>使用C++位操作,做地址交换。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1              0101110101</span><br><span class=\"line\">b1              1011101011</span><br><span class=\"line\">a2 = a1^b1      1110011110</span><br><span class=\"line\">b2 = a2^b1      0101110101(a1)</span><br><span class=\"line\">a3 = a2^b2      1011101011(b1)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取字符串长度，从首尾两端开始两两交换。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterviewCpp/blob/master/CrackingCodingInterviewCpp/stringHelper.cpp\" title=\"Q1.2_Imp\" target=\"_blank\" rel=\"noopener\">Q1.2_Implementation</a></li>\n</ul>\n<h6 id=\"1-3-Given-two-strings-write-a-method-to-decide-if-one-is-a-permutation-of-the-other\"><a href=\"#1-3-Given-two-strings-write-a-method-to-decide-if-one-is-a-permutation-of-the-other\" class=\"headerlink\" title=\"1.3 Given two strings, write a method to decide if one is a permutation of the other.\"></a>1.3 Given two strings, write a method to decide if one is a permutation of the other.</h6><ul>\n<li>将字符串转换成字符数组（toCharArray()）后排序(Arrays.sort())</li>\n<li>然后比较两个字符数组(Arrays.equals(string a, string b))</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java\" title=\"Implementation\" target=\"_blank\" rel=\"noopener\">Q1.3_Implementation</a></li>\n</ul>\n<h6 id=\"1-4-Write-a-method-to-replace-all-spaces-in-a-string-with-‘-20’-You-may-assume-that-the-string-has-sufficient-space-at-the-end-of-the-string-to-hold-the-additional-characters-and-that-you-are-given-the-“true”-length-of-the-string-Note-if-implementing-in-Java-please-use-a-character-array-so-that-you-can-perform-this-operation-in-place\"><a href=\"#1-4-Write-a-method-to-replace-all-spaces-in-a-string-with-‘-20’-You-may-assume-that-the-string-has-sufficient-space-at-the-end-of-the-string-to-hold-the-additional-characters-and-that-you-are-given-the-“true”-length-of-the-string-Note-if-implementing-in-Java-please-use-a-character-array-so-that-you-can-perform-this-operation-in-place\" class=\"headerlink\" title=\"1.4 Write a method to replace all spaces in a string with ‘%20’. You may assume that the string has sufficient space at the end of the string to hold the additional characters, and that you are given the “true” length of the string.(Note: if implementing in Java, please use a character array so that you can perform this operation in place.)\"></a>1.4 Write a method to replace all spaces in a string with ‘%20’. You may assume that the string has sufficient space at the end of the string to hold the additional characters, and that you are given the “true” length of the string.(Note: if implementing in Java, please use a character array so that you can perform this operation in place.)</h6><p>EXAMPLE</p>\n<p>Input: “Mr_John_Smith”,13</p>\n<p>Output:”Mr%20John%20Smith”</p>\n<ul>\n<li>首先遍历字符串记录空格个数，计算新的 字符串长度=原长度+2*空格数</li>\n<li>将原字符串的内容以此填入新的字符串，遇到空格填入“%20”</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java\" title=\"Implementation\" target=\"_blank\" rel=\"noopener\">Q1.4_Implementation</a></li>\n</ul>\n<h6 id=\"1-5-Implement-a-method-to-perform-basic-string-compression-using-the-counts-of-repeated-characters-For-example-the-string-aabccccccaaa-would-become-a2b1c5a3-If-the-“compressed”-string-would-not-become-smaller-than-the-original-string-you-method-should-return-the-original-string-You-can-assume-the-string-has-only-upper-and-lower-case\"><a href=\"#1-5-Implement-a-method-to-perform-basic-string-compression-using-the-counts-of-repeated-characters-For-example-the-string-aabccccccaaa-would-become-a2b1c5a3-If-the-“compressed”-string-would-not-become-smaller-than-the-original-string-you-method-should-return-the-original-string-You-can-assume-the-string-has-only-upper-and-lower-case\" class=\"headerlink\" title=\"1.5 Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabccccccaaa would become a2b1c5a3. If the “compressed” string would not become smaller than the original string, you method should return the original string. You can assume the string has only upper and lower case.\"></a>1.5 Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabccccccaaa would become a2b1c5a3. If the “compressed” string would not become smaller than the original string, you method should return the original string. You can assume the string has only upper and lower case.</h6><ul>\n<li>建立一个新的StringBuffer字符串newstr，和count.</li>\n<li>遍历字符串str, 计算压缩后的长度, 判断两个字符串长度，如果newstr长度不小于str长度，输出str.</li>\n<li>第一个字符写入newstr</li>\n<li>后一个字符和前一个字符相同则count++，不同则将数字写入newstr，后count=0，写入新的字符</li>\n<li>遍历完成，输出newstr</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java\" title=\"Implementation\" target=\"_blank\" rel=\"noopener\">Q1.5_Implementation</a></li>\n</ul>\n<h6 id=\"1-6-Given-an-image-represented-by-an-NxN-matrix-where-each-pixel-in-the-image-is-4-bytes-write-a-method-to-rotate-the-image-by-90-degrees-Can-you-do-this-in-place\"><a href=\"#1-6-Given-an-image-represented-by-an-NxN-matrix-where-each-pixel-in-the-image-is-4-bytes-write-a-method-to-rotate-the-image-by-90-degrees-Can-you-do-this-in-place\" class=\"headerlink\" title=\"1.6 Given an image represented by an NxN matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees. Can you do this in place?\"></a>1.6 Given an image represented by an NxN matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees. Can you do this in place?</h6><ul>\n<li>Do this in place, 即不开辟新的空间，在原数据结构中操作</li>\n<li>我们可以将matrix由外之内分层，一层一层进行旋转操作</li>\n<li><img src=\"https://lh5.googleusercontent.com/-PYq_I9DzGWo/VRnY2DG2GHI/AAAAAAAAANc/k3vpW6fQHaI/w1258-h1230-no/IMG_20150330_191308~2.jpg\" alt=\"\"></li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/matrixHelper.java\" target=\"_blank\" rel=\"noopener\">Q1.6_Implementation</a></li>\n</ul>\n<h6 id=\"1-7-Write-an-algorithm-such-that-if-an-element-in-an-MxN-matrix-is-0-its-entire-row-and-column-are-set-to-0\"><a href=\"#1-7-Write-an-algorithm-such-that-if-an-element-in-an-MxN-matrix-is-0-its-entire-row-and-column-are-set-to-0\" class=\"headerlink\" title=\"1.7 Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0\"></a>1.7 Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0</h6><ul>\n<li>建立两个一维数组，分别对应矩阵的长和宽，并赋值false</li>\n<li>遍历矩阵，遇到0，将对应长款数组中的元素赋值为true</li>\n<li>遍历矩阵，如果当前元素的行号列号在长宽数组中为true，将该元素置为0</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/matrixHelper.java\" target=\"_blank\" rel=\"noopener\">Q1.7_Implementation</a></li>\n</ul>\n<h6 id=\"1-8-Assume-you-have-a-method-isSubstring-which-checks-if-one-word-is-a-substring-of-another-Given-two-strings-s1-and-s2-write-code-to-check-if-s2-is-a-rotation-of-s1-using-only-one-call-to-isString-e-g-“waterbottle”-is-a-rotation-of-“erbottlewat”\"><a href=\"#1-8-Assume-you-have-a-method-isSubstring-which-checks-if-one-word-is-a-substring-of-another-Given-two-strings-s1-and-s2-write-code-to-check-if-s2-is-a-rotation-of-s1-using-only-one-call-to-isString-e-g-“waterbottle”-is-a-rotation-of-“erbottlewat”\" class=\"headerlink\" title=\"1.8 Assume you have a method isSubstring( ) which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to _isString( ) _(e.g., “waterbottle” is a rotation of “erbottlewat”).\"></a>1.8 Assume you have a method <em>isSubstring( )</em> which checks if one word is a substring of another. Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 using only one call to _isString( ) _(e.g., “waterbottle” is a rotation of “erbottlewat”).</h6><ul>\n<li>isSubstring( )可以用 String.isContatin()实现</li>\n<li>如果字符串是一个旋转字符串，则首位应该相连，如“erbottlewat”中 “er”与“wat”相连</li>\n<li>如果将这个字符串，复制拼接“erbottle<strong>wat</strong>”+“<strong>erbottle</strong>wat”=“erbottle<strong>waterbottle</strong>wat”，则其中一定含有一个完整的字串</li>\n<li>所以判断(s1+s1).isSubString(s2)</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/ArrayString/DataStructures/stringHelper.java\" title=\"im\" target=\"_blank\" rel=\"noopener\">Q1.8_Implementation</a></li>\n</ul>\n"},{"title":"【转载】C++ 位运算详解","id":"34","date":"2015-03-25T21:58:30.000Z","_content":"\n### 位简介\n\n位是数据存储的最小单位。在计算机中的二进制数系统中，位，简记为b,也称为比特，每个0或1就是一个位(bit)。\n\n### 位操作详解\n\n我们先来看看位运算操作符：& (按位与)、| (按位或)、^ (按位异或)、~ (按位取反)、>> (按位右移)、<< (按位左移)。\n\n* **&**（按位与） 从概念上来讲，就是将参与运算的两个分量对应的每一位来做逻辑与运算，若两者都为真（等于1），则结果才为真（等于1）。否则都为假（等于0）。\n即：1 & 1 = 1 、1 & 0 = 0 、0 & 1 = 1、0 & 0 = 0\n这里我们先来看看那一个8位二进制的例子：\n```\n\t7 & 8 = 0000 0111 & 0000 1000 = 0000 0000 = 0\n\t7 & 6 = 0000 0111 & 0000 0110 = 0000 0110 = 6\n```\n* **|** (按位或) 即把参与运算的每个分量对应的每一位来做逻辑或运算，即两者都为假（为0）时，才为假（为0），否则皆为真。\n即：0|0 = 0、1|0 = 1、0|1 = 1、1|1 = 1\n来看看8位二进制的例子：\n```\t\n\t7|8 = 0000 0111 | 0000 1000 = 0000 1111 = 15\n\t7|6 = 0000 0111 | 0000 0110 = 0000 0111 = 7\n```\n* **^**(按位异或) 即把参与运算的每个分量对应的每一位来做异或运算，即两者相同为假，不同为真。\n即：0|0 = 0、 1|0 = 1、0|1 = 1、 1|1 = 0\n看下面的例子:\n```\t\n\t7^8 = 0000 0111 ^ 0000 1000 = 0000 0111 = 7\n\t7^6 = 0000 0111 ^ 0000 0100 = 0000 0011 = 3\n```\n* **~**（按位取反） 即把二进制位的每一位进行取反运算，简而言之就是1变成0，0变成1。\n直接看例子：\n```\t\n\t~7 = ~0000 0111 = 1111 1000 = 248\n```\n* **>>**(按位右移）把二进制位整体向右移动。\n```\t\n\t7 >> 1 = 0000 0111 >> 1 = 0000 0011 = 3\n\t7 >> 2 = 0000 0111 >> 2 = 0000 0001 = 1\n```\n这里右移等于除了2的N次方，N为右移的位数。\n\n* **<<**（按位左移）这里就不详细说了，和右移相反。\n\n### 位操作应用\n\n好了，下面讲讲实际应用吧。\n一、一种颜色的表示方式—- 通过DWORD来表示颜色\n定义：typedef unsigned long DWORD;\n即为一个无符号32位（32机器）长整数，有四个字节，我们从左到右叫他1，2，3，4字节，每一个字节的范围是0～255。第一个字节表示alpha值，即透明度。如果是255，表示不透明，0表示完全透明（看不到），其他分别是R,G,B值。\n可通过下列方法获得每个字节的值：\n\n \tint A = (int)((DWORD & 0xFF000000) >> 24);\n\tint R = (int)((DWORD & 0x00FF0000) >> 16);\n\tint G = (int)((DWORD & 0x0000FF00) >> 8);\n\tint B = (int)(DWORD & 0x000000FF);\n\tDWORD dwColor = (A << 24)+(R << 16)+(G << 8)+B;\n\n有了前面的基础，我相信大家对上面的换算方法，一看就明白吧。如果对16进制不敏感的童鞋，可以用计算机把十六进制换算成二进制，更容易理解。\n\n### 状态系统中的使用\n\n在游戏开发中，我们通常用一个32位（假设这里用32位）的整数来存储角色的状态(这样做主要是为了节约存储空间，同时也减小网络同步消息包的size)。所谓的状态，就是大家熟悉的Buff或者DeBuff。\n\n```C++\nenum ROLE_STATUS\n{\n\tSTATUS_NORMAL = 0, // 正常\n\tSTATUS_DIE = 1, // 死亡状态\n\tSTATUS_GOD , // 无敌\n\tSTATUS_DISAPPEARING , // 消失中状态\n\tSTATUS_DEF_ADJUST , // 物理防御提升/降低\n\tSTATUS_MDEF_ADJUST , // 魔法防御提升/降低\n\tSTATUS_ATK_CRI_ADJUST , // 同时提升物理攻击和爆击率\n\tSTATUS_MAXHP_ADJUST , // HP上限调整\n\tSTATUS_MAXMP_ADJUST , // MP上限提升/降低\n\t//……\n\t这里最多只能写32个，因为我们假设是用32位数据来存储状态。\n};\n```\n\n状态数据定义好了，现在来看看怎么使用他们。\n首先， 角色上线，我要给他一个保护状态，应该这样操作。\n```\nDWORD dwRoleStatus = STATUS_GOD;\n```\n同时，角色使用了一个物品，这个物品的效果时，HP和MP上限增加一段时间。因此要附加调整玩家的HP和MP上限的状态，应该这样。\n```\nDWORD dwRoleStatus |= (STATUS_MAXHP_ADJUST+STATUS_MAXMP_ADJUST);\n```\n这里是|=而不是=操作，因为不能清掉之前附加的无敌保护状态。所以用或运算。\n该角色受到其他玩家或者怪物的攻击，我们要判断被攻击的这个角色的受保护状态状态还在不在。执行如下逻辑\n\n```C++\nif( dwRoleStatus & STATUS_GOD ) // 判断位是否为1\n{\n// 受保护状态，不能被攻击\n}\n```\n\n接下来，角色无敌保护时间过期了，我们要清除无敌状态，执行如下操作\n```dwRoleStatus &= ~STATUS_GOD;```\n这里用到了取反的计算。~STATUS_GOD的结果是第二位为0外，其他都为1。然后和dwRoleStatus做按位与计算。\n```\n\t STATUS_GOD = 0000 0000 0000 0000 0000 0000 0000 0000 0000 0010;\n\t~STATUS_GOD = 1111 1111 1111 1111 1111 1111 1111 1111 1111 1101;\n```\n因此和dwRoleStatus相与之后，dwRoleStatus除了第二位以外的位，都保留下来了。第二位不管是什么值，都会被设置为0,这样子就把STATUS_GOD这个状态清除掉了。同理我们要清除多个状态的时候，先把要清楚的状态或运算到一起。再取反，然后和dwRoleStatus按位与。起到同时清除多个状态。\n然后讲讲异或，它有一个性质是，两次异或，能还原回来\n例如 \n```\n\ta = 7, b = 6;\n\ta = a ^ b ^ b;\n```\n我们来看看那二进制的操作\n```\n\ta = 0111\n\tb = 0110\n\tc = a ^ b = 0001\n\ta = c ^ b = 0111\n```\n写到这里，想到一道经典的C++笔试题，即不需要第3个变量，交换两个变量的值。\n```\n\ta = a ^ b = 0001\n\tb = b ^ a = 0111\n\ta = a ^ b = 0110\n```\n暂时写到这里，想到有补充的，再完善。\n疯刀 2011.6.26","source":"_posts/BitOperation.md","raw":"---\ntitle: 【转载】C++ 位运算详解\nid: 34\ncategories:\n  - C/C++\ndate: 2015-03-25 17:58:30\ntags:\n  - C/C++\n---\n\n### 位简介\n\n位是数据存储的最小单位。在计算机中的二进制数系统中，位，简记为b,也称为比特，每个0或1就是一个位(bit)。\n\n### 位操作详解\n\n我们先来看看位运算操作符：& (按位与)、| (按位或)、^ (按位异或)、~ (按位取反)、>> (按位右移)、<< (按位左移)。\n\n* **&**（按位与） 从概念上来讲，就是将参与运算的两个分量对应的每一位来做逻辑与运算，若两者都为真（等于1），则结果才为真（等于1）。否则都为假（等于0）。\n即：1 & 1 = 1 、1 & 0 = 0 、0 & 1 = 1、0 & 0 = 0\n这里我们先来看看那一个8位二进制的例子：\n```\n\t7 & 8 = 0000 0111 & 0000 1000 = 0000 0000 = 0\n\t7 & 6 = 0000 0111 & 0000 0110 = 0000 0110 = 6\n```\n* **|** (按位或) 即把参与运算的每个分量对应的每一位来做逻辑或运算，即两者都为假（为0）时，才为假（为0），否则皆为真。\n即：0|0 = 0、1|0 = 1、0|1 = 1、1|1 = 1\n来看看8位二进制的例子：\n```\t\n\t7|8 = 0000 0111 | 0000 1000 = 0000 1111 = 15\n\t7|6 = 0000 0111 | 0000 0110 = 0000 0111 = 7\n```\n* **^**(按位异或) 即把参与运算的每个分量对应的每一位来做异或运算，即两者相同为假，不同为真。\n即：0|0 = 0、 1|0 = 1、0|1 = 1、 1|1 = 0\n看下面的例子:\n```\t\n\t7^8 = 0000 0111 ^ 0000 1000 = 0000 0111 = 7\n\t7^6 = 0000 0111 ^ 0000 0100 = 0000 0011 = 3\n```\n* **~**（按位取反） 即把二进制位的每一位进行取反运算，简而言之就是1变成0，0变成1。\n直接看例子：\n```\t\n\t~7 = ~0000 0111 = 1111 1000 = 248\n```\n* **>>**(按位右移）把二进制位整体向右移动。\n```\t\n\t7 >> 1 = 0000 0111 >> 1 = 0000 0011 = 3\n\t7 >> 2 = 0000 0111 >> 2 = 0000 0001 = 1\n```\n这里右移等于除了2的N次方，N为右移的位数。\n\n* **<<**（按位左移）这里就不详细说了，和右移相反。\n\n### 位操作应用\n\n好了，下面讲讲实际应用吧。\n一、一种颜色的表示方式—- 通过DWORD来表示颜色\n定义：typedef unsigned long DWORD;\n即为一个无符号32位（32机器）长整数，有四个字节，我们从左到右叫他1，2，3，4字节，每一个字节的范围是0～255。第一个字节表示alpha值，即透明度。如果是255，表示不透明，0表示完全透明（看不到），其他分别是R,G,B值。\n可通过下列方法获得每个字节的值：\n\n \tint A = (int)((DWORD & 0xFF000000) >> 24);\n\tint R = (int)((DWORD & 0x00FF0000) >> 16);\n\tint G = (int)((DWORD & 0x0000FF00) >> 8);\n\tint B = (int)(DWORD & 0x000000FF);\n\tDWORD dwColor = (A << 24)+(R << 16)+(G << 8)+B;\n\n有了前面的基础，我相信大家对上面的换算方法，一看就明白吧。如果对16进制不敏感的童鞋，可以用计算机把十六进制换算成二进制，更容易理解。\n\n### 状态系统中的使用\n\n在游戏开发中，我们通常用一个32位（假设这里用32位）的整数来存储角色的状态(这样做主要是为了节约存储空间，同时也减小网络同步消息包的size)。所谓的状态，就是大家熟悉的Buff或者DeBuff。\n\n```C++\nenum ROLE_STATUS\n{\n\tSTATUS_NORMAL = 0, // 正常\n\tSTATUS_DIE = 1, // 死亡状态\n\tSTATUS_GOD , // 无敌\n\tSTATUS_DISAPPEARING , // 消失中状态\n\tSTATUS_DEF_ADJUST , // 物理防御提升/降低\n\tSTATUS_MDEF_ADJUST , // 魔法防御提升/降低\n\tSTATUS_ATK_CRI_ADJUST , // 同时提升物理攻击和爆击率\n\tSTATUS_MAXHP_ADJUST , // HP上限调整\n\tSTATUS_MAXMP_ADJUST , // MP上限提升/降低\n\t//……\n\t这里最多只能写32个，因为我们假设是用32位数据来存储状态。\n};\n```\n\n状态数据定义好了，现在来看看怎么使用他们。\n首先， 角色上线，我要给他一个保护状态，应该这样操作。\n```\nDWORD dwRoleStatus = STATUS_GOD;\n```\n同时，角色使用了一个物品，这个物品的效果时，HP和MP上限增加一段时间。因此要附加调整玩家的HP和MP上限的状态，应该这样。\n```\nDWORD dwRoleStatus |= (STATUS_MAXHP_ADJUST+STATUS_MAXMP_ADJUST);\n```\n这里是|=而不是=操作，因为不能清掉之前附加的无敌保护状态。所以用或运算。\n该角色受到其他玩家或者怪物的攻击，我们要判断被攻击的这个角色的受保护状态状态还在不在。执行如下逻辑\n\n```C++\nif( dwRoleStatus & STATUS_GOD ) // 判断位是否为1\n{\n// 受保护状态，不能被攻击\n}\n```\n\n接下来，角色无敌保护时间过期了，我们要清除无敌状态，执行如下操作\n```dwRoleStatus &= ~STATUS_GOD;```\n这里用到了取反的计算。~STATUS_GOD的结果是第二位为0外，其他都为1。然后和dwRoleStatus做按位与计算。\n```\n\t STATUS_GOD = 0000 0000 0000 0000 0000 0000 0000 0000 0000 0010;\n\t~STATUS_GOD = 1111 1111 1111 1111 1111 1111 1111 1111 1111 1101;\n```\n因此和dwRoleStatus相与之后，dwRoleStatus除了第二位以外的位，都保留下来了。第二位不管是什么值，都会被设置为0,这样子就把STATUS_GOD这个状态清除掉了。同理我们要清除多个状态的时候，先把要清楚的状态或运算到一起。再取反，然后和dwRoleStatus按位与。起到同时清除多个状态。\n然后讲讲异或，它有一个性质是，两次异或，能还原回来\n例如 \n```\n\ta = 7, b = 6;\n\ta = a ^ b ^ b;\n```\n我们来看看那二进制的操作\n```\n\ta = 0111\n\tb = 0110\n\tc = a ^ b = 0001\n\ta = c ^ b = 0111\n```\n写到这里，想到一道经典的C++笔试题，即不需要第3个变量，交换两个变量的值。\n```\n\ta = a ^ b = 0001\n\tb = b ^ a = 0111\n\ta = a ^ b = 0110\n```\n暂时写到这里，想到有补充的，再完善。\n疯刀 2011.6.26","slug":"BitOperation","published":1,"updated":"2019-02-10T17:11:09.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk0s0005lkgu8r8duqdw","content":"<h3 id=\"位简介\"><a href=\"#位简介\" class=\"headerlink\" title=\"位简介\"></a>位简介</h3><p>位是数据存储的最小单位。在计算机中的二进制数系统中，位，简记为b,也称为比特，每个0或1就是一个位(bit)。</p>\n<h3 id=\"位操作详解\"><a href=\"#位操作详解\" class=\"headerlink\" title=\"位操作详解\"></a>位操作详解</h3><p>我们先来看看位运算操作符：&amp; (按位与)、| (按位或)、^ (按位异或)、~ (按位取反)、&gt;&gt; (按位右移)、&lt;&lt; (按位左移)。</p>\n<ul>\n<li><p><strong>&amp;</strong>（按位与） 从概念上来讲，就是将参与运算的两个分量对应的每一位来做逻辑与运算，若两者都为真（等于1），则结果才为真（等于1）。否则都为假（等于0）。<br>即：1 &amp; 1 = 1 、1 &amp; 0 = 0 、0 &amp; 1 = 1、0 &amp; 0 = 0<br>这里我们先来看看那一个8位二进制的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 &amp; 8 = 0000 0111 &amp; 0000 1000 = 0000 0000 = 0</span><br><span class=\"line\">7 &amp; 6 = 0000 0111 &amp; 0000 0110 = 0000 0110 = 6</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>|</strong> (按位或) 即把参与运算的每个分量对应的每一位来做逻辑或运算，即两者都为假（为0）时，才为假（为0），否则皆为真。<br>即：0|0 = 0、1|0 = 1、0|1 = 1、1|1 = 1<br>来看看8位二进制的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7|8 = 0000 0111 | 0000 1000 = 0000 1111 = 15</span><br><span class=\"line\">7|6 = 0000 0111 | 0000 0110 = 0000 0111 = 7</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>^</strong>(按位异或) 即把参与运算的每个分量对应的每一位来做异或运算，即两者相同为假，不同为真。<br>即：0|0 = 0、 1|0 = 1、0|1 = 1、 1|1 = 0<br>看下面的例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7^8 = 0000 0111 ^ 0000 1000 = 0000 0111 = 7</span><br><span class=\"line\">7^6 = 0000 0111 ^ 0000 0100 = 0000 0011 = 3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>~</strong>（按位取反） 即把二进制位的每一位进行取反运算，简而言之就是1变成0，0变成1。<br>直接看例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~7 = ~0000 0111 = 1111 1000 = 248</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>&gt;&gt;</strong>(按位右移）把二进制位整体向右移动。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 &gt;&gt; 1 = 0000 0111 &gt;&gt; 1 = 0000 0011 = 3</span><br><span class=\"line\">7 &gt;&gt; 2 = 0000 0111 &gt;&gt; 2 = 0000 0001 = 1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里右移等于除了2的N次方，N为右移的位数。</p>\n<ul>\n<li><strong>&lt;&lt;</strong>（按位左移）这里就不详细说了，和右移相反。</li>\n</ul>\n<h3 id=\"位操作应用\"><a href=\"#位操作应用\" class=\"headerlink\" title=\"位操作应用\"></a>位操作应用</h3><p>好了，下面讲讲实际应用吧。<br>一、一种颜色的表示方式—- 通过DWORD来表示颜色<br>定义：typedef unsigned long DWORD;<br>即为一个无符号32位（32机器）长整数，有四个字节，我们从左到右叫他1，2，3，4字节，每一个字节的范围是0～255。第一个字节表示alpha值，即透明度。如果是255，表示不透明，0表示完全透明（看不到），其他分别是R,G,B值。<br>可通过下列方法获得每个字节的值：</p>\n<pre><code> int A = (int)((DWORD &amp; 0xFF000000) &gt;&gt; 24);\nint R = (int)((DWORD &amp; 0x00FF0000) &gt;&gt; 16);\nint G = (int)((DWORD &amp; 0x0000FF00) &gt;&gt; 8);\nint B = (int)(DWORD &amp; 0x000000FF);\nDWORD dwColor = (A &lt;&lt; 24)+(R &lt;&lt; 16)+(G &lt;&lt; 8)+B;\n</code></pre><p>有了前面的基础，我相信大家对上面的换算方法，一看就明白吧。如果对16进制不敏感的童鞋，可以用计算机把十六进制换算成二进制，更容易理解。</p>\n<h3 id=\"状态系统中的使用\"><a href=\"#状态系统中的使用\" class=\"headerlink\" title=\"状态系统中的使用\"></a>状态系统中的使用</h3><p>在游戏开发中，我们通常用一个32位（假设这里用32位）的整数来存储角色的状态(这样做主要是为了节约存储空间，同时也减小网络同步消息包的size)。所谓的状态，就是大家熟悉的Buff或者DeBuff。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> ROLE_STATUS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSTATUS_NORMAL = <span class=\"number\">0</span>, <span class=\"comment\">// 正常</span></span><br><span class=\"line\">\tSTATUS_DIE = <span class=\"number\">1</span>, <span class=\"comment\">// 死亡状态</span></span><br><span class=\"line\">\tSTATUS_GOD , <span class=\"comment\">// 无敌</span></span><br><span class=\"line\">\tSTATUS_DISAPPEARING , <span class=\"comment\">// 消失中状态</span></span><br><span class=\"line\">\tSTATUS_DEF_ADJUST , <span class=\"comment\">// 物理防御提升/降低</span></span><br><span class=\"line\">\tSTATUS_MDEF_ADJUST , <span class=\"comment\">// 魔法防御提升/降低</span></span><br><span class=\"line\">\tSTATUS_ATK_CRI_ADJUST , <span class=\"comment\">// 同时提升物理攻击和爆击率</span></span><br><span class=\"line\">\tSTATUS_MAXHP_ADJUST , <span class=\"comment\">// HP上限调整</span></span><br><span class=\"line\">\tSTATUS_MAXMP_ADJUST , <span class=\"comment\">// MP上限提升/降低</span></span><br><span class=\"line\">\t<span class=\"comment\">//……</span></span><br><span class=\"line\">\t这里最多只能写<span class=\"number\">32</span>个，因为我们假设是用<span class=\"number\">32</span>位数据来存储状态。</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>状态数据定义好了，现在来看看怎么使用他们。<br>首先， 角色上线，我要给他一个保护状态，应该这样操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DWORD dwRoleStatus = STATUS_GOD;</span><br></pre></td></tr></table></figure></p>\n<p>同时，角色使用了一个物品，这个物品的效果时，HP和MP上限增加一段时间。因此要附加调整玩家的HP和MP上限的状态，应该这样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DWORD dwRoleStatus |= (STATUS_MAXHP_ADJUST+STATUS_MAXMP_ADJUST);</span><br></pre></td></tr></table></figure></p>\n<p>这里是|=而不是=操作，因为不能清掉之前附加的无敌保护状态。所以用或运算。<br>该角色受到其他玩家或者怪物的攻击，我们要判断被攻击的这个角色的受保护状态状态还在不在。执行如下逻辑</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>( dwRoleStatus &amp; STATUS_GOD ) <span class=\"comment\">// 判断位是否为1</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">// 受保护状态，不能被攻击</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，角色无敌保护时间过期了，我们要清除无敌状态，执行如下操作<br><figure class=\"highlight plain\"><figcaption><span>&</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里用到了取反的计算。~STATUS_GOD的结果是第二位为0外，其他都为1。然后和dwRoleStatus做按位与计算。</span><br></pre></td></tr></table></figure></p>\n<pre><code> STATUS_GOD = 0000 0000 0000 0000 0000 0000 0000 0000 0000 0010;\n~STATUS_GOD = 1111 1111 1111 1111 1111 1111 1111 1111 1111 1101;\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">因此和dwRoleStatus相与之后，dwRoleStatus除了第二位以外的位，都保留下来了。第二位不管是什么值，都会被设置为0,这样子就把STATUS_GOD这个状态清除掉了。同理我们要清除多个状态的时候，先把要清楚的状态或运算到一起。再取反，然后和dwRoleStatus按位与。起到同时清除多个状态。</span><br><span class=\"line\">然后讲讲异或，它有一个性质是，两次异或，能还原回来</span><br><span class=\"line\">例如</span><br></pre></td></tr></table></figure>\n<pre><code>a = 7, b = 6;\na = a ^ b ^ b;\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们来看看那二进制的操作</span><br></pre></td></tr></table></figure>\n<pre><code>a = 0111\nb = 0110\nc = a ^ b = 0001\na = c ^ b = 0111\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">写到这里，想到一道经典的C++笔试题，即不需要第3个变量，交换两个变量的值。</span><br></pre></td></tr></table></figure>\n<pre><code>a = a ^ b = 0001\nb = b ^ a = 0111\na = a ^ b = 0110\n</code></pre><p><code>`</code><br>暂时写到这里，想到有补充的，再完善。<br>疯刀 2011.6.26</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"位简介\"><a href=\"#位简介\" class=\"headerlink\" title=\"位简介\"></a>位简介</h3><p>位是数据存储的最小单位。在计算机中的二进制数系统中，位，简记为b,也称为比特，每个0或1就是一个位(bit)。</p>\n<h3 id=\"位操作详解\"><a href=\"#位操作详解\" class=\"headerlink\" title=\"位操作详解\"></a>位操作详解</h3><p>我们先来看看位运算操作符：&amp; (按位与)、| (按位或)、^ (按位异或)、~ (按位取反)、&gt;&gt; (按位右移)、&lt;&lt; (按位左移)。</p>\n<ul>\n<li><p><strong>&amp;</strong>（按位与） 从概念上来讲，就是将参与运算的两个分量对应的每一位来做逻辑与运算，若两者都为真（等于1），则结果才为真（等于1）。否则都为假（等于0）。<br>即：1 &amp; 1 = 1 、1 &amp; 0 = 0 、0 &amp; 1 = 1、0 &amp; 0 = 0<br>这里我们先来看看那一个8位二进制的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 &amp; 8 = 0000 0111 &amp; 0000 1000 = 0000 0000 = 0</span><br><span class=\"line\">7 &amp; 6 = 0000 0111 &amp; 0000 0110 = 0000 0110 = 6</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>|</strong> (按位或) 即把参与运算的每个分量对应的每一位来做逻辑或运算，即两者都为假（为0）时，才为假（为0），否则皆为真。<br>即：0|0 = 0、1|0 = 1、0|1 = 1、1|1 = 1<br>来看看8位二进制的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7|8 = 0000 0111 | 0000 1000 = 0000 1111 = 15</span><br><span class=\"line\">7|6 = 0000 0111 | 0000 0110 = 0000 0111 = 7</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>^</strong>(按位异或) 即把参与运算的每个分量对应的每一位来做异或运算，即两者相同为假，不同为真。<br>即：0|0 = 0、 1|0 = 1、0|1 = 1、 1|1 = 0<br>看下面的例子:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7^8 = 0000 0111 ^ 0000 1000 = 0000 0111 = 7</span><br><span class=\"line\">7^6 = 0000 0111 ^ 0000 0100 = 0000 0011 = 3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>~</strong>（按位取反） 即把二进制位的每一位进行取反运算，简而言之就是1变成0，0变成1。<br>直接看例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~7 = ~0000 0111 = 1111 1000 = 248</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>&gt;&gt;</strong>(按位右移）把二进制位整体向右移动。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 &gt;&gt; 1 = 0000 0111 &gt;&gt; 1 = 0000 0011 = 3</span><br><span class=\"line\">7 &gt;&gt; 2 = 0000 0111 &gt;&gt; 2 = 0000 0001 = 1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里右移等于除了2的N次方，N为右移的位数。</p>\n<ul>\n<li><strong>&lt;&lt;</strong>（按位左移）这里就不详细说了，和右移相反。</li>\n</ul>\n<h3 id=\"位操作应用\"><a href=\"#位操作应用\" class=\"headerlink\" title=\"位操作应用\"></a>位操作应用</h3><p>好了，下面讲讲实际应用吧。<br>一、一种颜色的表示方式—- 通过DWORD来表示颜色<br>定义：typedef unsigned long DWORD;<br>即为一个无符号32位（32机器）长整数，有四个字节，我们从左到右叫他1，2，3，4字节，每一个字节的范围是0～255。第一个字节表示alpha值，即透明度。如果是255，表示不透明，0表示完全透明（看不到），其他分别是R,G,B值。<br>可通过下列方法获得每个字节的值：</p>\n<pre><code> int A = (int)((DWORD &amp; 0xFF000000) &gt;&gt; 24);\nint R = (int)((DWORD &amp; 0x00FF0000) &gt;&gt; 16);\nint G = (int)((DWORD &amp; 0x0000FF00) &gt;&gt; 8);\nint B = (int)(DWORD &amp; 0x000000FF);\nDWORD dwColor = (A &lt;&lt; 24)+(R &lt;&lt; 16)+(G &lt;&lt; 8)+B;\n</code></pre><p>有了前面的基础，我相信大家对上面的换算方法，一看就明白吧。如果对16进制不敏感的童鞋，可以用计算机把十六进制换算成二进制，更容易理解。</p>\n<h3 id=\"状态系统中的使用\"><a href=\"#状态系统中的使用\" class=\"headerlink\" title=\"状态系统中的使用\"></a>状态系统中的使用</h3><p>在游戏开发中，我们通常用一个32位（假设这里用32位）的整数来存储角色的状态(这样做主要是为了节约存储空间，同时也减小网络同步消息包的size)。所谓的状态，就是大家熟悉的Buff或者DeBuff。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> ROLE_STATUS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSTATUS_NORMAL = <span class=\"number\">0</span>, <span class=\"comment\">// 正常</span></span><br><span class=\"line\">\tSTATUS_DIE = <span class=\"number\">1</span>, <span class=\"comment\">// 死亡状态</span></span><br><span class=\"line\">\tSTATUS_GOD , <span class=\"comment\">// 无敌</span></span><br><span class=\"line\">\tSTATUS_DISAPPEARING , <span class=\"comment\">// 消失中状态</span></span><br><span class=\"line\">\tSTATUS_DEF_ADJUST , <span class=\"comment\">// 物理防御提升/降低</span></span><br><span class=\"line\">\tSTATUS_MDEF_ADJUST , <span class=\"comment\">// 魔法防御提升/降低</span></span><br><span class=\"line\">\tSTATUS_ATK_CRI_ADJUST , <span class=\"comment\">// 同时提升物理攻击和爆击率</span></span><br><span class=\"line\">\tSTATUS_MAXHP_ADJUST , <span class=\"comment\">// HP上限调整</span></span><br><span class=\"line\">\tSTATUS_MAXMP_ADJUST , <span class=\"comment\">// MP上限提升/降低</span></span><br><span class=\"line\">\t<span class=\"comment\">//……</span></span><br><span class=\"line\">\t这里最多只能写<span class=\"number\">32</span>个，因为我们假设是用<span class=\"number\">32</span>位数据来存储状态。</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>状态数据定义好了，现在来看看怎么使用他们。<br>首先， 角色上线，我要给他一个保护状态，应该这样操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DWORD dwRoleStatus = STATUS_GOD;</span><br></pre></td></tr></table></figure></p>\n<p>同时，角色使用了一个物品，这个物品的效果时，HP和MP上限增加一段时间。因此要附加调整玩家的HP和MP上限的状态，应该这样。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DWORD dwRoleStatus |= (STATUS_MAXHP_ADJUST+STATUS_MAXMP_ADJUST);</span><br></pre></td></tr></table></figure></p>\n<p>这里是|=而不是=操作，因为不能清掉之前附加的无敌保护状态。所以用或运算。<br>该角色受到其他玩家或者怪物的攻击，我们要判断被攻击的这个角色的受保护状态状态还在不在。执行如下逻辑</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>( dwRoleStatus &amp; STATUS_GOD ) <span class=\"comment\">// 判断位是否为1</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">// 受保护状态，不能被攻击</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，角色无敌保护时间过期了，我们要清除无敌状态，执行如下操作<br><figure class=\"highlight plain\"><figcaption><span>&</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里用到了取反的计算。~STATUS_GOD的结果是第二位为0外，其他都为1。然后和dwRoleStatus做按位与计算。</span><br></pre></td></tr></table></figure></p>\n<pre><code> STATUS_GOD = 0000 0000 0000 0000 0000 0000 0000 0000 0000 0010;\n~STATUS_GOD = 1111 1111 1111 1111 1111 1111 1111 1111 1111 1101;\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">因此和dwRoleStatus相与之后，dwRoleStatus除了第二位以外的位，都保留下来了。第二位不管是什么值，都会被设置为0,这样子就把STATUS_GOD这个状态清除掉了。同理我们要清除多个状态的时候，先把要清楚的状态或运算到一起。再取反，然后和dwRoleStatus按位与。起到同时清除多个状态。</span><br><span class=\"line\">然后讲讲异或，它有一个性质是，两次异或，能还原回来</span><br><span class=\"line\">例如</span><br></pre></td></tr></table></figure>\n<pre><code>a = 7, b = 6;\na = a ^ b ^ b;\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们来看看那二进制的操作</span><br></pre></td></tr></table></figure>\n<pre><code>a = 0111\nb = 0110\nc = a ^ b = 0001\na = c ^ b = 0111\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">写到这里，想到一道经典的C++笔试题，即不需要第3个变量，交换两个变量的值。</span><br></pre></td></tr></table></figure>\n<pre><code>a = a ^ b = 0001\nb = b ^ a = 0111\na = a ^ b = 0110\n</code></pre><p><code>`</code><br>暂时写到这里，想到有补充的，再完善。<br>疯刀 2011.6.26</p>\n"},{"title":"Cracking the Coding Interview - Chapter 13 C and C++","id":"71","date":"2015-04-09T18:59:05.000Z","_content":"\n## Chapter 13 C and C++\n\n###### 13.1 Write a method to print the last K lines of an input file using C++.\n\n*   用c++，写一个方法可以打印一个文件的最后k行\n*   使用一个大小为K的string数组来循环保存每行字符串，这样最后到文件结尾，数组中就剩下的是最后K行\n*   倒数第K行（正数i行）保存在数组 i%k的位置\n*   [Q13.1_Implementation](https://github.com/godlzr/CrackingCodingInterviewCpp/blob/master/CrackingCodingInterviewCpp/printLastKLines.cpp)\n\n###### 13.2 Compare and contrast a hash table and an STL map. How is a hash table implemented? If the number of inputs is small, which data structure options can be used instead of a hash table?\n\n*   **对比哈希表和STL map**\n在哈希表中，实值的存储位置由其键值对应的哈希函数值决定。因此， 存储在哈希表中的值是无序的。在哈希表中插入元素和查找元素的时间复杂度都是O(1)。 (假设冲突很少)。实现一个哈希表，冲突处理是必须要考虑的。\n\n对于STL中的map，键/值对在其中是根据键进行排序的。它使用一根**红黑树**来保存数据， 因此插入和查找元素的时间复杂度都是**O(logn)**。而且不需要处理冲突问题。 STL中的map适合以下情况使用：\n\n1.  查找最小元素\n2.  查找最大元素\n3.  有序地输出元素\n4.  查找某个元素，或是当元素找不到时，查找比它大的最小元素\n\n*   **哈希表是怎么实现**\n\n1.  首先需要一个好的哈希函数来确保哈希值是均匀分布的。比如：对大质数取模\n2.  其次需要一个好的冲突解决方法：链表法(chaining，表中元素比较密集时用此法)， 探测法(probing，开放地址法，表中元素比较稀疏时用此法)。\n3.  动态地增加或减少哈希表的大小。比如，(表中元素数量)/(表大小)大于一个阈值时， 就增加哈希表的大小。我们新建一个大的哈希表，然后将旧表中的元素值， 通过新的哈希函数映射到新表。\n\n*   **如果输入数据规模不大，我们可以使用什么数据结构来代替哈希表。**\n你可以使用STL map来代替哈希表，尽管插入和查找元素的时间复杂度是O(logn)， 但由于输入数据的规模不大，因此这点时间差别可以忽略不计。\n\n###### 13.3 How do virtual functions work in C++?\n\n*   虚函数依赖虚函数表进行工作。如果一个类中，有函数被关键词virtual进行修饰， 那么一个虚函数表就会被构建起来保存这个类中虚函数的地址。同时， 编译器会为这个类添加一个隐藏指针指向虚函数表。如果在派生类中没有重写虚函数， 那么，派生类中虚表存储的是父类虚函数的地址。每当虚函数被调用时， 虚表会决定具体去调用哪个函数。因此，C++中的动态绑定是通过虚函数表机制进行的。\n*   当我们用基类指针指向派生类时，虚表指针vptr指向派生类的虚函数表。 这个机制可以保证派生类中的虚函数被调用到。\n*   C++中非虚函数的调用是在编译期静态绑定的， 而虚函数的调用则是在执行时才进行动态绑定。\n\n###### 13.4 What is the difference between deep cop and shallow copy? Explain how you would usd each.\n\n*   浅拷贝并不复制数据，只复制指向数据的指针，因此是多个指针指向同一份数据。 深拷贝会复制原始数据，每个指针指向一份独立的数据。\n*   浅拷贝在构造和删除对象时容易产生问题，因此使用时要十分小心。如无必要， 尽量不用浅拷贝。当我们要传递复杂结构的信息，而又不想产生另一份数据时， 可以使用浅拷贝，比如引用传参。浅拷贝特别需要注意的就是析构时的问题， 当多个指针指向同一份内存时，删除这些指针将导致多次释放同一内存而出错。\n*   实际情况下是很少使用浅拷贝的，而智能指针是浅拷贝概念的增强。 比如智能指针可以维护一个引用计数来表明指向某块内存的指针数量， 只有当引用计数减至0时，才真正释放内存。\n*   大部分时候，我们用的是深拷贝，特别是当拷贝的结构不大的时候。\n\n###### 13.5 What is the significance of the keyword \"volatile\" in C?\n\n*   volatile的意思是\"易变的\"，因为访问寄存器比访问内存要快得多， 所以编译器一般都会做减少存取内存的优化。volatile 这个关键字会提醒编译器，它声明的变量随时可能发生变化(在外部被修改)， 因此，与该变量相关的代码不要进行编译优化，以免出错。\n*   volatile在声明上的使用和const是一样的。volatile在*号左边， 修饰的是指针所指物；在*号右边修饰的是指针。\n*\n\n###### 13.6 Why does a destructor in base class need to be declared virtual?\n\n*   用对象指针来调用一个函数，有以下两种情况：\n\n    1.  如果是虚函数，会调用派生类中的版本。\n    2.  如果是非虚函数，会调用指针所指类型的实现版本。\n\n*   析构函数也会遵循以上两种情况，因为析构函数也是函数嘛，不要把它看得太特殊。 当对象出了作用域或是我们删除对象指针，析构函数就会被调用。\n*   当派生类对象出了作用域，派生类的析构函数会先调用，然后再调用它父类的析构函数， 这样能保证分配给对象的内存得到正确释放。\n*   但是，如果我们删除一个指向派生类对象的基类指针，而基类析构函数又是非虚的话， 那么就会先调用基类的析构函数(上面第2种情况)，派生类的析构函数得不到调用。\n*   如果我们把基类的析构函数声明为虚析构函数，这会使得所有派生类的析构函数也为虚。 从而使析构函数得到正确调用。\n*   因此，如果我们可能会删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 事实上，《Effective C++》中的观点是，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数。\n\n###### 13.7 Write a method that takes a pointer to a Node structure as a parameter na dreturns a complete copy of the passed in data structure. The Node data structure contains two pointers to other Nodes.\n\n###### 13.8 Write a smart pointer class. A smart pointer is a data type, usually implemented with templates, that simulates a pointer while also providing automatic garbage collection. It automatically counts the number of references to a SmartPointer&lt;T*&gt; object and frees the object of type T when the reference count hits zero.\n\n###### 13.9 Write an aligned malloc and free function that supports allocating memory such that the memory address returned is divisible by a specific power of two.\n\n###### EXAMPLE\n\n###### align_malloc(1000, 128) will return a memory address that is a multiple of 128 and that points to memory of size 1000 bytes.\n\n###### aligned_free() will free memory allocated by align_malloc.\n\n###### 13.10 Write a function in C called my2DAlloc which allocates a two-dimensional array. Minimize the number of calls to malloc and make sure that the memory is accessible by the notation arr[i][j].","source":"_posts/CCI_Chapter13.md","raw":"---\ntitle: Cracking the Coding Interview - Chapter 13 C and C++\nid: 71\ncategories:\n  - Cracking the Coding Interview (Fifth edition)\ndate: 2015-04-09 14:59:05\ntags:\n---\n\n## Chapter 13 C and C++\n\n###### 13.1 Write a method to print the last K lines of an input file using C++.\n\n*   用c++，写一个方法可以打印一个文件的最后k行\n*   使用一个大小为K的string数组来循环保存每行字符串，这样最后到文件结尾，数组中就剩下的是最后K行\n*   倒数第K行（正数i行）保存在数组 i%k的位置\n*   [Q13.1_Implementation](https://github.com/godlzr/CrackingCodingInterviewCpp/blob/master/CrackingCodingInterviewCpp/printLastKLines.cpp)\n\n###### 13.2 Compare and contrast a hash table and an STL map. How is a hash table implemented? If the number of inputs is small, which data structure options can be used instead of a hash table?\n\n*   **对比哈希表和STL map**\n在哈希表中，实值的存储位置由其键值对应的哈希函数值决定。因此， 存储在哈希表中的值是无序的。在哈希表中插入元素和查找元素的时间复杂度都是O(1)。 (假设冲突很少)。实现一个哈希表，冲突处理是必须要考虑的。\n\n对于STL中的map，键/值对在其中是根据键进行排序的。它使用一根**红黑树**来保存数据， 因此插入和查找元素的时间复杂度都是**O(logn)**。而且不需要处理冲突问题。 STL中的map适合以下情况使用：\n\n1.  查找最小元素\n2.  查找最大元素\n3.  有序地输出元素\n4.  查找某个元素，或是当元素找不到时，查找比它大的最小元素\n\n*   **哈希表是怎么实现**\n\n1.  首先需要一个好的哈希函数来确保哈希值是均匀分布的。比如：对大质数取模\n2.  其次需要一个好的冲突解决方法：链表法(chaining，表中元素比较密集时用此法)， 探测法(probing，开放地址法，表中元素比较稀疏时用此法)。\n3.  动态地增加或减少哈希表的大小。比如，(表中元素数量)/(表大小)大于一个阈值时， 就增加哈希表的大小。我们新建一个大的哈希表，然后将旧表中的元素值， 通过新的哈希函数映射到新表。\n\n*   **如果输入数据规模不大，我们可以使用什么数据结构来代替哈希表。**\n你可以使用STL map来代替哈希表，尽管插入和查找元素的时间复杂度是O(logn)， 但由于输入数据的规模不大，因此这点时间差别可以忽略不计。\n\n###### 13.3 How do virtual functions work in C++?\n\n*   虚函数依赖虚函数表进行工作。如果一个类中，有函数被关键词virtual进行修饰， 那么一个虚函数表就会被构建起来保存这个类中虚函数的地址。同时， 编译器会为这个类添加一个隐藏指针指向虚函数表。如果在派生类中没有重写虚函数， 那么，派生类中虚表存储的是父类虚函数的地址。每当虚函数被调用时， 虚表会决定具体去调用哪个函数。因此，C++中的动态绑定是通过虚函数表机制进行的。\n*   当我们用基类指针指向派生类时，虚表指针vptr指向派生类的虚函数表。 这个机制可以保证派生类中的虚函数被调用到。\n*   C++中非虚函数的调用是在编译期静态绑定的， 而虚函数的调用则是在执行时才进行动态绑定。\n\n###### 13.4 What is the difference between deep cop and shallow copy? Explain how you would usd each.\n\n*   浅拷贝并不复制数据，只复制指向数据的指针，因此是多个指针指向同一份数据。 深拷贝会复制原始数据，每个指针指向一份独立的数据。\n*   浅拷贝在构造和删除对象时容易产生问题，因此使用时要十分小心。如无必要， 尽量不用浅拷贝。当我们要传递复杂结构的信息，而又不想产生另一份数据时， 可以使用浅拷贝，比如引用传参。浅拷贝特别需要注意的就是析构时的问题， 当多个指针指向同一份内存时，删除这些指针将导致多次释放同一内存而出错。\n*   实际情况下是很少使用浅拷贝的，而智能指针是浅拷贝概念的增强。 比如智能指针可以维护一个引用计数来表明指向某块内存的指针数量， 只有当引用计数减至0时，才真正释放内存。\n*   大部分时候，我们用的是深拷贝，特别是当拷贝的结构不大的时候。\n\n###### 13.5 What is the significance of the keyword \"volatile\" in C?\n\n*   volatile的意思是\"易变的\"，因为访问寄存器比访问内存要快得多， 所以编译器一般都会做减少存取内存的优化。volatile 这个关键字会提醒编译器，它声明的变量随时可能发生变化(在外部被修改)， 因此，与该变量相关的代码不要进行编译优化，以免出错。\n*   volatile在声明上的使用和const是一样的。volatile在*号左边， 修饰的是指针所指物；在*号右边修饰的是指针。\n*\n\n###### 13.6 Why does a destructor in base class need to be declared virtual?\n\n*   用对象指针来调用一个函数，有以下两种情况：\n\n    1.  如果是虚函数，会调用派生类中的版本。\n    2.  如果是非虚函数，会调用指针所指类型的实现版本。\n\n*   析构函数也会遵循以上两种情况，因为析构函数也是函数嘛，不要把它看得太特殊。 当对象出了作用域或是我们删除对象指针，析构函数就会被调用。\n*   当派生类对象出了作用域，派生类的析构函数会先调用，然后再调用它父类的析构函数， 这样能保证分配给对象的内存得到正确释放。\n*   但是，如果我们删除一个指向派生类对象的基类指针，而基类析构函数又是非虚的话， 那么就会先调用基类的析构函数(上面第2种情况)，派生类的析构函数得不到调用。\n*   如果我们把基类的析构函数声明为虚析构函数，这会使得所有派生类的析构函数也为虚。 从而使析构函数得到正确调用。\n*   因此，如果我们可能会删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 事实上，《Effective C++》中的观点是，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数。\n\n###### 13.7 Write a method that takes a pointer to a Node structure as a parameter na dreturns a complete copy of the passed in data structure. The Node data structure contains two pointers to other Nodes.\n\n###### 13.8 Write a smart pointer class. A smart pointer is a data type, usually implemented with templates, that simulates a pointer while also providing automatic garbage collection. It automatically counts the number of references to a SmartPointer&lt;T*&gt; object and frees the object of type T when the reference count hits zero.\n\n###### 13.9 Write an aligned malloc and free function that supports allocating memory such that the memory address returned is divisible by a specific power of two.\n\n###### EXAMPLE\n\n###### align_malloc(1000, 128) will return a memory address that is a multiple of 128 and that points to memory of size 1000 bytes.\n\n###### aligned_free() will free memory allocated by align_malloc.\n\n###### 13.10 Write a function in C called my2DAlloc which allocates a two-dimensional array. Minimize the number of calls to malloc and make sure that the memory is accessible by the notation arr[i][j].","slug":"CCI_Chapter13","published":1,"updated":"2019-02-10T17:11:09.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk0u0008lkguxn6fi9tl","content":"<h2 id=\"Chapter-13-C-and-C\"><a href=\"#Chapter-13-C-and-C\" class=\"headerlink\" title=\"Chapter 13 C and C++\"></a>Chapter 13 C and C++</h2><h6 id=\"13-1-Write-a-method-to-print-the-last-K-lines-of-an-input-file-using-C\"><a href=\"#13-1-Write-a-method-to-print-the-last-K-lines-of-an-input-file-using-C\" class=\"headerlink\" title=\"13.1 Write a method to print the last K lines of an input file using C++.\"></a>13.1 Write a method to print the last K lines of an input file using C++.</h6><ul>\n<li>用c++，写一个方法可以打印一个文件的最后k行</li>\n<li>使用一个大小为K的string数组来循环保存每行字符串，这样最后到文件结尾，数组中就剩下的是最后K行</li>\n<li>倒数第K行（正数i行）保存在数组 i%k的位置</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterviewCpp/blob/master/CrackingCodingInterviewCpp/printLastKLines.cpp\" target=\"_blank\" rel=\"noopener\">Q13.1_Implementation</a></li>\n</ul>\n<h6 id=\"13-2-Compare-and-contrast-a-hash-table-and-an-STL-map-How-is-a-hash-table-implemented-If-the-number-of-inputs-is-small-which-data-structure-options-can-be-used-instead-of-a-hash-table\"><a href=\"#13-2-Compare-and-contrast-a-hash-table-and-an-STL-map-How-is-a-hash-table-implemented-If-the-number-of-inputs-is-small-which-data-structure-options-can-be-used-instead-of-a-hash-table\" class=\"headerlink\" title=\"13.2 Compare and contrast a hash table and an STL map. How is a hash table implemented? If the number of inputs is small, which data structure options can be used instead of a hash table?\"></a>13.2 Compare and contrast a hash table and an STL map. How is a hash table implemented? If the number of inputs is small, which data structure options can be used instead of a hash table?</h6><ul>\n<li><strong>对比哈希表和STL map</strong><br>在哈希表中，实值的存储位置由其键值对应的哈希函数值决定。因此， 存储在哈希表中的值是无序的。在哈希表中插入元素和查找元素的时间复杂度都是O(1)。 (假设冲突很少)。实现一个哈希表，冲突处理是必须要考虑的。</li>\n</ul>\n<p>对于STL中的map，键/值对在其中是根据键进行排序的。它使用一根<strong>红黑树</strong>来保存数据， 因此插入和查找元素的时间复杂度都是<strong>O(logn)</strong>。而且不需要处理冲突问题。 STL中的map适合以下情况使用：</p>\n<ol>\n<li>查找最小元素</li>\n<li>查找最大元素</li>\n<li>有序地输出元素</li>\n<li>查找某个元素，或是当元素找不到时，查找比它大的最小元素</li>\n</ol>\n<ul>\n<li><strong>哈希表是怎么实现</strong></li>\n</ul>\n<ol>\n<li>首先需要一个好的哈希函数来确保哈希值是均匀分布的。比如：对大质数取模</li>\n<li>其次需要一个好的冲突解决方法：链表法(chaining，表中元素比较密集时用此法)， 探测法(probing，开放地址法，表中元素比较稀疏时用此法)。</li>\n<li>动态地增加或减少哈希表的大小。比如，(表中元素数量)/(表大小)大于一个阈值时， 就增加哈希表的大小。我们新建一个大的哈希表，然后将旧表中的元素值， 通过新的哈希函数映射到新表。</li>\n</ol>\n<ul>\n<li><strong>如果输入数据规模不大，我们可以使用什么数据结构来代替哈希表。</strong><br>你可以使用STL map来代替哈希表，尽管插入和查找元素的时间复杂度是O(logn)， 但由于输入数据的规模不大，因此这点时间差别可以忽略不计。</li>\n</ul>\n<h6 id=\"13-3-How-do-virtual-functions-work-in-C\"><a href=\"#13-3-How-do-virtual-functions-work-in-C\" class=\"headerlink\" title=\"13.3 How do virtual functions work in C++?\"></a>13.3 How do virtual functions work in C++?</h6><ul>\n<li>虚函数依赖虚函数表进行工作。如果一个类中，有函数被关键词virtual进行修饰， 那么一个虚函数表就会被构建起来保存这个类中虚函数的地址。同时， 编译器会为这个类添加一个隐藏指针指向虚函数表。如果在派生类中没有重写虚函数， 那么，派生类中虚表存储的是父类虚函数的地址。每当虚函数被调用时， 虚表会决定具体去调用哪个函数。因此，C++中的动态绑定是通过虚函数表机制进行的。</li>\n<li>当我们用基类指针指向派生类时，虚表指针vptr指向派生类的虚函数表。 这个机制可以保证派生类中的虚函数被调用到。</li>\n<li>C++中非虚函数的调用是在编译期静态绑定的， 而虚函数的调用则是在执行时才进行动态绑定。</li>\n</ul>\n<h6 id=\"13-4-What-is-the-difference-between-deep-cop-and-shallow-copy-Explain-how-you-would-usd-each\"><a href=\"#13-4-What-is-the-difference-between-deep-cop-and-shallow-copy-Explain-how-you-would-usd-each\" class=\"headerlink\" title=\"13.4 What is the difference between deep cop and shallow copy? Explain how you would usd each.\"></a>13.4 What is the difference between deep cop and shallow copy? Explain how you would usd each.</h6><ul>\n<li>浅拷贝并不复制数据，只复制指向数据的指针，因此是多个指针指向同一份数据。 深拷贝会复制原始数据，每个指针指向一份独立的数据。</li>\n<li>浅拷贝在构造和删除对象时容易产生问题，因此使用时要十分小心。如无必要， 尽量不用浅拷贝。当我们要传递复杂结构的信息，而又不想产生另一份数据时， 可以使用浅拷贝，比如引用传参。浅拷贝特别需要注意的就是析构时的问题， 当多个指针指向同一份内存时，删除这些指针将导致多次释放同一内存而出错。</li>\n<li>实际情况下是很少使用浅拷贝的，而智能指针是浅拷贝概念的增强。 比如智能指针可以维护一个引用计数来表明指向某块内存的指针数量， 只有当引用计数减至0时，才真正释放内存。</li>\n<li>大部分时候，我们用的是深拷贝，特别是当拷贝的结构不大的时候。</li>\n</ul>\n<h6 id=\"13-5-What-is-the-significance-of-the-keyword-“volatile”-in-C\"><a href=\"#13-5-What-is-the-significance-of-the-keyword-“volatile”-in-C\" class=\"headerlink\" title=\"13.5 What is the significance of the keyword “volatile” in C?\"></a>13.5 What is the significance of the keyword “volatile” in C?</h6><ul>\n<li>volatile的意思是”易变的”，因为访问寄存器比访问内存要快得多， 所以编译器一般都会做减少存取内存的优化。volatile 这个关键字会提醒编译器，它声明的变量随时可能发生变化(在外部被修改)， 因此，与该变量相关的代码不要进行编译优化，以免出错。</li>\n<li>volatile在声明上的使用和const是一样的。volatile在<em>号左边， 修饰的是指针所指物；在</em>号右边修饰的是指针。<br>*</li>\n</ul>\n<h6 id=\"13-6-Why-does-a-destructor-in-base-class-need-to-be-declared-virtual\"><a href=\"#13-6-Why-does-a-destructor-in-base-class-need-to-be-declared-virtual\" class=\"headerlink\" title=\"13.6 Why does a destructor in base class need to be declared virtual?\"></a>13.6 Why does a destructor in base class need to be declared virtual?</h6><ul>\n<li><p>用对象指针来调用一个函数，有以下两种情况：</p>\n<ol>\n<li>如果是虚函数，会调用派生类中的版本。</li>\n<li>如果是非虚函数，会调用指针所指类型的实现版本。</li>\n</ol>\n</li>\n<li><p>析构函数也会遵循以上两种情况，因为析构函数也是函数嘛，不要把它看得太特殊。 当对象出了作用域或是我们删除对象指针，析构函数就会被调用。</p>\n</li>\n<li>当派生类对象出了作用域，派生类的析构函数会先调用，然后再调用它父类的析构函数， 这样能保证分配给对象的内存得到正确释放。</li>\n<li>但是，如果我们删除一个指向派生类对象的基类指针，而基类析构函数又是非虚的话， 那么就会先调用基类的析构函数(上面第2种情况)，派生类的析构函数得不到调用。</li>\n<li>如果我们把基类的析构函数声明为虚析构函数，这会使得所有派生类的析构函数也为虚。 从而使析构函数得到正确调用。</li>\n<li>因此，如果我们可能会删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 事实上，《Effective C++》中的观点是，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数。</li>\n</ul>\n<h6 id=\"13-7-Write-a-method-that-takes-a-pointer-to-a-Node-structure-as-a-parameter-na-dreturns-a-complete-copy-of-the-passed-in-data-structure-The-Node-data-structure-contains-two-pointers-to-other-Nodes\"><a href=\"#13-7-Write-a-method-that-takes-a-pointer-to-a-Node-structure-as-a-parameter-na-dreturns-a-complete-copy-of-the-passed-in-data-structure-The-Node-data-structure-contains-two-pointers-to-other-Nodes\" class=\"headerlink\" title=\"13.7 Write a method that takes a pointer to a Node structure as a parameter na dreturns a complete copy of the passed in data structure. The Node data structure contains two pointers to other Nodes.\"></a>13.7 Write a method that takes a pointer to a Node structure as a parameter na dreturns a complete copy of the passed in data structure. The Node data structure contains two pointers to other Nodes.</h6><h6 id=\"13-8-Write-a-smart-pointer-class-A-smart-pointer-is-a-data-type-usually-implemented-with-templates-that-simulates-a-pointer-while-also-providing-automatic-garbage-collection-It-automatically-counts-the-number-of-references-to-a-SmartPointer-lt-T-gt-object-and-frees-the-object-of-type-T-when-the-reference-count-hits-zero\"><a href=\"#13-8-Write-a-smart-pointer-class-A-smart-pointer-is-a-data-type-usually-implemented-with-templates-that-simulates-a-pointer-while-also-providing-automatic-garbage-collection-It-automatically-counts-the-number-of-references-to-a-SmartPointer-lt-T-gt-object-and-frees-the-object-of-type-T-when-the-reference-count-hits-zero\" class=\"headerlink\" title=\"13.8 Write a smart pointer class. A smart pointer is a data type, usually implemented with templates, that simulates a pointer while also providing automatic garbage collection. It automatically counts the number of references to a SmartPointer&lt;T*&gt; object and frees the object of type T when the reference count hits zero.\"></a>13.8 Write a smart pointer class. A smart pointer is a data type, usually implemented with templates, that simulates a pointer while also providing automatic garbage collection. It automatically counts the number of references to a SmartPointer&lt;T*&gt; object and frees the object of type T when the reference count hits zero.</h6><h6 id=\"13-9-Write-an-aligned-malloc-and-free-function-that-supports-allocating-memory-such-that-the-memory-address-returned-is-divisible-by-a-specific-power-of-two\"><a href=\"#13-9-Write-an-aligned-malloc-and-free-function-that-supports-allocating-memory-such-that-the-memory-address-returned-is-divisible-by-a-specific-power-of-two\" class=\"headerlink\" title=\"13.9 Write an aligned malloc and free function that supports allocating memory such that the memory address returned is divisible by a specific power of two.\"></a>13.9 Write an aligned malloc and free function that supports allocating memory such that the memory address returned is divisible by a specific power of two.</h6><h6 id=\"EXAMPLE\"><a href=\"#EXAMPLE\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h6><h6 id=\"align-malloc-1000-128-will-return-a-memory-address-that-is-a-multiple-of-128-and-that-points-to-memory-of-size-1000-bytes\"><a href=\"#align-malloc-1000-128-will-return-a-memory-address-that-is-a-multiple-of-128-and-that-points-to-memory-of-size-1000-bytes\" class=\"headerlink\" title=\"align_malloc(1000, 128) will return a memory address that is a multiple of 128 and that points to memory of size 1000 bytes.\"></a>align_malloc(1000, 128) will return a memory address that is a multiple of 128 and that points to memory of size 1000 bytes.</h6><h6 id=\"aligned-free-will-free-memory-allocated-by-align-malloc\"><a href=\"#aligned-free-will-free-memory-allocated-by-align-malloc\" class=\"headerlink\" title=\"aligned_free() will free memory allocated by align_malloc.\"></a>aligned_free() will free memory allocated by align_malloc.</h6><h6 id=\"13-10-Write-a-function-in-C-called-my2DAlloc-which-allocates-a-two-dimensional-array-Minimize-the-number-of-calls-to-malloc-and-make-sure-that-the-memory-is-accessible-by-the-notation-arr-i-j\"><a href=\"#13-10-Write-a-function-in-C-called-my2DAlloc-which-allocates-a-two-dimensional-array-Minimize-the-number-of-calls-to-malloc-and-make-sure-that-the-memory-is-accessible-by-the-notation-arr-i-j\" class=\"headerlink\" title=\"13.10 Write a function in C called my2DAlloc which allocates a two-dimensional array. Minimize the number of calls to malloc and make sure that the memory is accessible by the notation arr[i][j].\"></a>13.10 Write a function in C called my2DAlloc which allocates a two-dimensional array. Minimize the number of calls to malloc and make sure that the memory is accessible by the notation arr[i][j].</h6>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Chapter-13-C-and-C\"><a href=\"#Chapter-13-C-and-C\" class=\"headerlink\" title=\"Chapter 13 C and C++\"></a>Chapter 13 C and C++</h2><h6 id=\"13-1-Write-a-method-to-print-the-last-K-lines-of-an-input-file-using-C\"><a href=\"#13-1-Write-a-method-to-print-the-last-K-lines-of-an-input-file-using-C\" class=\"headerlink\" title=\"13.1 Write a method to print the last K lines of an input file using C++.\"></a>13.1 Write a method to print the last K lines of an input file using C++.</h6><ul>\n<li>用c++，写一个方法可以打印一个文件的最后k行</li>\n<li>使用一个大小为K的string数组来循环保存每行字符串，这样最后到文件结尾，数组中就剩下的是最后K行</li>\n<li>倒数第K行（正数i行）保存在数组 i%k的位置</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterviewCpp/blob/master/CrackingCodingInterviewCpp/printLastKLines.cpp\" target=\"_blank\" rel=\"noopener\">Q13.1_Implementation</a></li>\n</ul>\n<h6 id=\"13-2-Compare-and-contrast-a-hash-table-and-an-STL-map-How-is-a-hash-table-implemented-If-the-number-of-inputs-is-small-which-data-structure-options-can-be-used-instead-of-a-hash-table\"><a href=\"#13-2-Compare-and-contrast-a-hash-table-and-an-STL-map-How-is-a-hash-table-implemented-If-the-number-of-inputs-is-small-which-data-structure-options-can-be-used-instead-of-a-hash-table\" class=\"headerlink\" title=\"13.2 Compare and contrast a hash table and an STL map. How is a hash table implemented? If the number of inputs is small, which data structure options can be used instead of a hash table?\"></a>13.2 Compare and contrast a hash table and an STL map. How is a hash table implemented? If the number of inputs is small, which data structure options can be used instead of a hash table?</h6><ul>\n<li><strong>对比哈希表和STL map</strong><br>在哈希表中，实值的存储位置由其键值对应的哈希函数值决定。因此， 存储在哈希表中的值是无序的。在哈希表中插入元素和查找元素的时间复杂度都是O(1)。 (假设冲突很少)。实现一个哈希表，冲突处理是必须要考虑的。</li>\n</ul>\n<p>对于STL中的map，键/值对在其中是根据键进行排序的。它使用一根<strong>红黑树</strong>来保存数据， 因此插入和查找元素的时间复杂度都是<strong>O(logn)</strong>。而且不需要处理冲突问题。 STL中的map适合以下情况使用：</p>\n<ol>\n<li>查找最小元素</li>\n<li>查找最大元素</li>\n<li>有序地输出元素</li>\n<li>查找某个元素，或是当元素找不到时，查找比它大的最小元素</li>\n</ol>\n<ul>\n<li><strong>哈希表是怎么实现</strong></li>\n</ul>\n<ol>\n<li>首先需要一个好的哈希函数来确保哈希值是均匀分布的。比如：对大质数取模</li>\n<li>其次需要一个好的冲突解决方法：链表法(chaining，表中元素比较密集时用此法)， 探测法(probing，开放地址法，表中元素比较稀疏时用此法)。</li>\n<li>动态地增加或减少哈希表的大小。比如，(表中元素数量)/(表大小)大于一个阈值时， 就增加哈希表的大小。我们新建一个大的哈希表，然后将旧表中的元素值， 通过新的哈希函数映射到新表。</li>\n</ol>\n<ul>\n<li><strong>如果输入数据规模不大，我们可以使用什么数据结构来代替哈希表。</strong><br>你可以使用STL map来代替哈希表，尽管插入和查找元素的时间复杂度是O(logn)， 但由于输入数据的规模不大，因此这点时间差别可以忽略不计。</li>\n</ul>\n<h6 id=\"13-3-How-do-virtual-functions-work-in-C\"><a href=\"#13-3-How-do-virtual-functions-work-in-C\" class=\"headerlink\" title=\"13.3 How do virtual functions work in C++?\"></a>13.3 How do virtual functions work in C++?</h6><ul>\n<li>虚函数依赖虚函数表进行工作。如果一个类中，有函数被关键词virtual进行修饰， 那么一个虚函数表就会被构建起来保存这个类中虚函数的地址。同时， 编译器会为这个类添加一个隐藏指针指向虚函数表。如果在派生类中没有重写虚函数， 那么，派生类中虚表存储的是父类虚函数的地址。每当虚函数被调用时， 虚表会决定具体去调用哪个函数。因此，C++中的动态绑定是通过虚函数表机制进行的。</li>\n<li>当我们用基类指针指向派生类时，虚表指针vptr指向派生类的虚函数表。 这个机制可以保证派生类中的虚函数被调用到。</li>\n<li>C++中非虚函数的调用是在编译期静态绑定的， 而虚函数的调用则是在执行时才进行动态绑定。</li>\n</ul>\n<h6 id=\"13-4-What-is-the-difference-between-deep-cop-and-shallow-copy-Explain-how-you-would-usd-each\"><a href=\"#13-4-What-is-the-difference-between-deep-cop-and-shallow-copy-Explain-how-you-would-usd-each\" class=\"headerlink\" title=\"13.4 What is the difference between deep cop and shallow copy? Explain how you would usd each.\"></a>13.4 What is the difference between deep cop and shallow copy? Explain how you would usd each.</h6><ul>\n<li>浅拷贝并不复制数据，只复制指向数据的指针，因此是多个指针指向同一份数据。 深拷贝会复制原始数据，每个指针指向一份独立的数据。</li>\n<li>浅拷贝在构造和删除对象时容易产生问题，因此使用时要十分小心。如无必要， 尽量不用浅拷贝。当我们要传递复杂结构的信息，而又不想产生另一份数据时， 可以使用浅拷贝，比如引用传参。浅拷贝特别需要注意的就是析构时的问题， 当多个指针指向同一份内存时，删除这些指针将导致多次释放同一内存而出错。</li>\n<li>实际情况下是很少使用浅拷贝的，而智能指针是浅拷贝概念的增强。 比如智能指针可以维护一个引用计数来表明指向某块内存的指针数量， 只有当引用计数减至0时，才真正释放内存。</li>\n<li>大部分时候，我们用的是深拷贝，特别是当拷贝的结构不大的时候。</li>\n</ul>\n<h6 id=\"13-5-What-is-the-significance-of-the-keyword-“volatile”-in-C\"><a href=\"#13-5-What-is-the-significance-of-the-keyword-“volatile”-in-C\" class=\"headerlink\" title=\"13.5 What is the significance of the keyword “volatile” in C?\"></a>13.5 What is the significance of the keyword “volatile” in C?</h6><ul>\n<li>volatile的意思是”易变的”，因为访问寄存器比访问内存要快得多， 所以编译器一般都会做减少存取内存的优化。volatile 这个关键字会提醒编译器，它声明的变量随时可能发生变化(在外部被修改)， 因此，与该变量相关的代码不要进行编译优化，以免出错。</li>\n<li>volatile在声明上的使用和const是一样的。volatile在<em>号左边， 修饰的是指针所指物；在</em>号右边修饰的是指针。<br>*</li>\n</ul>\n<h6 id=\"13-6-Why-does-a-destructor-in-base-class-need-to-be-declared-virtual\"><a href=\"#13-6-Why-does-a-destructor-in-base-class-need-to-be-declared-virtual\" class=\"headerlink\" title=\"13.6 Why does a destructor in base class need to be declared virtual?\"></a>13.6 Why does a destructor in base class need to be declared virtual?</h6><ul>\n<li><p>用对象指针来调用一个函数，有以下两种情况：</p>\n<ol>\n<li>如果是虚函数，会调用派生类中的版本。</li>\n<li>如果是非虚函数，会调用指针所指类型的实现版本。</li>\n</ol>\n</li>\n<li><p>析构函数也会遵循以上两种情况，因为析构函数也是函数嘛，不要把它看得太特殊。 当对象出了作用域或是我们删除对象指针，析构函数就会被调用。</p>\n</li>\n<li>当派生类对象出了作用域，派生类的析构函数会先调用，然后再调用它父类的析构函数， 这样能保证分配给对象的内存得到正确释放。</li>\n<li>但是，如果我们删除一个指向派生类对象的基类指针，而基类析构函数又是非虚的话， 那么就会先调用基类的析构函数(上面第2种情况)，派生类的析构函数得不到调用。</li>\n<li>如果我们把基类的析构函数声明为虚析构函数，这会使得所有派生类的析构函数也为虚。 从而使析构函数得到正确调用。</li>\n<li>因此，如果我们可能会删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 事实上，《Effective C++》中的观点是，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数。</li>\n</ul>\n<h6 id=\"13-7-Write-a-method-that-takes-a-pointer-to-a-Node-structure-as-a-parameter-na-dreturns-a-complete-copy-of-the-passed-in-data-structure-The-Node-data-structure-contains-two-pointers-to-other-Nodes\"><a href=\"#13-7-Write-a-method-that-takes-a-pointer-to-a-Node-structure-as-a-parameter-na-dreturns-a-complete-copy-of-the-passed-in-data-structure-The-Node-data-structure-contains-two-pointers-to-other-Nodes\" class=\"headerlink\" title=\"13.7 Write a method that takes a pointer to a Node structure as a parameter na dreturns a complete copy of the passed in data structure. The Node data structure contains two pointers to other Nodes.\"></a>13.7 Write a method that takes a pointer to a Node structure as a parameter na dreturns a complete copy of the passed in data structure. The Node data structure contains two pointers to other Nodes.</h6><h6 id=\"13-8-Write-a-smart-pointer-class-A-smart-pointer-is-a-data-type-usually-implemented-with-templates-that-simulates-a-pointer-while-also-providing-automatic-garbage-collection-It-automatically-counts-the-number-of-references-to-a-SmartPointer-lt-T-gt-object-and-frees-the-object-of-type-T-when-the-reference-count-hits-zero\"><a href=\"#13-8-Write-a-smart-pointer-class-A-smart-pointer-is-a-data-type-usually-implemented-with-templates-that-simulates-a-pointer-while-also-providing-automatic-garbage-collection-It-automatically-counts-the-number-of-references-to-a-SmartPointer-lt-T-gt-object-and-frees-the-object-of-type-T-when-the-reference-count-hits-zero\" class=\"headerlink\" title=\"13.8 Write a smart pointer class. A smart pointer is a data type, usually implemented with templates, that simulates a pointer while also providing automatic garbage collection. It automatically counts the number of references to a SmartPointer&lt;T*&gt; object and frees the object of type T when the reference count hits zero.\"></a>13.8 Write a smart pointer class. A smart pointer is a data type, usually implemented with templates, that simulates a pointer while also providing automatic garbage collection. It automatically counts the number of references to a SmartPointer&lt;T*&gt; object and frees the object of type T when the reference count hits zero.</h6><h6 id=\"13-9-Write-an-aligned-malloc-and-free-function-that-supports-allocating-memory-such-that-the-memory-address-returned-is-divisible-by-a-specific-power-of-two\"><a href=\"#13-9-Write-an-aligned-malloc-and-free-function-that-supports-allocating-memory-such-that-the-memory-address-returned-is-divisible-by-a-specific-power-of-two\" class=\"headerlink\" title=\"13.9 Write an aligned malloc and free function that supports allocating memory such that the memory address returned is divisible by a specific power of two.\"></a>13.9 Write an aligned malloc and free function that supports allocating memory such that the memory address returned is divisible by a specific power of two.</h6><h6 id=\"EXAMPLE\"><a href=\"#EXAMPLE\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h6><h6 id=\"align-malloc-1000-128-will-return-a-memory-address-that-is-a-multiple-of-128-and-that-points-to-memory-of-size-1000-bytes\"><a href=\"#align-malloc-1000-128-will-return-a-memory-address-that-is-a-multiple-of-128-and-that-points-to-memory-of-size-1000-bytes\" class=\"headerlink\" title=\"align_malloc(1000, 128) will return a memory address that is a multiple of 128 and that points to memory of size 1000 bytes.\"></a>align_malloc(1000, 128) will return a memory address that is a multiple of 128 and that points to memory of size 1000 bytes.</h6><h6 id=\"aligned-free-will-free-memory-allocated-by-align-malloc\"><a href=\"#aligned-free-will-free-memory-allocated-by-align-malloc\" class=\"headerlink\" title=\"aligned_free() will free memory allocated by align_malloc.\"></a>aligned_free() will free memory allocated by align_malloc.</h6><h6 id=\"13-10-Write-a-function-in-C-called-my2DAlloc-which-allocates-a-two-dimensional-array-Minimize-the-number-of-calls-to-malloc-and-make-sure-that-the-memory-is-accessible-by-the-notation-arr-i-j\"><a href=\"#13-10-Write-a-function-in-C-called-my2DAlloc-which-allocates-a-two-dimensional-array-Minimize-the-number-of-calls-to-malloc-and-make-sure-that-the-memory-is-accessible-by-the-notation-arr-i-j\" class=\"headerlink\" title=\"13.10 Write a function in C called my2DAlloc which allocates a two-dimensional array. Minimize the number of calls to malloc and make sure that the memory is accessible by the notation arr[i][j].\"></a>13.10 Write a function in C called my2DAlloc which allocates a two-dimensional array. Minimize the number of calls to malloc and make sure that the memory is accessible by the notation arr[i][j].</h6>"},{"title":"Cracking the Coding Interview - Chapter 2 Linked List","id":"56","date":"2015-04-06T04:06:19.000Z","_content":"\n# Chapter 2 Linked List\n\n###### 2.1 Write code to remove duplicates from an unsorted linked list.\n\n###### FOLLOW UP\n\n###### How would you solve this problem if a temporary buffer is now allowed?\n\n*   如果可以使用临时区域，我们使用hash表来判断元素是否重复\n*   如果不使用临时区域，我们用两个指针，从前向后依次遍历判断是否有后继节点与之前的节点相同\n*   [Q2.1_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)\n\n###### 2.2 Implement an algorithm to find the kth to last element of a singly linked list.\n\n*   在单链表中找到倒数第k个元素\n*   如果链表的长度已知， 则倒数k个元素即正数（length-k），这种情况太简单，明显不是要考察的\n*   一种方法是使用递归，依次遍历到最后一个元素，然后向前递归查找第k个,需要一个全局变量来计数\n*   另种方法是双指针，两个指针差k位，同时向后移动至后指针指到最后一个元素，返回前指针指向的元素即可\n*   [Q2.2_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)\n\n###### 2.3 Implement an algorithm to delete a node in the middle of a singly linked list, given only access to that node.\n\n###### EXAMPLE\n\n###### Input: the node c from the linked list a->b->c->d->e\n\n###### Result: nothing is returned, but the new linked list looks like a->b->d->e\n\n*   middle指的是中间的某个不是正中间\n*   需要考虑4种情况即，A: c为头节点，B: c 为中间节点， C: c为尾节点，D: c为null\n*   情况C比较特殊，因为你无法删除c，可以增加标志位，不打印c，来处理这种情况\n*   [Q2.3_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)\n\n###### 2.4 Write code to partition a linked list around a value x, such that all nodes less than x come before all node greater than or equal to x.\n\n*   不要求排序\n*   建立两个链表，一个大于x，一个小于x\n*   遍历链表，将元素加入这两个链表，然后将其拼接\n*   [Q2.4_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)\n\n###### 2.5 You have tow numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1's digit is at the head of the list, Write a function that adds the two numbers and returns the sum as a linked list.\n\n###### EXAMPLE\n\n###### Input: (7->1->6) + (5->9->2). That is, 617+ 295.\n\n###### Ouput: 2->1->9. That is, 912.\n\n###### FOLLOW UP\n\n###### Suppose the digits are stored in forward order. Repeat the above problem.\n\n###### EXAMPLE\n\n###### Input: (6->1->7) + (2->9->5). That is, 617 + 295.\n\n###### Output: 9->1->2. That is, 912.\n\n*   答案给的是使用递归，建立新链表，按位相加。\n*   我自己写的是，先按位相加得到和，然后根据和构造sum链表\n*   [Q2.5_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)\n\n###### 2.6 Given a circular linked list, implement an algorithm which returns the node at the beginning of the loop.\n\n###### DEFINITION\n\n###### Circular linked list: A (corrupt) linked list in which a node's next pointer points to an earlier node, so as to make a loop in the linked list.\n\n###### EXAMPLE\n\n###### Input: A->B->C->D->E->C [the same C as earlier]\n\n###### Output: C\n\n*   最简单的思路是使用hashmap，将元素一个个存入判断是否已存在\n*   返回第一个重复的元素，即环入口\n*   [Q2.6_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java).\n  \n###### 2.7 implement a function to check if a linked list is palindrome.\n\n*   思路是比较前一半的元素和后一半的元素\n*   可以使用栈，将前一半的元素压栈，然后和后一半的逐个比较。\n*   需要注意的是元素的个数是可能是奇数，加一个判断，为奇数就跳过中间的元素。\n*   [Q2.7_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)","source":"_posts/CCI_Chapter2.md","raw":"---\ntitle: Cracking the Coding Interview - Chapter 2 Linked List\nid: 56\ncategories:\n  - Cracking the Coding Interview (Fifth edition)\ndate: 2015-04-06 00:06:19\ntags:\n---\n\n# Chapter 2 Linked List\n\n###### 2.1 Write code to remove duplicates from an unsorted linked list.\n\n###### FOLLOW UP\n\n###### How would you solve this problem if a temporary buffer is now allowed?\n\n*   如果可以使用临时区域，我们使用hash表来判断元素是否重复\n*   如果不使用临时区域，我们用两个指针，从前向后依次遍历判断是否有后继节点与之前的节点相同\n*   [Q2.1_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)\n\n###### 2.2 Implement an algorithm to find the kth to last element of a singly linked list.\n\n*   在单链表中找到倒数第k个元素\n*   如果链表的长度已知， 则倒数k个元素即正数（length-k），这种情况太简单，明显不是要考察的\n*   一种方法是使用递归，依次遍历到最后一个元素，然后向前递归查找第k个,需要一个全局变量来计数\n*   另种方法是双指针，两个指针差k位，同时向后移动至后指针指到最后一个元素，返回前指针指向的元素即可\n*   [Q2.2_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)\n\n###### 2.3 Implement an algorithm to delete a node in the middle of a singly linked list, given only access to that node.\n\n###### EXAMPLE\n\n###### Input: the node c from the linked list a->b->c->d->e\n\n###### Result: nothing is returned, but the new linked list looks like a->b->d->e\n\n*   middle指的是中间的某个不是正中间\n*   需要考虑4种情况即，A: c为头节点，B: c 为中间节点， C: c为尾节点，D: c为null\n*   情况C比较特殊，因为你无法删除c，可以增加标志位，不打印c，来处理这种情况\n*   [Q2.3_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)\n\n###### 2.4 Write code to partition a linked list around a value x, such that all nodes less than x come before all node greater than or equal to x.\n\n*   不要求排序\n*   建立两个链表，一个大于x，一个小于x\n*   遍历链表，将元素加入这两个链表，然后将其拼接\n*   [Q2.4_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)\n\n###### 2.5 You have tow numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1's digit is at the head of the list, Write a function that adds the two numbers and returns the sum as a linked list.\n\n###### EXAMPLE\n\n###### Input: (7->1->6) + (5->9->2). That is, 617+ 295.\n\n###### Ouput: 2->1->9. That is, 912.\n\n###### FOLLOW UP\n\n###### Suppose the digits are stored in forward order. Repeat the above problem.\n\n###### EXAMPLE\n\n###### Input: (6->1->7) + (2->9->5). That is, 617 + 295.\n\n###### Output: 9->1->2. That is, 912.\n\n*   答案给的是使用递归，建立新链表，按位相加。\n*   我自己写的是，先按位相加得到和，然后根据和构造sum链表\n*   [Q2.5_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)\n\n###### 2.6 Given a circular linked list, implement an algorithm which returns the node at the beginning of the loop.\n\n###### DEFINITION\n\n###### Circular linked list: A (corrupt) linked list in which a node's next pointer points to an earlier node, so as to make a loop in the linked list.\n\n###### EXAMPLE\n\n###### Input: A->B->C->D->E->C [the same C as earlier]\n\n###### Output: C\n\n*   最简单的思路是使用hashmap，将元素一个个存入判断是否已存在\n*   返回第一个重复的元素，即环入口\n*   [Q2.6_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java).\n  \n###### 2.7 implement a function to check if a linked list is palindrome.\n\n*   思路是比较前一半的元素和后一半的元素\n*   可以使用栈，将前一半的元素压栈，然后和后一半的逐个比较。\n*   需要注意的是元素的个数是可能是奇数，加一个判断，为奇数就跳过中间的元素。\n*   [Q2.7_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java)","slug":"CCI_Chapter2","published":1,"updated":"2019-02-10T17:11:09.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk0w000alkgu12quj9vg","content":"<h1 id=\"Chapter-2-Linked-List\"><a href=\"#Chapter-2-Linked-List\" class=\"headerlink\" title=\"Chapter 2 Linked List\"></a>Chapter 2 Linked List</h1><h6 id=\"2-1-Write-code-to-remove-duplicates-from-an-unsorted-linked-list\"><a href=\"#2-1-Write-code-to-remove-duplicates-from-an-unsorted-linked-list\" class=\"headerlink\" title=\"2.1 Write code to remove duplicates from an unsorted linked list.\"></a>2.1 Write code to remove duplicates from an unsorted linked list.</h6><h6 id=\"FOLLOW-UP\"><a href=\"#FOLLOW-UP\" class=\"headerlink\" title=\"FOLLOW UP\"></a>FOLLOW UP</h6><h6 id=\"How-would-you-solve-this-problem-if-a-temporary-buffer-is-now-allowed\"><a href=\"#How-would-you-solve-this-problem-if-a-temporary-buffer-is-now-allowed\" class=\"headerlink\" title=\"How would you solve this problem if a temporary buffer is now allowed?\"></a>How would you solve this problem if a temporary buffer is now allowed?</h6><ul>\n<li>如果可以使用临时区域，我们使用hash表来判断元素是否重复</li>\n<li>如果不使用临时区域，我们用两个指针，从前向后依次遍历判断是否有后继节点与之前的节点相同</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.1_Implementation</a></li>\n</ul>\n<h6 id=\"2-2-Implement-an-algorithm-to-find-the-kth-to-last-element-of-a-singly-linked-list\"><a href=\"#2-2-Implement-an-algorithm-to-find-the-kth-to-last-element-of-a-singly-linked-list\" class=\"headerlink\" title=\"2.2 Implement an algorithm to find the kth to last element of a singly linked list.\"></a>2.2 Implement an algorithm to find the kth to last element of a singly linked list.</h6><ul>\n<li>在单链表中找到倒数第k个元素</li>\n<li>如果链表的长度已知， 则倒数k个元素即正数（length-k），这种情况太简单，明显不是要考察的</li>\n<li>一种方法是使用递归，依次遍历到最后一个元素，然后向前递归查找第k个,需要一个全局变量来计数</li>\n<li>另种方法是双指针，两个指针差k位，同时向后移动至后指针指到最后一个元素，返回前指针指向的元素即可</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.2_Implementation</a></li>\n</ul>\n<h6 id=\"2-3-Implement-an-algorithm-to-delete-a-node-in-the-middle-of-a-singly-linked-list-given-only-access-to-that-node\"><a href=\"#2-3-Implement-an-algorithm-to-delete-a-node-in-the-middle-of-a-singly-linked-list-given-only-access-to-that-node\" class=\"headerlink\" title=\"2.3 Implement an algorithm to delete a node in the middle of a singly linked list, given only access to that node.\"></a>2.3 Implement an algorithm to delete a node in the middle of a singly linked list, given only access to that node.</h6><h6 id=\"EXAMPLE\"><a href=\"#EXAMPLE\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h6><h6 id=\"Input-the-node-c-from-the-linked-list-a-gt-b-gt-c-gt-d-gt-e\"><a href=\"#Input-the-node-c-from-the-linked-list-a-gt-b-gt-c-gt-d-gt-e\" class=\"headerlink\" title=\"Input: the node c from the linked list a-&gt;b-&gt;c-&gt;d-&gt;e\"></a>Input: the node c from the linked list a-&gt;b-&gt;c-&gt;d-&gt;e</h6><h6 id=\"Result-nothing-is-returned-but-the-new-linked-list-looks-like-a-gt-b-gt-d-gt-e\"><a href=\"#Result-nothing-is-returned-but-the-new-linked-list-looks-like-a-gt-b-gt-d-gt-e\" class=\"headerlink\" title=\"Result: nothing is returned, but the new linked list looks like a-&gt;b-&gt;d-&gt;e\"></a>Result: nothing is returned, but the new linked list looks like a-&gt;b-&gt;d-&gt;e</h6><ul>\n<li>middle指的是中间的某个不是正中间</li>\n<li>需要考虑4种情况即，A: c为头节点，B: c 为中间节点， C: c为尾节点，D: c为null</li>\n<li>情况C比较特殊，因为你无法删除c，可以增加标志位，不打印c，来处理这种情况</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.3_Implementation</a></li>\n</ul>\n<h6 id=\"2-4-Write-code-to-partition-a-linked-list-around-a-value-x-such-that-all-nodes-less-than-x-come-before-all-node-greater-than-or-equal-to-x\"><a href=\"#2-4-Write-code-to-partition-a-linked-list-around-a-value-x-such-that-all-nodes-less-than-x-come-before-all-node-greater-than-or-equal-to-x\" class=\"headerlink\" title=\"2.4 Write code to partition a linked list around a value x, such that all nodes less than x come before all node greater than or equal to x.\"></a>2.4 Write code to partition a linked list around a value x, such that all nodes less than x come before all node greater than or equal to x.</h6><ul>\n<li>不要求排序</li>\n<li>建立两个链表，一个大于x，一个小于x</li>\n<li>遍历链表，将元素加入这两个链表，然后将其拼接</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.4_Implementation</a></li>\n</ul>\n<h6 id=\"2-5-You-have-tow-numbers-represented-by-a-linked-list-where-each-node-contains-a-single-digit-The-digits-are-stored-in-reverse-order-such-that-the-1’s-digit-is-at-the-head-of-the-list-Write-a-function-that-adds-the-two-numbers-and-returns-the-sum-as-a-linked-list\"><a href=\"#2-5-You-have-tow-numbers-represented-by-a-linked-list-where-each-node-contains-a-single-digit-The-digits-are-stored-in-reverse-order-such-that-the-1’s-digit-is-at-the-head-of-the-list-Write-a-function-that-adds-the-two-numbers-and-returns-the-sum-as-a-linked-list\" class=\"headerlink\" title=\"2.5 You have tow numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1’s digit is at the head of the list, Write a function that adds the two numbers and returns the sum as a linked list.\"></a>2.5 You have tow numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1’s digit is at the head of the list, Write a function that adds the two numbers and returns the sum as a linked list.</h6><h6 id=\"EXAMPLE-1\"><a href=\"#EXAMPLE-1\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h6><h6 id=\"Input-7-gt-1-gt-6-5-gt-9-gt-2-That-is-617-295\"><a href=\"#Input-7-gt-1-gt-6-5-gt-9-gt-2-That-is-617-295\" class=\"headerlink\" title=\"Input: (7-&gt;1-&gt;6) + (5-&gt;9-&gt;2). That is, 617+ 295.\"></a>Input: (7-&gt;1-&gt;6) + (5-&gt;9-&gt;2). That is, 617+ 295.</h6><h6 id=\"Ouput-2-gt-1-gt-9-That-is-912\"><a href=\"#Ouput-2-gt-1-gt-9-That-is-912\" class=\"headerlink\" title=\"Ouput: 2-&gt;1-&gt;9. That is, 912.\"></a>Ouput: 2-&gt;1-&gt;9. That is, 912.</h6><h6 id=\"FOLLOW-UP-1\"><a href=\"#FOLLOW-UP-1\" class=\"headerlink\" title=\"FOLLOW UP\"></a>FOLLOW UP</h6><h6 id=\"Suppose-the-digits-are-stored-in-forward-order-Repeat-the-above-problem\"><a href=\"#Suppose-the-digits-are-stored-in-forward-order-Repeat-the-above-problem\" class=\"headerlink\" title=\"Suppose the digits are stored in forward order. Repeat the above problem.\"></a>Suppose the digits are stored in forward order. Repeat the above problem.</h6><h6 id=\"EXAMPLE-2\"><a href=\"#EXAMPLE-2\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h6><h6 id=\"Input-6-gt-1-gt-7-2-gt-9-gt-5-That-is-617-295\"><a href=\"#Input-6-gt-1-gt-7-2-gt-9-gt-5-That-is-617-295\" class=\"headerlink\" title=\"Input: (6-&gt;1-&gt;7) + (2-&gt;9-&gt;5). That is, 617 + 295.\"></a>Input: (6-&gt;1-&gt;7) + (2-&gt;9-&gt;5). That is, 617 + 295.</h6><h6 id=\"Output-9-gt-1-gt-2-That-is-912\"><a href=\"#Output-9-gt-1-gt-2-That-is-912\" class=\"headerlink\" title=\"Output: 9-&gt;1-&gt;2. That is, 912.\"></a>Output: 9-&gt;1-&gt;2. That is, 912.</h6><ul>\n<li>答案给的是使用递归，建立新链表，按位相加。</li>\n<li>我自己写的是，先按位相加得到和，然后根据和构造sum链表</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.5_Implementation</a></li>\n</ul>\n<h6 id=\"2-6-Given-a-circular-linked-list-implement-an-algorithm-which-returns-the-node-at-the-beginning-of-the-loop\"><a href=\"#2-6-Given-a-circular-linked-list-implement-an-algorithm-which-returns-the-node-at-the-beginning-of-the-loop\" class=\"headerlink\" title=\"2.6 Given a circular linked list, implement an algorithm which returns the node at the beginning of the loop.\"></a>2.6 Given a circular linked list, implement an algorithm which returns the node at the beginning of the loop.</h6><h6 id=\"DEFINITION\"><a href=\"#DEFINITION\" class=\"headerlink\" title=\"DEFINITION\"></a>DEFINITION</h6><h6 id=\"Circular-linked-list-A-corrupt-linked-list-in-which-a-node’s-next-pointer-points-to-an-earlier-node-so-as-to-make-a-loop-in-the-linked-list\"><a href=\"#Circular-linked-list-A-corrupt-linked-list-in-which-a-node’s-next-pointer-points-to-an-earlier-node-so-as-to-make-a-loop-in-the-linked-list\" class=\"headerlink\" title=\"Circular linked list: A (corrupt) linked list in which a node’s next pointer points to an earlier node, so as to make a loop in the linked list.\"></a>Circular linked list: A (corrupt) linked list in which a node’s next pointer points to an earlier node, so as to make a loop in the linked list.</h6><h6 id=\"EXAMPLE-3\"><a href=\"#EXAMPLE-3\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h6><h6 id=\"Input-A-gt-B-gt-C-gt-D-gt-E-gt-C-the-same-C-as-earlier\"><a href=\"#Input-A-gt-B-gt-C-gt-D-gt-E-gt-C-the-same-C-as-earlier\" class=\"headerlink\" title=\"Input: A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C [the same C as earlier]\"></a>Input: A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C [the same C as earlier]</h6><h6 id=\"Output-C\"><a href=\"#Output-C\" class=\"headerlink\" title=\"Output: C\"></a>Output: C</h6><ul>\n<li>最简单的思路是使用hashmap，将元素一个个存入判断是否已存在</li>\n<li>返回第一个重复的元素，即环入口</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.6_Implementation</a>.</li>\n</ul>\n<h6 id=\"2-7-implement-a-function-to-check-if-a-linked-list-is-palindrome\"><a href=\"#2-7-implement-a-function-to-check-if-a-linked-list-is-palindrome\" class=\"headerlink\" title=\"2.7 implement a function to check if a linked list is palindrome.\"></a>2.7 implement a function to check if a linked list is palindrome.</h6><ul>\n<li>思路是比较前一半的元素和后一半的元素</li>\n<li>可以使用栈，将前一半的元素压栈，然后和后一半的逐个比较。</li>\n<li>需要注意的是元素的个数是可能是奇数，加一个判断，为奇数就跳过中间的元素。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.7_Implementation</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Chapter-2-Linked-List\"><a href=\"#Chapter-2-Linked-List\" class=\"headerlink\" title=\"Chapter 2 Linked List\"></a>Chapter 2 Linked List</h1><h6 id=\"2-1-Write-code-to-remove-duplicates-from-an-unsorted-linked-list\"><a href=\"#2-1-Write-code-to-remove-duplicates-from-an-unsorted-linked-list\" class=\"headerlink\" title=\"2.1 Write code to remove duplicates from an unsorted linked list.\"></a>2.1 Write code to remove duplicates from an unsorted linked list.</h6><h6 id=\"FOLLOW-UP\"><a href=\"#FOLLOW-UP\" class=\"headerlink\" title=\"FOLLOW UP\"></a>FOLLOW UP</h6><h6 id=\"How-would-you-solve-this-problem-if-a-temporary-buffer-is-now-allowed\"><a href=\"#How-would-you-solve-this-problem-if-a-temporary-buffer-is-now-allowed\" class=\"headerlink\" title=\"How would you solve this problem if a temporary buffer is now allowed?\"></a>How would you solve this problem if a temporary buffer is now allowed?</h6><ul>\n<li>如果可以使用临时区域，我们使用hash表来判断元素是否重复</li>\n<li>如果不使用临时区域，我们用两个指针，从前向后依次遍历判断是否有后继节点与之前的节点相同</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.1_Implementation</a></li>\n</ul>\n<h6 id=\"2-2-Implement-an-algorithm-to-find-the-kth-to-last-element-of-a-singly-linked-list\"><a href=\"#2-2-Implement-an-algorithm-to-find-the-kth-to-last-element-of-a-singly-linked-list\" class=\"headerlink\" title=\"2.2 Implement an algorithm to find the kth to last element of a singly linked list.\"></a>2.2 Implement an algorithm to find the kth to last element of a singly linked list.</h6><ul>\n<li>在单链表中找到倒数第k个元素</li>\n<li>如果链表的长度已知， 则倒数k个元素即正数（length-k），这种情况太简单，明显不是要考察的</li>\n<li>一种方法是使用递归，依次遍历到最后一个元素，然后向前递归查找第k个,需要一个全局变量来计数</li>\n<li>另种方法是双指针，两个指针差k位，同时向后移动至后指针指到最后一个元素，返回前指针指向的元素即可</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.2_Implementation</a></li>\n</ul>\n<h6 id=\"2-3-Implement-an-algorithm-to-delete-a-node-in-the-middle-of-a-singly-linked-list-given-only-access-to-that-node\"><a href=\"#2-3-Implement-an-algorithm-to-delete-a-node-in-the-middle-of-a-singly-linked-list-given-only-access-to-that-node\" class=\"headerlink\" title=\"2.3 Implement an algorithm to delete a node in the middle of a singly linked list, given only access to that node.\"></a>2.3 Implement an algorithm to delete a node in the middle of a singly linked list, given only access to that node.</h6><h6 id=\"EXAMPLE\"><a href=\"#EXAMPLE\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h6><h6 id=\"Input-the-node-c-from-the-linked-list-a-gt-b-gt-c-gt-d-gt-e\"><a href=\"#Input-the-node-c-from-the-linked-list-a-gt-b-gt-c-gt-d-gt-e\" class=\"headerlink\" title=\"Input: the node c from the linked list a-&gt;b-&gt;c-&gt;d-&gt;e\"></a>Input: the node c from the linked list a-&gt;b-&gt;c-&gt;d-&gt;e</h6><h6 id=\"Result-nothing-is-returned-but-the-new-linked-list-looks-like-a-gt-b-gt-d-gt-e\"><a href=\"#Result-nothing-is-returned-but-the-new-linked-list-looks-like-a-gt-b-gt-d-gt-e\" class=\"headerlink\" title=\"Result: nothing is returned, but the new linked list looks like a-&gt;b-&gt;d-&gt;e\"></a>Result: nothing is returned, but the new linked list looks like a-&gt;b-&gt;d-&gt;e</h6><ul>\n<li>middle指的是中间的某个不是正中间</li>\n<li>需要考虑4种情况即，A: c为头节点，B: c 为中间节点， C: c为尾节点，D: c为null</li>\n<li>情况C比较特殊，因为你无法删除c，可以增加标志位，不打印c，来处理这种情况</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.3_Implementation</a></li>\n</ul>\n<h6 id=\"2-4-Write-code-to-partition-a-linked-list-around-a-value-x-such-that-all-nodes-less-than-x-come-before-all-node-greater-than-or-equal-to-x\"><a href=\"#2-4-Write-code-to-partition-a-linked-list-around-a-value-x-such-that-all-nodes-less-than-x-come-before-all-node-greater-than-or-equal-to-x\" class=\"headerlink\" title=\"2.4 Write code to partition a linked list around a value x, such that all nodes less than x come before all node greater than or equal to x.\"></a>2.4 Write code to partition a linked list around a value x, such that all nodes less than x come before all node greater than or equal to x.</h6><ul>\n<li>不要求排序</li>\n<li>建立两个链表，一个大于x，一个小于x</li>\n<li>遍历链表，将元素加入这两个链表，然后将其拼接</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.4_Implementation</a></li>\n</ul>\n<h6 id=\"2-5-You-have-tow-numbers-represented-by-a-linked-list-where-each-node-contains-a-single-digit-The-digits-are-stored-in-reverse-order-such-that-the-1’s-digit-is-at-the-head-of-the-list-Write-a-function-that-adds-the-two-numbers-and-returns-the-sum-as-a-linked-list\"><a href=\"#2-5-You-have-tow-numbers-represented-by-a-linked-list-where-each-node-contains-a-single-digit-The-digits-are-stored-in-reverse-order-such-that-the-1’s-digit-is-at-the-head-of-the-list-Write-a-function-that-adds-the-two-numbers-and-returns-the-sum-as-a-linked-list\" class=\"headerlink\" title=\"2.5 You have tow numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1’s digit is at the head of the list, Write a function that adds the two numbers and returns the sum as a linked list.\"></a>2.5 You have tow numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1’s digit is at the head of the list, Write a function that adds the two numbers and returns the sum as a linked list.</h6><h6 id=\"EXAMPLE-1\"><a href=\"#EXAMPLE-1\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h6><h6 id=\"Input-7-gt-1-gt-6-5-gt-9-gt-2-That-is-617-295\"><a href=\"#Input-7-gt-1-gt-6-5-gt-9-gt-2-That-is-617-295\" class=\"headerlink\" title=\"Input: (7-&gt;1-&gt;6) + (5-&gt;9-&gt;2). That is, 617+ 295.\"></a>Input: (7-&gt;1-&gt;6) + (5-&gt;9-&gt;2). That is, 617+ 295.</h6><h6 id=\"Ouput-2-gt-1-gt-9-That-is-912\"><a href=\"#Ouput-2-gt-1-gt-9-That-is-912\" class=\"headerlink\" title=\"Ouput: 2-&gt;1-&gt;9. That is, 912.\"></a>Ouput: 2-&gt;1-&gt;9. That is, 912.</h6><h6 id=\"FOLLOW-UP-1\"><a href=\"#FOLLOW-UP-1\" class=\"headerlink\" title=\"FOLLOW UP\"></a>FOLLOW UP</h6><h6 id=\"Suppose-the-digits-are-stored-in-forward-order-Repeat-the-above-problem\"><a href=\"#Suppose-the-digits-are-stored-in-forward-order-Repeat-the-above-problem\" class=\"headerlink\" title=\"Suppose the digits are stored in forward order. Repeat the above problem.\"></a>Suppose the digits are stored in forward order. Repeat the above problem.</h6><h6 id=\"EXAMPLE-2\"><a href=\"#EXAMPLE-2\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h6><h6 id=\"Input-6-gt-1-gt-7-2-gt-9-gt-5-That-is-617-295\"><a href=\"#Input-6-gt-1-gt-7-2-gt-9-gt-5-That-is-617-295\" class=\"headerlink\" title=\"Input: (6-&gt;1-&gt;7) + (2-&gt;9-&gt;5). That is, 617 + 295.\"></a>Input: (6-&gt;1-&gt;7) + (2-&gt;9-&gt;5). That is, 617 + 295.</h6><h6 id=\"Output-9-gt-1-gt-2-That-is-912\"><a href=\"#Output-9-gt-1-gt-2-That-is-912\" class=\"headerlink\" title=\"Output: 9-&gt;1-&gt;2. That is, 912.\"></a>Output: 9-&gt;1-&gt;2. That is, 912.</h6><ul>\n<li>答案给的是使用递归，建立新链表，按位相加。</li>\n<li>我自己写的是，先按位相加得到和，然后根据和构造sum链表</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.5_Implementation</a></li>\n</ul>\n<h6 id=\"2-6-Given-a-circular-linked-list-implement-an-algorithm-which-returns-the-node-at-the-beginning-of-the-loop\"><a href=\"#2-6-Given-a-circular-linked-list-implement-an-algorithm-which-returns-the-node-at-the-beginning-of-the-loop\" class=\"headerlink\" title=\"2.6 Given a circular linked list, implement an algorithm which returns the node at the beginning of the loop.\"></a>2.6 Given a circular linked list, implement an algorithm which returns the node at the beginning of the loop.</h6><h6 id=\"DEFINITION\"><a href=\"#DEFINITION\" class=\"headerlink\" title=\"DEFINITION\"></a>DEFINITION</h6><h6 id=\"Circular-linked-list-A-corrupt-linked-list-in-which-a-node’s-next-pointer-points-to-an-earlier-node-so-as-to-make-a-loop-in-the-linked-list\"><a href=\"#Circular-linked-list-A-corrupt-linked-list-in-which-a-node’s-next-pointer-points-to-an-earlier-node-so-as-to-make-a-loop-in-the-linked-list\" class=\"headerlink\" title=\"Circular linked list: A (corrupt) linked list in which a node’s next pointer points to an earlier node, so as to make a loop in the linked list.\"></a>Circular linked list: A (corrupt) linked list in which a node’s next pointer points to an earlier node, so as to make a loop in the linked list.</h6><h6 id=\"EXAMPLE-3\"><a href=\"#EXAMPLE-3\" class=\"headerlink\" title=\"EXAMPLE\"></a>EXAMPLE</h6><h6 id=\"Input-A-gt-B-gt-C-gt-D-gt-E-gt-C-the-same-C-as-earlier\"><a href=\"#Input-A-gt-B-gt-C-gt-D-gt-E-gt-C-the-same-C-as-earlier\" class=\"headerlink\" title=\"Input: A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C [the same C as earlier]\"></a>Input: A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C [the same C as earlier]</h6><h6 id=\"Output-C\"><a href=\"#Output-C\" class=\"headerlink\" title=\"Output: C\"></a>Output: C</h6><ul>\n<li>最简单的思路是使用hashmap，将元素一个个存入判断是否已存在</li>\n<li>返回第一个重复的元素，即环入口</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.6_Implementation</a>.</li>\n</ul>\n<h6 id=\"2-7-implement-a-function-to-check-if-a-linked-list-is-palindrome\"><a href=\"#2-7-implement-a-function-to-check-if-a-linked-list-is-palindrome\" class=\"headerlink\" title=\"2.7 implement a function to check if a linked list is palindrome.\"></a>2.7 implement a function to check if a linked list is palindrome.</h6><ul>\n<li>思路是比较前一半的元素和后一半的元素</li>\n<li>可以使用栈，将前一半的元素压栈，然后和后一半的逐个比较。</li>\n<li>需要注意的是元素的个数是可能是奇数，加一个判断，为奇数就跳过中间的元素。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/LinkedList/linkedListHelper.java\" target=\"_blank\" rel=\"noopener\">Q2.7_Implementation</a></li>\n</ul>\n"},{"title":"Callback Function 回调函数","id":"250","date":"2015-07-30T18:50:57.000Z","_content":"\n# 回调函数\n\n回调函数就是一个通过函数指针调用的函数。如果你把函数的指针地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。\n\n为什么要使用回调函数？\n\n* 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。\n\n* 如果想知道回调函数在实际中有什么作用，先假设有这样一种情况，我们要编写一个库，它提供了某些排序算法的实现，如冒泡排序、快速排序、shell排序、shake排序等等，但为使库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，想让库可用于多种数据类型（int、float、string），此时，该怎么办呢？可以使用函数指针，并进行回调。\n\n回调可用于通知机制，例如，有时要在程序中设置一个计时器，每到一定时间，程序会得到相应的通知，但通知机制的实现者对我们的程序一无所知。而此时，就需有一个特定原型的函数指针，用这个指针来进行回调，来通知我们的程序事件已经发生。实际上，SetTimer() API使用了一个回调函数来通知计时器，而且，万一没有提供回调函数，它还会把一个消息发往程序的消息队列。\n\n另一个使用回调机制的API函数是EnumWindow()，它枚举屏幕上所有的顶层窗口，为每个窗口调用一个程序提供的函数，并传递窗口的处理程序。如果被调用者返回一个值，就继续进行迭代，否则，退出。EnumWindow()并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。\n\n不管怎么说，回调函数是继续自C语言的，因而，在C++中，应只在与C代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在C++中应使用虚拟方法或函数符（functor），而不是回调函数。\n\n下面是一个简单的回调函数，相比其他的那些复杂的代码，这个更容易理解：\n\n```C++\n#include<stdio.h>;\n#include<stdlib.h>;\nvoid perfect(int n)\n{\n    int i=1;\n    int count=0;\n    for(i=1;i&lt;n;i++)\n    {\n        if(0==n%i)\n        {\n           count+=i;\n        }\n     }\n     if(count==n)\n         printf(&quot;%d是完数\\n&quot;,n);\n     else \n         printf(&quot;%d不是完数\\n&quot;,n);\n}\n\nvoid myCallback(void (*perfect)(int ),int n)\n{\n     perfect(n);\n}\n\nint main()\n{\n     int n;\n     printf(&quot;请输入一个正整数\\n&quot;);\n     scanf(&quot;%d&quot;,&amp;n);\n\n     myCallback(perfect,n);\n     return 0;\n}\n```","source":"_posts/CallbackFunction.md","raw":"---\ntitle: Callback Function 回调函数\nid: 250\ncategories:\n  - C/C++\ndate: 2015-07-30 14:50:57\ntags:\n---\n\n# 回调函数\n\n回调函数就是一个通过函数指针调用的函数。如果你把函数的指针地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。\n\n为什么要使用回调函数？\n\n* 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。\n\n* 如果想知道回调函数在实际中有什么作用，先假设有这样一种情况，我们要编写一个库，它提供了某些排序算法的实现，如冒泡排序、快速排序、shell排序、shake排序等等，但为使库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，想让库可用于多种数据类型（int、float、string），此时，该怎么办呢？可以使用函数指针，并进行回调。\n\n回调可用于通知机制，例如，有时要在程序中设置一个计时器，每到一定时间，程序会得到相应的通知，但通知机制的实现者对我们的程序一无所知。而此时，就需有一个特定原型的函数指针，用这个指针来进行回调，来通知我们的程序事件已经发生。实际上，SetTimer() API使用了一个回调函数来通知计时器，而且，万一没有提供回调函数，它还会把一个消息发往程序的消息队列。\n\n另一个使用回调机制的API函数是EnumWindow()，它枚举屏幕上所有的顶层窗口，为每个窗口调用一个程序提供的函数，并传递窗口的处理程序。如果被调用者返回一个值，就继续进行迭代，否则，退出。EnumWindow()并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。\n\n不管怎么说，回调函数是继续自C语言的，因而，在C++中，应只在与C代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在C++中应使用虚拟方法或函数符（functor），而不是回调函数。\n\n下面是一个简单的回调函数，相比其他的那些复杂的代码，这个更容易理解：\n\n```C++\n#include<stdio.h>;\n#include<stdlib.h>;\nvoid perfect(int n)\n{\n    int i=1;\n    int count=0;\n    for(i=1;i&lt;n;i++)\n    {\n        if(0==n%i)\n        {\n           count+=i;\n        }\n     }\n     if(count==n)\n         printf(&quot;%d是完数\\n&quot;,n);\n     else \n         printf(&quot;%d不是完数\\n&quot;,n);\n}\n\nvoid myCallback(void (*perfect)(int ),int n)\n{\n     perfect(n);\n}\n\nint main()\n{\n     int n;\n     printf(&quot;请输入一个正整数\\n&quot;);\n     scanf(&quot;%d&quot;,&amp;n);\n\n     myCallback(perfect,n);\n     return 0;\n}\n```","slug":"CallbackFunction","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk0x000blkgupshhd8sn","content":"<h1 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h1><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>\n<p>为什么要使用回调函数？</p>\n<ul>\n<li><p>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</p>\n</li>\n<li><p>如果想知道回调函数在实际中有什么作用，先假设有这样一种情况，我们要编写一个库，它提供了某些排序算法的实现，如冒泡排序、快速排序、shell排序、shake排序等等，但为使库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，想让库可用于多种数据类型（int、float、string），此时，该怎么办呢？可以使用函数指针，并进行回调。</p>\n</li>\n</ul>\n<p>回调可用于通知机制，例如，有时要在程序中设置一个计时器，每到一定时间，程序会得到相应的通知，但通知机制的实现者对我们的程序一无所知。而此时，就需有一个特定原型的函数指针，用这个指针来进行回调，来通知我们的程序事件已经发生。实际上，SetTimer() API使用了一个回调函数来通知计时器，而且，万一没有提供回调函数，它还会把一个消息发往程序的消息队列。</p>\n<p>另一个使用回调机制的API函数是EnumWindow()，它枚举屏幕上所有的顶层窗口，为每个窗口调用一个程序提供的函数，并传递窗口的处理程序。如果被调用者返回一个值，就继续进行迭代，否则，退出。EnumWindow()并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。</p>\n<p>不管怎么说，回调函数是继续自C语言的，因而，在C++中，应只在与C代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在C++中应使用虚拟方法或函数符（functor），而不是回调函数。</p>\n<p>下面是一个简单的回调函数，相比其他的那些复杂的代码，这个更容易理解：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">perfect</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&amp;lt;n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">0</span>==n%i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           count+=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(count==n)</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(&amp;quot;%d是完数\\n&amp;quot;,n);</span><br><span class=\"line\">     <span class=\"keyword\">else</span> </span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(&amp;quot;%d不是完数\\n&amp;quot;,n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myCallback</span><span class=\"params\">(<span class=\"keyword\">void</span> (*perfect)(<span class=\"keyword\">int</span> ),<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     perfect(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(&amp;quot;请输入一个正整数\\n&amp;quot;);</span><br><span class=\"line\">     <span class=\"built_in\">scanf</span>(&amp;quot;%d&amp;quot;,&amp;amp;n);</span><br><span class=\"line\"></span><br><span class=\"line\">     myCallback(perfect,n);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h1><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>\n<p>为什么要使用回调函数？</p>\n<ul>\n<li><p>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</p>\n</li>\n<li><p>如果想知道回调函数在实际中有什么作用，先假设有这样一种情况，我们要编写一个库，它提供了某些排序算法的实现，如冒泡排序、快速排序、shell排序、shake排序等等，但为使库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，想让库可用于多种数据类型（int、float、string），此时，该怎么办呢？可以使用函数指针，并进行回调。</p>\n</li>\n</ul>\n<p>回调可用于通知机制，例如，有时要在程序中设置一个计时器，每到一定时间，程序会得到相应的通知，但通知机制的实现者对我们的程序一无所知。而此时，就需有一个特定原型的函数指针，用这个指针来进行回调，来通知我们的程序事件已经发生。实际上，SetTimer() API使用了一个回调函数来通知计时器，而且，万一没有提供回调函数，它还会把一个消息发往程序的消息队列。</p>\n<p>另一个使用回调机制的API函数是EnumWindow()，它枚举屏幕上所有的顶层窗口，为每个窗口调用一个程序提供的函数，并传递窗口的处理程序。如果被调用者返回一个值，就继续进行迭代，否则，退出。EnumWindow()并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。</p>\n<p>不管怎么说，回调函数是继续自C语言的，因而，在C++中，应只在与C代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在C++中应使用虚拟方法或函数符（functor），而不是回调函数。</p>\n<p>下面是一个简单的回调函数，相比其他的那些复杂的代码，这个更容易理解：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdio.h&gt;;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;stdlib.h&gt;;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">perfect</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&amp;lt;n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">0</span>==n%i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           count+=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(count==n)</span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(&amp;quot;%d是完数\\n&amp;quot;,n);</span><br><span class=\"line\">     <span class=\"keyword\">else</span> </span><br><span class=\"line\">         <span class=\"built_in\">printf</span>(&amp;quot;%d不是完数\\n&amp;quot;,n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myCallback</span><span class=\"params\">(<span class=\"keyword\">void</span> (*perfect)(<span class=\"keyword\">int</span> ),<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     perfect(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(&amp;quot;请输入一个正整数\\n&amp;quot;);</span><br><span class=\"line\">     <span class=\"built_in\">scanf</span>(&amp;quot;%d&amp;quot;,&amp;amp;n);</span><br><span class=\"line\"></span><br><span class=\"line\">     myCallback(perfect,n);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"[Issue] Can't find the C/C++ project option in Eclipse on Mac OS","id":"32","date":"2015-03-25T08:56:37.000Z","_content":"\nEclipse Luna + MacOS 10.10 Yosemite\n\nAfter installing CDT, can't find the c/c++ project option under new menu.\n\nTry to install the latest version JDK, and restart eclipse.\n","source":"_posts/CantFindeCCppProjectOptionInEclipse.md","raw":"---\ntitle: \"[Issue] Can't find the C/C++ project option in Eclipse on Mac OS\"\nid: 32\ncategories:\n  - Issues Solution\ndate: 2015-03-25 04:56:37\ntags:\n  - Eclipse\n  - MacOS\n---\n\nEclipse Luna + MacOS 10.10 Yosemite\n\nAfter installing CDT, can't find the c/c++ project option under new menu.\n\nTry to install the latest version JDK, and restart eclipse.\n","slug":"CantFindeCCppProjectOptionInEclipse","published":1,"updated":"2019-02-12T00:36:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk0y000dlkgu8quts1w8","content":"<p>Eclipse Luna + MacOS 10.10 Yosemite</p>\n<p>After installing CDT, can’t find the c/c++ project option under new menu.</p>\n<p>Try to install the latest version JDK, and restart eclipse.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Eclipse Luna + MacOS 10.10 Yosemite</p>\n<p>After installing CDT, can’t find the c/c++ project option under new menu.</p>\n<p>Try to install the latest version JDK, and restart eclipse.</p>\n"},{"title":"Cracking the Coding Interview - Chapter 4 Tree and Graph","id":"73","date":"2015-04-15T21:14:24.000Z","_content":"\n# Chapter 4 Tree and Graph\n\n4.1 Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.\n\n*   根据题目，一颗二叉树的平衡是指深度最小和最大的叶子节点深度差不超过1.\n*   我们可以遍历二叉树找出最小深度和最大深度的叶子节点，然后求深度差.\n*   我们使用vector来存储每个节点的深度，之后比较最大深度与最小深度.\n*   [Q4.1_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.2 Given a directed graph, design an algorithm to find out whether there is a route between two nodes.\n\n*   从给定的点遍历图如果不用回退能到达另一个节点说明两个节点之间存在路径\n*   可以简单的修改BFS算法，在a节点遍历完之后，不回退，如果访问过b节点则存在路径\n*   [Q4.2_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/GraphHelper.java)\n\n4.3 Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search tree with minimal height.\n\n*   要构建BST，它的中序遍历也应该是一个递增序列.\n*   要使树的高度最小，我们需要是左右子树的高度尽可能相同，所以中分数组，之后再中分\n*   [Q4.3_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.4 Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g. if you have a tree with depth D, you'll have D linked lists).\n\n*   遍历二叉树，计算当前节点的深度，构造Vector<Vector<TreeNode>>, 将当前节点存入其链表，\n*   比如depth是n，就存入index 为n的链表中.\n*   [Q4.4_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.5 Implement a function to check if a binary tree is a binary search tree.\n\n*   二叉搜索树的左节点<父节点<右节点\n*   使用中序遍历得到的结果如果是一组由小到大排序的数组，则是二叉搜索树。\n*   [Q4.5_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.6 Write an algorithm to find the 'next' node(i.e., in-order successor) of a given node in a binary search tree. You may assume that each node has a link to its parent.\n\n*   分两种情况，如果一个节点有右子树，其successor即位右子树上的最左节点，\n*   如果一个节点没有右子树，其successor为第一个大于它的祖先节点.\n*   [Q4.6_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.7 Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a structure. NOTE: This is not necessarily a binary search tree.\n\n*   使用map，将第一个节点的所有父节点存入map\n*   遍历第二个节点的父节存入map中，第一个重复的即为第一个共同的祖先节点\n*   [Q4.7_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.8 You have two very large binary trees: T1, with millions of nodes, and T2, with hundreds of nodes. Create an algorithm to decide if T2 is a subtree of T1.\n\nA tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2\\. That is, if you cut off the tree at node n, the two tree would be identical.\n\n*   暴力方法，在T1中找到T2的根节点，然后开始匹配左右子树\n*   如果二叉树中节点的值都不相同，则可以使用一种相同的遍历，将两棵树的遍历存成数组，然后比较一个是不是另一个的子串。\n\n4.9 You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum to a given value. The path does not need to start or end at the root or a leaf, but it must go in a straight line down.\n\n*   这道题可以直观的转化为查找路径，我们要找和为规定值的所有路径，\n*   因为要求路径必须是从上直接到下即不能回退，所以这些路一定包含在从跟节点到所有叶子的全部路径中\n*   所以我们可以在查找全部根节点至叶子节点的路径中计算路径和\n*   思路即查找所有根节点至叶子节点的路径，将他们存成vector，在每个vector中在查找和为规定值的路径\n*   有多少叶子节点，就要存多少个vector。\n*   [Q4.9_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)","source":"_posts/CCI_Chapter4.md","raw":"---\ntitle: Cracking the Coding Interview - Chapter 4 Tree and Graph\nid: 73\ncategories:\n  - Cracking the Coding Interview (Fifth edition)\ndate: 2015-04-15 17:14:24\ntags:\n---\n\n# Chapter 4 Tree and Graph\n\n4.1 Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.\n\n*   根据题目，一颗二叉树的平衡是指深度最小和最大的叶子节点深度差不超过1.\n*   我们可以遍历二叉树找出最小深度和最大深度的叶子节点，然后求深度差.\n*   我们使用vector来存储每个节点的深度，之后比较最大深度与最小深度.\n*   [Q4.1_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.2 Given a directed graph, design an algorithm to find out whether there is a route between two nodes.\n\n*   从给定的点遍历图如果不用回退能到达另一个节点说明两个节点之间存在路径\n*   可以简单的修改BFS算法，在a节点遍历完之后，不回退，如果访问过b节点则存在路径\n*   [Q4.2_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/GraphHelper.java)\n\n4.3 Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search tree with minimal height.\n\n*   要构建BST，它的中序遍历也应该是一个递增序列.\n*   要使树的高度最小，我们需要是左右子树的高度尽可能相同，所以中分数组，之后再中分\n*   [Q4.3_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.4 Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g. if you have a tree with depth D, you'll have D linked lists).\n\n*   遍历二叉树，计算当前节点的深度，构造Vector<Vector<TreeNode>>, 将当前节点存入其链表，\n*   比如depth是n，就存入index 为n的链表中.\n*   [Q4.4_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.5 Implement a function to check if a binary tree is a binary search tree.\n\n*   二叉搜索树的左节点<父节点<右节点\n*   使用中序遍历得到的结果如果是一组由小到大排序的数组，则是二叉搜索树。\n*   [Q4.5_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.6 Write an algorithm to find the 'next' node(i.e., in-order successor) of a given node in a binary search tree. You may assume that each node has a link to its parent.\n\n*   分两种情况，如果一个节点有右子树，其successor即位右子树上的最左节点，\n*   如果一个节点没有右子树，其successor为第一个大于它的祖先节点.\n*   [Q4.6_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.7 Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a structure. NOTE: This is not necessarily a binary search tree.\n\n*   使用map，将第一个节点的所有父节点存入map\n*   遍历第二个节点的父节存入map中，第一个重复的即为第一个共同的祖先节点\n*   [Q4.7_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)\n\n4.8 You have two very large binary trees: T1, with millions of nodes, and T2, with hundreds of nodes. Create an algorithm to decide if T2 is a subtree of T1.\n\nA tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2\\. That is, if you cut off the tree at node n, the two tree would be identical.\n\n*   暴力方法，在T1中找到T2的根节点，然后开始匹配左右子树\n*   如果二叉树中节点的值都不相同，则可以使用一种相同的遍历，将两棵树的遍历存成数组，然后比较一个是不是另一个的子串。\n\n4.9 You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum to a given value. The path does not need to start or end at the root or a leaf, but it must go in a straight line down.\n\n*   这道题可以直观的转化为查找路径，我们要找和为规定值的所有路径，\n*   因为要求路径必须是从上直接到下即不能回退，所以这些路一定包含在从跟节点到所有叶子的全部路径中\n*   所以我们可以在查找全部根节点至叶子节点的路径中计算路径和\n*   思路即查找所有根节点至叶子节点的路径，将他们存成vector，在每个vector中在查找和为规定值的路径\n*   有多少叶子节点，就要存多少个vector。\n*   [Q4.9_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java)","slug":"CCI_Chapter4","published":1,"updated":"2019-02-10T17:11:09.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk0z000flkgujz72qjwj","content":"<h1 id=\"Chapter-4-Tree-and-Graph\"><a href=\"#Chapter-4-Tree-and-Graph\" class=\"headerlink\" title=\"Chapter 4 Tree and Graph\"></a>Chapter 4 Tree and Graph</h1><p>4.1 Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.</p>\n<ul>\n<li>根据题目，一颗二叉树的平衡是指深度最小和最大的叶子节点深度差不超过1.</li>\n<li>我们可以遍历二叉树找出最小深度和最大深度的叶子节点，然后求深度差.</li>\n<li>我们使用vector来存储每个节点的深度，之后比较最大深度与最小深度.</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.1_Implementation</a></li>\n</ul>\n<p>4.2 Given a directed graph, design an algorithm to find out whether there is a route between two nodes.</p>\n<ul>\n<li>从给定的点遍历图如果不用回退能到达另一个节点说明两个节点之间存在路径</li>\n<li>可以简单的修改BFS算法，在a节点遍历完之后，不回退，如果访问过b节点则存在路径</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/GraphHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.2_Implementation</a></li>\n</ul>\n<p>4.3 Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search tree with minimal height.</p>\n<ul>\n<li>要构建BST，它的中序遍历也应该是一个递增序列.</li>\n<li>要使树的高度最小，我们需要是左右子树的高度尽可能相同，所以中分数组，之后再中分</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.3_Implementation</a></li>\n</ul>\n<p>4.4 Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g. if you have a tree with depth D, you’ll have D linked lists).</p>\n<ul>\n<li>遍历二叉树，计算当前节点的深度，构造Vector&lt;Vector<treenode>&gt;, 将当前节点存入其链表，</treenode></li>\n<li>比如depth是n，就存入index 为n的链表中.</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.4_Implementation</a></li>\n</ul>\n<p>4.5 Implement a function to check if a binary tree is a binary search tree.</p>\n<ul>\n<li>二叉搜索树的左节点&lt;父节点&lt;右节点</li>\n<li>使用中序遍历得到的结果如果是一组由小到大排序的数组，则是二叉搜索树。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.5_Implementation</a></li>\n</ul>\n<p>4.6 Write an algorithm to find the ‘next’ node(i.e., in-order successor) of a given node in a binary search tree. You may assume that each node has a link to its parent.</p>\n<ul>\n<li>分两种情况，如果一个节点有右子树，其successor即位右子树上的最左节点，</li>\n<li>如果一个节点没有右子树，其successor为第一个大于它的祖先节点.</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.6_Implementation</a></li>\n</ul>\n<p>4.7 Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a structure. NOTE: This is not necessarily a binary search tree.</p>\n<ul>\n<li>使用map，将第一个节点的所有父节点存入map</li>\n<li>遍历第二个节点的父节存入map中，第一个重复的即为第一个共同的祖先节点</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.7_Implementation</a></li>\n</ul>\n<p>4.8 You have two very large binary trees: T1, with millions of nodes, and T2, with hundreds of nodes. Create an algorithm to decide if T2 is a subtree of T1.</p>\n<p>A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the two tree would be identical.</p>\n<ul>\n<li>暴力方法，在T1中找到T2的根节点，然后开始匹配左右子树</li>\n<li>如果二叉树中节点的值都不相同，则可以使用一种相同的遍历，将两棵树的遍历存成数组，然后比较一个是不是另一个的子串。</li>\n</ul>\n<p>4.9 You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum to a given value. The path does not need to start or end at the root or a leaf, but it must go in a straight line down.</p>\n<ul>\n<li>这道题可以直观的转化为查找路径，我们要找和为规定值的所有路径，</li>\n<li>因为要求路径必须是从上直接到下即不能回退，所以这些路一定包含在从跟节点到所有叶子的全部路径中</li>\n<li>所以我们可以在查找全部根节点至叶子节点的路径中计算路径和</li>\n<li>思路即查找所有根节点至叶子节点的路径，将他们存成vector，在每个vector中在查找和为规定值的路径</li>\n<li>有多少叶子节点，就要存多少个vector。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.9_Implementation</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Chapter-4-Tree-and-Graph\"><a href=\"#Chapter-4-Tree-and-Graph\" class=\"headerlink\" title=\"Chapter 4 Tree and Graph\"></a>Chapter 4 Tree and Graph</h1><p>4.1 Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.</p>\n<ul>\n<li>根据题目，一颗二叉树的平衡是指深度最小和最大的叶子节点深度差不超过1.</li>\n<li>我们可以遍历二叉树找出最小深度和最大深度的叶子节点，然后求深度差.</li>\n<li>我们使用vector来存储每个节点的深度，之后比较最大深度与最小深度.</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.1_Implementation</a></li>\n</ul>\n<p>4.2 Given a directed graph, design an algorithm to find out whether there is a route between two nodes.</p>\n<ul>\n<li>从给定的点遍历图如果不用回退能到达另一个节点说明两个节点之间存在路径</li>\n<li>可以简单的修改BFS算法，在a节点遍历完之后，不回退，如果访问过b节点则存在路径</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/GraphHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.2_Implementation</a></li>\n</ul>\n<p>4.3 Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search tree with minimal height.</p>\n<ul>\n<li>要构建BST，它的中序遍历也应该是一个递增序列.</li>\n<li>要使树的高度最小，我们需要是左右子树的高度尽可能相同，所以中分数组，之后再中分</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.3_Implementation</a></li>\n</ul>\n<p>4.4 Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g. if you have a tree with depth D, you’ll have D linked lists).</p>\n<ul>\n<li>遍历二叉树，计算当前节点的深度，构造Vector&lt;Vector<treenode>&gt;, 将当前节点存入其链表，</treenode></li>\n<li>比如depth是n，就存入index 为n的链表中.</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.4_Implementation</a></li>\n</ul>\n<p>4.5 Implement a function to check if a binary tree is a binary search tree.</p>\n<ul>\n<li>二叉搜索树的左节点&lt;父节点&lt;右节点</li>\n<li>使用中序遍历得到的结果如果是一组由小到大排序的数组，则是二叉搜索树。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.5_Implementation</a></li>\n</ul>\n<p>4.6 Write an algorithm to find the ‘next’ node(i.e., in-order successor) of a given node in a binary search tree. You may assume that each node has a link to its parent.</p>\n<ul>\n<li>分两种情况，如果一个节点有右子树，其successor即位右子树上的最左节点，</li>\n<li>如果一个节点没有右子树，其successor为第一个大于它的祖先节点.</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.6_Implementation</a></li>\n</ul>\n<p>4.7 Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a structure. NOTE: This is not necessarily a binary search tree.</p>\n<ul>\n<li>使用map，将第一个节点的所有父节点存入map</li>\n<li>遍历第二个节点的父节存入map中，第一个重复的即为第一个共同的祖先节点</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.7_Implementation</a></li>\n</ul>\n<p>4.8 You have two very large binary trees: T1, with millions of nodes, and T2, with hundreds of nodes. Create an algorithm to decide if T2 is a subtree of T1.</p>\n<p>A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the two tree would be identical.</p>\n<ul>\n<li>暴力方法，在T1中找到T2的根节点，然后开始匹配左右子树</li>\n<li>如果二叉树中节点的值都不相同，则可以使用一种相同的遍历，将两棵树的遍历存成数组，然后比较一个是不是另一个的子串。</li>\n</ul>\n<p>4.9 You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum to a given value. The path does not need to start or end at the root or a leaf, but it must go in a straight line down.</p>\n<ul>\n<li>这道题可以直观的转化为查找路径，我们要找和为规定值的所有路径，</li>\n<li>因为要求路径必须是从上直接到下即不能回退，所以这些路一定包含在从跟节点到所有叶子的全部路径中</li>\n<li>所以我们可以在查找全部根节点至叶子节点的路径中计算路径和</li>\n<li>思路即查找所有根节点至叶子节点的路径，将他们存成vector，在每个vector中在查找和为规定值的路径</li>\n<li>有多少叶子节点，就要存多少个vector。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/TreeGraph/BinaryTreeHelper.java\" target=\"_blank\" rel=\"noopener\">Q4.9_Implementation</a></li>\n</ul>\n"},{"title":"Cracking the Coding Interview - Chapter 3 Stacks and Queues","id":"67","date":"2015-04-09T07:29:22.000Z","_content":"\n## Chapter 3 Stacks and Queues\n\n3.1 Describe how you could use a single array to implement three stacks.\n\n*   We can divide the array into three equal parts,\n*   And the bases of each stack are 0, n/3, 2n/3,\n*   We can set a array to store the top of the stack,\n*   So we can implement pop() push(), peek().\n\n3.2 How would you design a stack which, in addition to push and pop, also has a function min which returns the minimum element? Push, pop and min should all operate in O(1) time.\n\n* 设计一个stack，使他拥有方法min可以返回stack中的最小值，保证所有操作都是O(1).\n*   可以在stack中新增一个栈minStack，\n*   有元素压栈时判断其与minStack栈顶大小，小于栈顶，将其压入minStack栈\n*   弹栈时，判断是否为minStack栈顶元素，是一起弹栈\n*   [Q3.2_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/StackWithMin.java)\n\n3.3 Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure _SetOfStacks_ that mimics this. _SetOfStacks_ should be composed of several stacks and should create a new stack once the previous one exceeds capacity. _SetOfStacks.push()_ and _SetOfStacks.pop(_) should behave identically to single stack (that is, pop() should return the same values as it would if there were just a singly stack).\n\nFOLLOW UP\n\nImplement a function _popAt(int index_) which performs a pop operation on a specific sub-stack.\n\n*   这里我们使用Vector Stack 来模拟这个SetOfStacks，需要给stack类添加一个length变量来保存其长度\n*   push：当当前的stack达到阀值长度，增加一个新的stack到vector中，在新的stack中push，标记加一\n*   pop：当单签的stack长度为1时，pop(),将该stack从vector中删除，并将标记减一\n*   popAt:对指定stack 弹栈操作，这里有一个问题，当弹位于中间的栈时，按照理论，之后的stack中的元素应该向下滑一位。\n*   这里较难处理，我们用一个新的栈tmpstack，当弹中部的栈时，将前面的栈中所有元素依次压入tmpstack，\n*   再将tmpstack中的所有元素依次弹栈俨如SetOfStacks.\n*   [Q3.3_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/SetOfStacks.java)\n\n3.4 In the classic problem of the Towers of Hanoi, you have 3 towers and N disks f different sizes which can slide onto any tower. The puzzle starts with disks sorted in ascending order of size from top to bottom (i.e., each disk sits on top of an even larger one). You have the following constraints:\n\n(1) Only one disk can be moved at a time.\n\n(2) A disk is slid off the top of one tower onto the next tower.\n\n(3) A disk can only be placed on top of a larger disk.\n\nWrite a program to move the disks from the first tower to the last using stacks.\n\n*   汉诺塔的解法很简单，要把n个盘子移到最右柱子上，就要把n-1个移到中间，再把第n个移到右柱\n*   同理就要把就要把n-1个移到中间，就要n-2 移到右柱\n*   使用递归\n*   [Q3.4_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/HanoiTower.java)\n\n3.5 Implement a MyQueue class which implements a queue using two stacks.\n\n*   queue 是FIFO，stack是LIFO.\n*   使用两个栈，一个为入栈，一个为出栈\n*   enqueue时将所有元素压入入栈，进队的元素压入入栈栈顶，\n*   dequeue时将所有元素压入出栈，出队的元素从出栈栈顶弹出.\n*   为了减少不必要的移动我们在入队时不考虑出栈是否为空\n*   我们只要在出对是判断出栈是否为空，为空则将入栈元素压入出栈再出队即可.\n*   两实现\n\n*   [Q3.5_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/MyQueue.java)\n\n3.6 Write a program to sort a stack in ascending order (with biggest items on top). You may use at most one additional stack to hold items, but you may not copy the elements into any other data structure (such as an array). The stack supports the following operations: push, pop, peek, and isEmpty.\n\n*   第二个stack可以用来排序，\n*   当第一个stack栈顶元素弹出时，将第二个stack中的比该元素大的依次弹出压入第一个stack中\n*   再将该元素压入二栈，第一个stack栈顶元素弹出，如果大于第二栈顶元素则直接压入第二个栈中。\n*   [Q3.6_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/StackHelper.java)\n\n3.7 An animal shelter holds only dogs and cats, and operates on a strictly \"first in, first out\" basis. People must adopt either the \"oldest\" (based on arrival time) of all animals at the shelter, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like, Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog and dequeueCat. You may use the built-in LinkedList data structure.\n\n*   我使用两个queue来分别保存dog和cat，\n*   但是在dog和cat的父类中加入index来区分dog和cat的顺序\n*   当dequeueAny时，判断 dog和cat 队头的顺序来确定哪种动物出队\n*   这个类完成的比较完整！！！！\n*   [Q3.7_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/Shelter.java)","source":"_posts/CCI_Chapter3.md","raw":"---\ntitle: Cracking the Coding Interview - Chapter 3 Stacks and Queues\nid: 67\ncategories:\n  - Cracking the Coding Interview (Fifth edition)\ndate: 2015-04-09 03:29:22\ntags:\n---\n\n## Chapter 3 Stacks and Queues\n\n3.1 Describe how you could use a single array to implement three stacks.\n\n*   We can divide the array into three equal parts,\n*   And the bases of each stack are 0, n/3, 2n/3,\n*   We can set a array to store the top of the stack,\n*   So we can implement pop() push(), peek().\n\n3.2 How would you design a stack which, in addition to push and pop, also has a function min which returns the minimum element? Push, pop and min should all operate in O(1) time.\n\n* 设计一个stack，使他拥有方法min可以返回stack中的最小值，保证所有操作都是O(1).\n*   可以在stack中新增一个栈minStack，\n*   有元素压栈时判断其与minStack栈顶大小，小于栈顶，将其压入minStack栈\n*   弹栈时，判断是否为minStack栈顶元素，是一起弹栈\n*   [Q3.2_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/StackWithMin.java)\n\n3.3 Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure _SetOfStacks_ that mimics this. _SetOfStacks_ should be composed of several stacks and should create a new stack once the previous one exceeds capacity. _SetOfStacks.push()_ and _SetOfStacks.pop(_) should behave identically to single stack (that is, pop() should return the same values as it would if there were just a singly stack).\n\nFOLLOW UP\n\nImplement a function _popAt(int index_) which performs a pop operation on a specific sub-stack.\n\n*   这里我们使用Vector Stack 来模拟这个SetOfStacks，需要给stack类添加一个length变量来保存其长度\n*   push：当当前的stack达到阀值长度，增加一个新的stack到vector中，在新的stack中push，标记加一\n*   pop：当单签的stack长度为1时，pop(),将该stack从vector中删除，并将标记减一\n*   popAt:对指定stack 弹栈操作，这里有一个问题，当弹位于中间的栈时，按照理论，之后的stack中的元素应该向下滑一位。\n*   这里较难处理，我们用一个新的栈tmpstack，当弹中部的栈时，将前面的栈中所有元素依次压入tmpstack，\n*   再将tmpstack中的所有元素依次弹栈俨如SetOfStacks.\n*   [Q3.3_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/SetOfStacks.java)\n\n3.4 In the classic problem of the Towers of Hanoi, you have 3 towers and N disks f different sizes which can slide onto any tower. The puzzle starts with disks sorted in ascending order of size from top to bottom (i.e., each disk sits on top of an even larger one). You have the following constraints:\n\n(1) Only one disk can be moved at a time.\n\n(2) A disk is slid off the top of one tower onto the next tower.\n\n(3) A disk can only be placed on top of a larger disk.\n\nWrite a program to move the disks from the first tower to the last using stacks.\n\n*   汉诺塔的解法很简单，要把n个盘子移到最右柱子上，就要把n-1个移到中间，再把第n个移到右柱\n*   同理就要把就要把n-1个移到中间，就要n-2 移到右柱\n*   使用递归\n*   [Q3.4_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/HanoiTower.java)\n\n3.5 Implement a MyQueue class which implements a queue using two stacks.\n\n*   queue 是FIFO，stack是LIFO.\n*   使用两个栈，一个为入栈，一个为出栈\n*   enqueue时将所有元素压入入栈，进队的元素压入入栈栈顶，\n*   dequeue时将所有元素压入出栈，出队的元素从出栈栈顶弹出.\n*   为了减少不必要的移动我们在入队时不考虑出栈是否为空\n*   我们只要在出对是判断出栈是否为空，为空则将入栈元素压入出栈再出队即可.\n*   两实现\n\n*   [Q3.5_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/MyQueue.java)\n\n3.6 Write a program to sort a stack in ascending order (with biggest items on top). You may use at most one additional stack to hold items, but you may not copy the elements into any other data structure (such as an array). The stack supports the following operations: push, pop, peek, and isEmpty.\n\n*   第二个stack可以用来排序，\n*   当第一个stack栈顶元素弹出时，将第二个stack中的比该元素大的依次弹出压入第一个stack中\n*   再将该元素压入二栈，第一个stack栈顶元素弹出，如果大于第二栈顶元素则直接压入第二个栈中。\n*   [Q3.6_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/StackHelper.java)\n\n3.7 An animal shelter holds only dogs and cats, and operates on a strictly \"first in, first out\" basis. People must adopt either the \"oldest\" (based on arrival time) of all animals at the shelter, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like, Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog and dequeueCat. You may use the built-in LinkedList data structure.\n\n*   我使用两个queue来分别保存dog和cat，\n*   但是在dog和cat的父类中加入index来区分dog和cat的顺序\n*   当dequeueAny时，判断 dog和cat 队头的顺序来确定哪种动物出队\n*   这个类完成的比较完整！！！！\n*   [Q3.7_Implementation](https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/Shelter.java)","slug":"CCI_Chapter3","published":1,"updated":"2019-02-10T17:11:09.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk11000jlkgu150f55y5","content":"<h2 id=\"Chapter-3-Stacks-and-Queues\"><a href=\"#Chapter-3-Stacks-and-Queues\" class=\"headerlink\" title=\"Chapter 3 Stacks and Queues\"></a>Chapter 3 Stacks and Queues</h2><p>3.1 Describe how you could use a single array to implement three stacks.</p>\n<ul>\n<li>We can divide the array into three equal parts,</li>\n<li>And the bases of each stack are 0, n/3, 2n/3,</li>\n<li>We can set a array to store the top of the stack,</li>\n<li>So we can implement pop() push(), peek().</li>\n</ul>\n<p>3.2 How would you design a stack which, in addition to push and pop, also has a function min which returns the minimum element? Push, pop and min should all operate in O(1) time.</p>\n<ul>\n<li>设计一个stack，使他拥有方法min可以返回stack中的最小值，保证所有操作都是O(1).</li>\n<li>可以在stack中新增一个栈minStack，</li>\n<li>有元素压栈时判断其与minStack栈顶大小，小于栈顶，将其压入minStack栈</li>\n<li>弹栈时，判断是否为minStack栈顶元素，是一起弹栈</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/StackWithMin.java\" target=\"_blank\" rel=\"noopener\">Q3.2_Implementation</a></li>\n</ul>\n<p>3.3 Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure <em>SetOfStacks</em> that mimics this. <em>SetOfStacks</em> should be composed of several stacks and should create a new stack once the previous one exceeds capacity. <em>SetOfStacks.push()</em> and <em>SetOfStacks.pop(</em>) should behave identically to single stack (that is, pop() should return the same values as it would if there were just a singly stack).</p>\n<p>FOLLOW UP</p>\n<p>Implement a function <em>popAt(int index</em>) which performs a pop operation on a specific sub-stack.</p>\n<ul>\n<li>这里我们使用Vector Stack 来模拟这个SetOfStacks，需要给stack类添加一个length变量来保存其长度</li>\n<li>push：当当前的stack达到阀值长度，增加一个新的stack到vector中，在新的stack中push，标记加一</li>\n<li>pop：当单签的stack长度为1时，pop(),将该stack从vector中删除，并将标记减一</li>\n<li>popAt:对指定stack 弹栈操作，这里有一个问题，当弹位于中间的栈时，按照理论，之后的stack中的元素应该向下滑一位。</li>\n<li>这里较难处理，我们用一个新的栈tmpstack，当弹中部的栈时，将前面的栈中所有元素依次压入tmpstack，</li>\n<li>再将tmpstack中的所有元素依次弹栈俨如SetOfStacks.</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/SetOfStacks.java\" target=\"_blank\" rel=\"noopener\">Q3.3_Implementation</a></li>\n</ul>\n<p>3.4 In the classic problem of the Towers of Hanoi, you have 3 towers and N disks f different sizes which can slide onto any tower. The puzzle starts with disks sorted in ascending order of size from top to bottom (i.e., each disk sits on top of an even larger one). You have the following constraints:</p>\n<p>(1) Only one disk can be moved at a time.</p>\n<p>(2) A disk is slid off the top of one tower onto the next tower.</p>\n<p>(3) A disk can only be placed on top of a larger disk.</p>\n<p>Write a program to move the disks from the first tower to the last using stacks.</p>\n<ul>\n<li>汉诺塔的解法很简单，要把n个盘子移到最右柱子上，就要把n-1个移到中间，再把第n个移到右柱</li>\n<li>同理就要把就要把n-1个移到中间，就要n-2 移到右柱</li>\n<li>使用递归</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/HanoiTower.java\" target=\"_blank\" rel=\"noopener\">Q3.4_Implementation</a></li>\n</ul>\n<p>3.5 Implement a MyQueue class which implements a queue using two stacks.</p>\n<ul>\n<li>queue 是FIFO，stack是LIFO.</li>\n<li>使用两个栈，一个为入栈，一个为出栈</li>\n<li>enqueue时将所有元素压入入栈，进队的元素压入入栈栈顶，</li>\n<li>dequeue时将所有元素压入出栈，出队的元素从出栈栈顶弹出.</li>\n<li>为了减少不必要的移动我们在入队时不考虑出栈是否为空</li>\n<li>我们只要在出对是判断出栈是否为空，为空则将入栈元素压入出栈再出队即可.</li>\n<li><p>两实现</p>\n</li>\n<li><p><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/MyQueue.java\" target=\"_blank\" rel=\"noopener\">Q3.5_Implementation</a></p>\n</li>\n</ul>\n<p>3.6 Write a program to sort a stack in ascending order (with biggest items on top). You may use at most one additional stack to hold items, but you may not copy the elements into any other data structure (such as an array). The stack supports the following operations: push, pop, peek, and isEmpty.</p>\n<ul>\n<li>第二个stack可以用来排序，</li>\n<li>当第一个stack栈顶元素弹出时，将第二个stack中的比该元素大的依次弹出压入第一个stack中</li>\n<li>再将该元素压入二栈，第一个stack栈顶元素弹出，如果大于第二栈顶元素则直接压入第二个栈中。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/StackHelper.java\" target=\"_blank\" rel=\"noopener\">Q3.6_Implementation</a></li>\n</ul>\n<p>3.7 An animal shelter holds only dogs and cats, and operates on a strictly “first in, first out” basis. People must adopt either the “oldest” (based on arrival time) of all animals at the shelter, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like, Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog and dequeueCat. You may use the built-in LinkedList data structure.</p>\n<ul>\n<li>我使用两个queue来分别保存dog和cat，</li>\n<li>但是在dog和cat的父类中加入index来区分dog和cat的顺序</li>\n<li>当dequeueAny时，判断 dog和cat 队头的顺序来确定哪种动物出队</li>\n<li>这个类完成的比较完整！！！！</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/Shelter.java\" target=\"_blank\" rel=\"noopener\">Q3.7_Implementation</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Chapter-3-Stacks-and-Queues\"><a href=\"#Chapter-3-Stacks-and-Queues\" class=\"headerlink\" title=\"Chapter 3 Stacks and Queues\"></a>Chapter 3 Stacks and Queues</h2><p>3.1 Describe how you could use a single array to implement three stacks.</p>\n<ul>\n<li>We can divide the array into three equal parts,</li>\n<li>And the bases of each stack are 0, n/3, 2n/3,</li>\n<li>We can set a array to store the top of the stack,</li>\n<li>So we can implement pop() push(), peek().</li>\n</ul>\n<p>3.2 How would you design a stack which, in addition to push and pop, also has a function min which returns the minimum element? Push, pop and min should all operate in O(1) time.</p>\n<ul>\n<li>设计一个stack，使他拥有方法min可以返回stack中的最小值，保证所有操作都是O(1).</li>\n<li>可以在stack中新增一个栈minStack，</li>\n<li>有元素压栈时判断其与minStack栈顶大小，小于栈顶，将其压入minStack栈</li>\n<li>弹栈时，判断是否为minStack栈顶元素，是一起弹栈</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/StackWithMin.java\" target=\"_blank\" rel=\"noopener\">Q3.2_Implementation</a></li>\n</ul>\n<p>3.3 Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure <em>SetOfStacks</em> that mimics this. <em>SetOfStacks</em> should be composed of several stacks and should create a new stack once the previous one exceeds capacity. <em>SetOfStacks.push()</em> and <em>SetOfStacks.pop(</em>) should behave identically to single stack (that is, pop() should return the same values as it would if there were just a singly stack).</p>\n<p>FOLLOW UP</p>\n<p>Implement a function <em>popAt(int index</em>) which performs a pop operation on a specific sub-stack.</p>\n<ul>\n<li>这里我们使用Vector Stack 来模拟这个SetOfStacks，需要给stack类添加一个length变量来保存其长度</li>\n<li>push：当当前的stack达到阀值长度，增加一个新的stack到vector中，在新的stack中push，标记加一</li>\n<li>pop：当单签的stack长度为1时，pop(),将该stack从vector中删除，并将标记减一</li>\n<li>popAt:对指定stack 弹栈操作，这里有一个问题，当弹位于中间的栈时，按照理论，之后的stack中的元素应该向下滑一位。</li>\n<li>这里较难处理，我们用一个新的栈tmpstack，当弹中部的栈时，将前面的栈中所有元素依次压入tmpstack，</li>\n<li>再将tmpstack中的所有元素依次弹栈俨如SetOfStacks.</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/SetOfStacks.java\" target=\"_blank\" rel=\"noopener\">Q3.3_Implementation</a></li>\n</ul>\n<p>3.4 In the classic problem of the Towers of Hanoi, you have 3 towers and N disks f different sizes which can slide onto any tower. The puzzle starts with disks sorted in ascending order of size from top to bottom (i.e., each disk sits on top of an even larger one). You have the following constraints:</p>\n<p>(1) Only one disk can be moved at a time.</p>\n<p>(2) A disk is slid off the top of one tower onto the next tower.</p>\n<p>(3) A disk can only be placed on top of a larger disk.</p>\n<p>Write a program to move the disks from the first tower to the last using stacks.</p>\n<ul>\n<li>汉诺塔的解法很简单，要把n个盘子移到最右柱子上，就要把n-1个移到中间，再把第n个移到右柱</li>\n<li>同理就要把就要把n-1个移到中间，就要n-2 移到右柱</li>\n<li>使用递归</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/HanoiTower.java\" target=\"_blank\" rel=\"noopener\">Q3.4_Implementation</a></li>\n</ul>\n<p>3.5 Implement a MyQueue class which implements a queue using two stacks.</p>\n<ul>\n<li>queue 是FIFO，stack是LIFO.</li>\n<li>使用两个栈，一个为入栈，一个为出栈</li>\n<li>enqueue时将所有元素压入入栈，进队的元素压入入栈栈顶，</li>\n<li>dequeue时将所有元素压入出栈，出队的元素从出栈栈顶弹出.</li>\n<li>为了减少不必要的移动我们在入队时不考虑出栈是否为空</li>\n<li>我们只要在出对是判断出栈是否为空，为空则将入栈元素压入出栈再出队即可.</li>\n<li><p>两实现</p>\n</li>\n<li><p><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/MyQueue.java\" target=\"_blank\" rel=\"noopener\">Q3.5_Implementation</a></p>\n</li>\n</ul>\n<p>3.6 Write a program to sort a stack in ascending order (with biggest items on top). You may use at most one additional stack to hold items, but you may not copy the elements into any other data structure (such as an array). The stack supports the following operations: push, pop, peek, and isEmpty.</p>\n<ul>\n<li>第二个stack可以用来排序，</li>\n<li>当第一个stack栈顶元素弹出时，将第二个stack中的比该元素大的依次弹出压入第一个stack中</li>\n<li>再将该元素压入二栈，第一个stack栈顶元素弹出，如果大于第二栈顶元素则直接压入第二个栈中。</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/StackHelper.java\" target=\"_blank\" rel=\"noopener\">Q3.6_Implementation</a></li>\n</ul>\n<p>3.7 An animal shelter holds only dogs and cats, and operates on a strictly “first in, first out” basis. People must adopt either the “oldest” (based on arrival time) of all animals at the shelter, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like, Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog and dequeueCat. You may use the built-in LinkedList data structure.</p>\n<ul>\n<li>我使用两个queue来分别保存dog和cat，</li>\n<li>但是在dog和cat的父类中加入index来区分dog和cat的顺序</li>\n<li>当dequeueAny时，判断 dog和cat 队头的顺序来确定哪种动物出队</li>\n<li>这个类完成的比较完整！！！！</li>\n<li><a href=\"https://github.com/godlzr/CrackingCodingInterview/blob/master/src/com/DataStructures/StacksQueues/Shelter.java\" target=\"_blank\" rel=\"noopener\">Q3.7_Implementation</a></li>\n</ul>\n"},{"title":"Clara.io V2 Player","id":"912","date":"2017-02-07T02:06:35.000Z","_content":"\n\n<iframe height=400 width=600 src=\"https://clara.io/player/v2/330e2db3-cc9f-4aa3-b7dd-9e7318f56915\" frameborder=0 allowfullscreen></iframe>","source":"_posts/ClaraV2Player.md","raw":"---\ntitle: Clara.io V2 Player\nid: 912\ncategories:\n  - Computer Graphics\ndate: 2017-02-06 21:06:35\ntags:\n---\n\n\n<iframe height=400 width=600 src=\"https://clara.io/player/v2/330e2db3-cc9f-4aa3-b7dd-9e7318f56915\" frameborder=0 allowfullscreen></iframe>","slug":"ClaraV2Player","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk11000llkgun8zxxgkw","content":"<iframe height=\"400\" width=\"600\" src=\"https://clara.io/player/v2/330e2db3-cc9f-4aa3-b7dd-9e7318f56915\" frameborder=\"0\" allowfullscreen></iframe>","site":{"data":{}},"excerpt":"","more":"<iframe height=\"400\" width=\"600\" src=\"https://clara.io/player/v2/330e2db3-cc9f-4aa3-b7dd-9e7318f56915\" frameborder=\"0\" allowfullscreen></iframe>"},{"title":"Blog clean up","id":"500","date":"2017-02-04T04:04:56.000Z","_content":"\nI am cleaning up my blog, all old and new articles are coming along.","source":"_posts/CleanUpMyBlog.md","raw":"---\ntitle: Blog clean up\nid: 500\ndate: 2017-02-3 23:04:56\ntags: others\n---\n\nI am cleaning up my blog, all old and new articles are coming along.","slug":"CleanUpMyBlog","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk13000olkgue4fiqjv4","content":"<p>I am cleaning up my blog, all old and new articles are coming along.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>I am cleaning up my blog, all old and new articles are coming along.</p>\n"},{"title":"Design Pattern - Behavioural","id":"346","date":"2015-09-02T16:25:58.000Z","_content":"\n1.责任链模式[Chain of Responsibility](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/chainOfResponsibility)\n\n* 能够将处理同一类请求的对象连城一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理否则传递给链上的下一个对象。所有的对象有[抽象类](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/chainOfResponsibility/Leader.java)控制\n* 场景：打牌轮流出牌，接力赛跑，奖学金审批，公文审批\n* 开发中的场景：异常机制，javascript时间的冒泡捕获，java是观察者，Servlet过滤器，structs2拦截器的调用。\n\n2.迭代器模式[Iterator](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/iterator)\n\n* 提供一种可以遍历聚合对象的方式，又称为：游标cursor模式\n* 聚合对象：存储数据 \n* 迭代器：遍历对象\n* 正向逆向遍历\n* 开发中的场景：jdk 内置迭代器\n\n3.中介者模式[Mediator](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/mediator)\n\n* 如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，这些对象称为同事对象，我们可以引入一个中介者对象，使各个同事对象只跟中介者对象打交道，将复杂的网状结构化解为星型结构\n* 实现同事对象之间的解耦，通过中介者对象统一的管理交互\n* 开发中的场景： MVC中C就是中介","source":"_posts/DesignPattern_Behavioural.md","raw":"---\ntitle: Design Pattern - Behavioural\nid: 346\ncategories:\n  - Design Patterns\ndate: 2015-09-02 12:25:58\ntags:\n---\n\n1.责任链模式[Chain of Responsibility](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/chainOfResponsibility)\n\n* 能够将处理同一类请求的对象连城一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理否则传递给链上的下一个对象。所有的对象有[抽象类](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/chainOfResponsibility/Leader.java)控制\n* 场景：打牌轮流出牌，接力赛跑，奖学金审批，公文审批\n* 开发中的场景：异常机制，javascript时间的冒泡捕获，java是观察者，Servlet过滤器，structs2拦截器的调用。\n\n2.迭代器模式[Iterator](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/iterator)\n\n* 提供一种可以遍历聚合对象的方式，又称为：游标cursor模式\n* 聚合对象：存储数据 \n* 迭代器：遍历对象\n* 正向逆向遍历\n* 开发中的场景：jdk 内置迭代器\n\n3.中介者模式[Mediator](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/mediator)\n\n* 如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，这些对象称为同事对象，我们可以引入一个中介者对象，使各个同事对象只跟中介者对象打交道，将复杂的网状结构化解为星型结构\n* 实现同事对象之间的解耦，通过中介者对象统一的管理交互\n* 开发中的场景： MVC中C就是中介","slug":"DesignPattern_Behavioural","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk13000rlkgurx044huo","content":"<p>1.责任链模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/chainOfResponsibility\" target=\"_blank\" rel=\"noopener\">Chain of Responsibility</a></p>\n<ul>\n<li>能够将处理同一类请求的对象连城一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理否则传递给链上的下一个对象。所有的对象有<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/chainOfResponsibility/Leader.java\" target=\"_blank\" rel=\"noopener\">抽象类</a>控制</li>\n<li>场景：打牌轮流出牌，接力赛跑，奖学金审批，公文审批</li>\n<li>开发中的场景：异常机制，javascript时间的冒泡捕获，java是观察者，Servlet过滤器，structs2拦截器的调用。</li>\n</ul>\n<p>2.迭代器模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/iterator\" target=\"_blank\" rel=\"noopener\">Iterator</a></p>\n<ul>\n<li>提供一种可以遍历聚合对象的方式，又称为：游标cursor模式</li>\n<li>聚合对象：存储数据 </li>\n<li>迭代器：遍历对象</li>\n<li>正向逆向遍历</li>\n<li>开发中的场景：jdk 内置迭代器</li>\n</ul>\n<p>3.中介者模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/mediator\" target=\"_blank\" rel=\"noopener\">Mediator</a></p>\n<ul>\n<li>如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，这些对象称为同事对象，我们可以引入一个中介者对象，使各个同事对象只跟中介者对象打交道，将复杂的网状结构化解为星型结构</li>\n<li>实现同事对象之间的解耦，通过中介者对象统一的管理交互</li>\n<li>开发中的场景： MVC中C就是中介</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>1.责任链模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/chainOfResponsibility\" target=\"_blank\" rel=\"noopener\">Chain of Responsibility</a></p>\n<ul>\n<li>能够将处理同一类请求的对象连城一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理否则传递给链上的下一个对象。所有的对象有<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/chainOfResponsibility/Leader.java\" target=\"_blank\" rel=\"noopener\">抽象类</a>控制</li>\n<li>场景：打牌轮流出牌，接力赛跑，奖学金审批，公文审批</li>\n<li>开发中的场景：异常机制，javascript时间的冒泡捕获，java是观察者，Servlet过滤器，structs2拦截器的调用。</li>\n</ul>\n<p>2.迭代器模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/iterator\" target=\"_blank\" rel=\"noopener\">Iterator</a></p>\n<ul>\n<li>提供一种可以遍历聚合对象的方式，又称为：游标cursor模式</li>\n<li>聚合对象：存储数据 </li>\n<li>迭代器：遍历对象</li>\n<li>正向逆向遍历</li>\n<li>开发中的场景：jdk 内置迭代器</li>\n</ul>\n<p>3.中介者模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/mediator\" target=\"_blank\" rel=\"noopener\">Mediator</a></p>\n<ul>\n<li>如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，这些对象称为同事对象，我们可以引入一个中介者对象，使各个同事对象只跟中介者对象打交道，将复杂的网状结构化解为星型结构</li>\n<li>实现同事对象之间的解耦，通过中介者对象统一的管理交互</li>\n<li>开发中的场景： MVC中C就是中介</li>\n</ul>\n"},{"title":"Design Pattern - Behavioural 2","date":"2015-09-02T16:29:39.000Z","_content":"\n# 命令模式[Command](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/command)\n\n* 将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化； 对请求排队或者记录请求日志，以及支持可撤销的操作。也称为：动作模式action 事务模式transaction.\n* 结构：\n\t1.  Command 抽象命令类\n\t2.  ConcreteCommand具体命令类\n\t3.  Invoker调用者\n\t4.  Receiver接受者\n* 开发中的场景：Struts2中，action的整个调用过程就是命令模式，数据库事务机制的底层实现\n\n# 解释器模式 Interpreter\n\n* 不常用，开发新的语言时，可以考虑使用解释器模式。主要用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的编译器和解释器设计。\n* 在项目中可以使用js引擎等动态语言来替代解释器的作用，弥补java语言的不足。\n开发中的场景：EL表达式，正则表达式，SQL语法，数学表达式\n\n# 访问者模式 Visitor\n\n* 对于存储在一个集合中的对象，他们可能具有不同的类型，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同\n* 开发中的场景：XML文档解释器设计，编译器设计，复杂集合对象的处理\n\n# 策略模式 [Strategy](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/strategy)\n\n* 策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一个问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。\n* 策略接口，具体的策略类，上下文类管理策略\n* 开发中的场景：spring中 resource接口，资源访问策略\n\n# 模板方法模式 [Template](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/templateMethod)\n\n* 场景：客户到银行办理业务，1.取号排队2.办理具体业务3.给柜员评分。\n* 定义了算法的骨架，某些步骤延迟到子类中实现，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。\n* 又称为方法回调，钩子方法，\n* 实现算法时整体步骤固定，某些步骤易变，易变的部分可以抽象出来供子类实现。\n开发中的场景：数据库访问封装，Junit，hibernate模板。","source":"_posts/DesignPattern_Behavioural2.md","raw":"---\ntitle: Design Pattern - Behavioural 2\ncategories:\n  - Design Pattern\ndate: 2015-09-02 12:29:39\ntags:\n---\n\n# 命令模式[Command](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/command)\n\n* 将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化； 对请求排队或者记录请求日志，以及支持可撤销的操作。也称为：动作模式action 事务模式transaction.\n* 结构：\n\t1.  Command 抽象命令类\n\t2.  ConcreteCommand具体命令类\n\t3.  Invoker调用者\n\t4.  Receiver接受者\n* 开发中的场景：Struts2中，action的整个调用过程就是命令模式，数据库事务机制的底层实现\n\n# 解释器模式 Interpreter\n\n* 不常用，开发新的语言时，可以考虑使用解释器模式。主要用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的编译器和解释器设计。\n* 在项目中可以使用js引擎等动态语言来替代解释器的作用，弥补java语言的不足。\n开发中的场景：EL表达式，正则表达式，SQL语法，数学表达式\n\n# 访问者模式 Visitor\n\n* 对于存储在一个集合中的对象，他们可能具有不同的类型，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同\n* 开发中的场景：XML文档解释器设计，编译器设计，复杂集合对象的处理\n\n# 策略模式 [Strategy](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/strategy)\n\n* 策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一个问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。\n* 策略接口，具体的策略类，上下文类管理策略\n* 开发中的场景：spring中 resource接口，资源访问策略\n\n# 模板方法模式 [Template](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/templateMethod)\n\n* 场景：客户到银行办理业务，1.取号排队2.办理具体业务3.给柜员评分。\n* 定义了算法的骨架，某些步骤延迟到子类中实现，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。\n* 又称为方法回调，钩子方法，\n* 实现算法时整体步骤固定，某些步骤易变，易变的部分可以抽象出来供子类实现。\n开发中的场景：数据库访问封装，Junit，hibernate模板。","slug":"DesignPattern_Behavioural2","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk14000ulkguwi7ofcfp","content":"<h1 id=\"命令模式Command\"><a href=\"#命令模式Command\" class=\"headerlink\" title=\"命令模式Command\"></a>命令模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/command\" target=\"_blank\" rel=\"noopener\">Command</a></h1><ul>\n<li>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化； 对请求排队或者记录请求日志，以及支持可撤销的操作。也称为：动作模式action 事务模式transaction.</li>\n<li>结构：<ol>\n<li>Command 抽象命令类</li>\n<li>ConcreteCommand具体命令类</li>\n<li>Invoker调用者</li>\n<li>Receiver接受者</li>\n</ol>\n</li>\n<li>开发中的场景：Struts2中，action的整个调用过程就是命令模式，数据库事务机制的底层实现</li>\n</ul>\n<h1 id=\"解释器模式-Interpreter\"><a href=\"#解释器模式-Interpreter\" class=\"headerlink\" title=\"解释器模式 Interpreter\"></a>解释器模式 Interpreter</h1><ul>\n<li>不常用，开发新的语言时，可以考虑使用解释器模式。主要用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的编译器和解释器设计。</li>\n<li>在项目中可以使用js引擎等动态语言来替代解释器的作用，弥补java语言的不足。<br>开发中的场景：EL表达式，正则表达式，SQL语法，数学表达式</li>\n</ul>\n<h1 id=\"访问者模式-Visitor\"><a href=\"#访问者模式-Visitor\" class=\"headerlink\" title=\"访问者模式 Visitor\"></a>访问者模式 Visitor</h1><ul>\n<li>对于存储在一个集合中的对象，他们可能具有不同的类型，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同</li>\n<li>开发中的场景：XML文档解释器设计，编译器设计，复杂集合对象的处理</li>\n</ul>\n<h1 id=\"策略模式-Strategy\"><a href=\"#策略模式-Strategy\" class=\"headerlink\" title=\"策略模式 Strategy\"></a>策略模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/strategy\" target=\"_blank\" rel=\"noopener\">Strategy</a></h1><ul>\n<li>策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一个问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。</li>\n<li>策略接口，具体的策略类，上下文类管理策略</li>\n<li>开发中的场景：spring中 resource接口，资源访问策略</li>\n</ul>\n<h1 id=\"模板方法模式-Template\"><a href=\"#模板方法模式-Template\" class=\"headerlink\" title=\"模板方法模式 Template\"></a>模板方法模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/templateMethod\" target=\"_blank\" rel=\"noopener\">Template</a></h1><ul>\n<li>场景：客户到银行办理业务，1.取号排队2.办理具体业务3.给柜员评分。</li>\n<li>定义了算法的骨架，某些步骤延迟到子类中实现，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。</li>\n<li>又称为方法回调，钩子方法，</li>\n<li>实现算法时整体步骤固定，某些步骤易变，易变的部分可以抽象出来供子类实现。<br>开发中的场景：数据库访问封装，Junit，hibernate模板。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"命令模式Command\"><a href=\"#命令模式Command\" class=\"headerlink\" title=\"命令模式Command\"></a>命令模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/command\" target=\"_blank\" rel=\"noopener\">Command</a></h1><ul>\n<li>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化； 对请求排队或者记录请求日志，以及支持可撤销的操作。也称为：动作模式action 事务模式transaction.</li>\n<li>结构：<ol>\n<li>Command 抽象命令类</li>\n<li>ConcreteCommand具体命令类</li>\n<li>Invoker调用者</li>\n<li>Receiver接受者</li>\n</ol>\n</li>\n<li>开发中的场景：Struts2中，action的整个调用过程就是命令模式，数据库事务机制的底层实现</li>\n</ul>\n<h1 id=\"解释器模式-Interpreter\"><a href=\"#解释器模式-Interpreter\" class=\"headerlink\" title=\"解释器模式 Interpreter\"></a>解释器模式 Interpreter</h1><ul>\n<li>不常用，开发新的语言时，可以考虑使用解释器模式。主要用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的编译器和解释器设计。</li>\n<li>在项目中可以使用js引擎等动态语言来替代解释器的作用，弥补java语言的不足。<br>开发中的场景：EL表达式，正则表达式，SQL语法，数学表达式</li>\n</ul>\n<h1 id=\"访问者模式-Visitor\"><a href=\"#访问者模式-Visitor\" class=\"headerlink\" title=\"访问者模式 Visitor\"></a>访问者模式 Visitor</h1><ul>\n<li>对于存储在一个集合中的对象，他们可能具有不同的类型，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同</li>\n<li>开发中的场景：XML文档解释器设计，编译器设计，复杂集合对象的处理</li>\n</ul>\n<h1 id=\"策略模式-Strategy\"><a href=\"#策略模式-Strategy\" class=\"headerlink\" title=\"策略模式 Strategy\"></a>策略模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/strategy\" target=\"_blank\" rel=\"noopener\">Strategy</a></h1><ul>\n<li>策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一个问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。</li>\n<li>策略接口，具体的策略类，上下文类管理策略</li>\n<li>开发中的场景：spring中 resource接口，资源访问策略</li>\n</ul>\n<h1 id=\"模板方法模式-Template\"><a href=\"#模板方法模式-Template\" class=\"headerlink\" title=\"模板方法模式 Template\"></a>模板方法模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/templateMethod\" target=\"_blank\" rel=\"noopener\">Template</a></h1><ul>\n<li>场景：客户到银行办理业务，1.取号排队2.办理具体业务3.给柜员评分。</li>\n<li>定义了算法的骨架，某些步骤延迟到子类中实现，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。</li>\n<li>又称为方法回调，钩子方法，</li>\n<li>实现算法时整体步骤固定，某些步骤易变，易变的部分可以抽象出来供子类实现。<br>开发中的场景：数据库访问封装，Junit，hibernate模板。</li>\n</ul>\n"},{"title":"Design Pattern - Behavioural 3","date":"2015-09-08T20:10:18.000Z","_content":"\n# 状态模式 [State](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/state)\n\n* 不同的状态对应不同的行为，如红绿灯，电梯运行的各种状态。\n* 解决复杂对象的状态切换以及不同状态下行为的封装问题.\n* 结构：[context](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/state/Context.java)上下文类（维护state对象，定义了当前的状态），[state抽象状态类](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/state/State.java)，concretestate具体状态类（封装了状态对应的行为\n\n\n# 观察者模式[Observer](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/observer)\n\n* 实现群发广播机制，群体广播信息时使用，类比广播站和收音机，收音机就是观察者，广播站发送信号。\n* 广播的订阅者，客户称为观察者，需要同步给多个订阅者的数据封装到对象中，称之为目标。\n* 用于1：N的通知，当目标对象subject的状态变化时，他需要及时告知一系列对象（观察者）令他们做出响应。\n* 有推（观察者被动接受），拉（观察者自己决定什么时候获取内容）两个动作。\n* javase 提供了java.util.Observable 和java.util.Observer来实现[观察者模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/javaseObserver)\n* 开发中的场景: 聊天室中服务器转发给所有客户端。网络游戏中，服务器将客户状态分发，邮件订阅，android广播机制\n\n# 备忘录模式[Memento](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/memento)（纪念章）\n\n* 保持对象状态的功能，保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。\n* 结构:\n\t* 源发器类[Originator](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/EmpMemento.java)\n\t*  备忘录类[Memento](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/Emp.java)\n\t*  负责人类[CareTaker](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/CareTaker.java)\n* 开发中的场景: 撤销操作，事务管理，回滚操作，历史记录","source":"_posts/DesignPattern_Behavioural3.md","raw":"---\ntitle: Design Pattern - Behavioural 3\ncategories:\n  - Design Pattern\ndate: 2015-09-08 16:10:18\ntags:\n---\n\n# 状态模式 [State](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/state)\n\n* 不同的状态对应不同的行为，如红绿灯，电梯运行的各种状态。\n* 解决复杂对象的状态切换以及不同状态下行为的封装问题.\n* 结构：[context](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/state/Context.java)上下文类（维护state对象，定义了当前的状态），[state抽象状态类](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/state/State.java)，concretestate具体状态类（封装了状态对应的行为\n\n\n# 观察者模式[Observer](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/observer)\n\n* 实现群发广播机制，群体广播信息时使用，类比广播站和收音机，收音机就是观察者，广播站发送信号。\n* 广播的订阅者，客户称为观察者，需要同步给多个订阅者的数据封装到对象中，称之为目标。\n* 用于1：N的通知，当目标对象subject的状态变化时，他需要及时告知一系列对象（观察者）令他们做出响应。\n* 有推（观察者被动接受），拉（观察者自己决定什么时候获取内容）两个动作。\n* javase 提供了java.util.Observable 和java.util.Observer来实现[观察者模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/javaseObserver)\n* 开发中的场景: 聊天室中服务器转发给所有客户端。网络游戏中，服务器将客户状态分发，邮件订阅，android广播机制\n\n# 备忘录模式[Memento](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/memento)（纪念章）\n\n* 保持对象状态的功能，保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。\n* 结构:\n\t* 源发器类[Originator](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/EmpMemento.java)\n\t*  备忘录类[Memento](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/Emp.java)\n\t*  负责人类[CareTaker](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/CareTaker.java)\n* 开发中的场景: 撤销操作，事务管理，回滚操作，历史记录","slug":"DesignPattern_Behavioural3","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk15000xlkgufttah9o8","content":"<h1 id=\"状态模式-State\"><a href=\"#状态模式-State\" class=\"headerlink\" title=\"状态模式 State\"></a>状态模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/state\" target=\"_blank\" rel=\"noopener\">State</a></h1><ul>\n<li>不同的状态对应不同的行为，如红绿灯，电梯运行的各种状态。</li>\n<li>解决复杂对象的状态切换以及不同状态下行为的封装问题.</li>\n<li>结构：<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/state/Context.java\" target=\"_blank\" rel=\"noopener\">context</a>上下文类（维护state对象，定义了当前的状态），<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/state/State.java\" target=\"_blank\" rel=\"noopener\">state抽象状态类</a>，concretestate具体状态类（封装了状态对应的行为</li>\n</ul>\n<h1 id=\"观察者模式Observer\"><a href=\"#观察者模式Observer\" class=\"headerlink\" title=\"观察者模式Observer\"></a>观察者模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/observer\" target=\"_blank\" rel=\"noopener\">Observer</a></h1><ul>\n<li>实现群发广播机制，群体广播信息时使用，类比广播站和收音机，收音机就是观察者，广播站发送信号。</li>\n<li>广播的订阅者，客户称为观察者，需要同步给多个订阅者的数据封装到对象中，称之为目标。</li>\n<li>用于1：N的通知，当目标对象subject的状态变化时，他需要及时告知一系列对象（观察者）令他们做出响应。</li>\n<li>有推（观察者被动接受），拉（观察者自己决定什么时候获取内容）两个动作。</li>\n<li>javase 提供了java.util.Observable 和java.util.Observer来实现<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/javaseObserver\" target=\"_blank\" rel=\"noopener\">观察者模式</a></li>\n<li>开发中的场景: 聊天室中服务器转发给所有客户端。网络游戏中，服务器将客户状态分发，邮件订阅，android广播机制</li>\n</ul>\n<h1 id=\"备忘录模式Memento（纪念章）\"><a href=\"#备忘录模式Memento（纪念章）\" class=\"headerlink\" title=\"备忘录模式Memento（纪念章）\"></a>备忘录模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/memento\" target=\"_blank\" rel=\"noopener\">Memento</a>（纪念章）</h1><ul>\n<li>保持对象状态的功能，保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。</li>\n<li>结构:<ul>\n<li>源发器类<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/EmpMemento.java\" target=\"_blank\" rel=\"noopener\">Originator</a></li>\n<li>备忘录类<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/Emp.java\" target=\"_blank\" rel=\"noopener\">Memento</a></li>\n<li>负责人类<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/CareTaker.java\" target=\"_blank\" rel=\"noopener\">CareTaker</a></li>\n</ul>\n</li>\n<li>开发中的场景: 撤销操作，事务管理，回滚操作，历史记录</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"状态模式-State\"><a href=\"#状态模式-State\" class=\"headerlink\" title=\"状态模式 State\"></a>状态模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/state\" target=\"_blank\" rel=\"noopener\">State</a></h1><ul>\n<li>不同的状态对应不同的行为，如红绿灯，电梯运行的各种状态。</li>\n<li>解决复杂对象的状态切换以及不同状态下行为的封装问题.</li>\n<li>结构：<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/state/Context.java\" target=\"_blank\" rel=\"noopener\">context</a>上下文类（维护state对象，定义了当前的状态），<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/state/State.java\" target=\"_blank\" rel=\"noopener\">state抽象状态类</a>，concretestate具体状态类（封装了状态对应的行为</li>\n</ul>\n<h1 id=\"观察者模式Observer\"><a href=\"#观察者模式Observer\" class=\"headerlink\" title=\"观察者模式Observer\"></a>观察者模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/observer\" target=\"_blank\" rel=\"noopener\">Observer</a></h1><ul>\n<li>实现群发广播机制，群体广播信息时使用，类比广播站和收音机，收音机就是观察者，广播站发送信号。</li>\n<li>广播的订阅者，客户称为观察者，需要同步给多个订阅者的数据封装到对象中，称之为目标。</li>\n<li>用于1：N的通知，当目标对象subject的状态变化时，他需要及时告知一系列对象（观察者）令他们做出响应。</li>\n<li>有推（观察者被动接受），拉（观察者自己决定什么时候获取内容）两个动作。</li>\n<li>javase 提供了java.util.Observable 和java.util.Observer来实现<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/javaseObserver\" target=\"_blank\" rel=\"noopener\">观察者模式</a></li>\n<li>开发中的场景: 聊天室中服务器转发给所有客户端。网络游戏中，服务器将客户状态分发，邮件订阅，android广播机制</li>\n</ul>\n<h1 id=\"备忘录模式Memento（纪念章）\"><a href=\"#备忘录模式Memento（纪念章）\" class=\"headerlink\" title=\"备忘录模式Memento（纪念章）\"></a>备忘录模式<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.behavioural/memento\" target=\"_blank\" rel=\"noopener\">Memento</a>（纪念章）</h1><ul>\n<li>保持对象状态的功能，保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。</li>\n<li>结构:<ul>\n<li>源发器类<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/EmpMemento.java\" target=\"_blank\" rel=\"noopener\">Originator</a></li>\n<li>备忘录类<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/Emp.java\" target=\"_blank\" rel=\"noopener\">Memento</a></li>\n<li>负责人类<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.behavioural/memento/CareTaker.java\" target=\"_blank\" rel=\"noopener\">CareTaker</a></li>\n</ul>\n</li>\n<li>开发中的场景: 撤销操作，事务管理，回滚操作，历史记录</li>\n</ul>\n"},{"title":"Design Pattern - Creational 1","id":"304","date":"2015-08-13T16:37:50.000Z","_content":"\n# [单例模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/singleton)\n\n一个类只有一个对象，并且提供一个访问该实例的全局访问点, 例如，windows的任务管理器，回收站。\n\n* 调用效率，线程安全，懒加载\n\n* 优点：只有一个实例，内存占用和系统开销小，\n\n## 饿汉式：\n\n* 线程安全，调用效率高，不能延时加载\n\n```java\n/*\n * 测试饿汉式单例模式\n */\npublic class SingletonDemo1 {\n\n\t//由于加载类时天然的线程安全\n\tprivate static SingletonDemo1 instance = new SingletonDemo1();//2.类初始化时立即直接构造函数实例（饿汉式）（没有延时加载的优势）\n\n\tprivate SingletonDemo1(){\n\t}//1.构造函数私有化\n\n\t//方法没有同步，调用效率高\n\tpublic static SingletonDemo1 getInstance(){\n\t\treturn instance;\n\t}//3.实例唯一的访问方法\n}\n```\n\n## 懒汉式：\n\n*   线程安全，调用效率低，延时加载（懒加载，只有用的时候才new实例),\n*   需要同步，并发效率低。\n\n```java\n/*\n * 单例模式懒汉式\n */\npublic class SingletonDemo2 {\n\n\tprivate static SingletonDemo2 instance;//2.类初始化时不初始化对象实例，延时加载，真正使用的时候再加载\n\n\tprivate SingletonDemo2(){ }//1.构造函数私有化\n\n\t//4.SYNCHRONIZED 需要同步，调用效率低，保证同一时间只有一个线程访问获取实例函数，这样就不会有多个实例被创建\n\tpublic static synchronized SingletonDemo2 getInstance(){\n\t\tif( instance == null)\n\t\t{\n\t\t\tinstance = new SingletonDemo2();//3.使用的时候才真正构造对象实例，加载对象\n\t\t}\n\t\treturn instance;\n\t} \n}\n```\n\n*  双重检测锁 double check lock\n*  将同步检测放在if下，提高了调用的效率\n\n```java\n/*\n * 双重检查锁实现单例模式\n */\npublic class SingletonDemo3 {\n\tprivate static SingletonDemo3 instance = null;\n\n\tprivate SingletonDemo3(){}\n\n\tpublic static SingletonDemo3 getInstance(){\n\n\t\tif(instance == null){\n\t\t\tSingletonDemo3 sc;\n\t\t\tsynchronized (SingletonDemo3.class){\n\t\t\t\tsc = instance;\n\t\t\t\tif(sc == null){\n\t\t\t\t\tsynchronized (SingletonDemo3.class){\n\t\t\t\t\t\tif(sc == null){\n\t\t\t\t\t\t\tsc = new SingletonDemo3();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tinstance  = sc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n*   静态内部类(并发高效调用，和延时加载）\n\t*   也是一种懒加载\n\t*   使用静态内部类\n\n```java\n/*\n * 静态内部类实现单例模式\n * 这种方式线程安全，调用效率高，实现了延时加载\n */\n\npublic class SingletonDemo4 {\n\n\t//静态内部类\n\tprivate static class SingletonClassInstance{\n\t\tprivate static final SingletonDemo4 instance =  new SingletonDemo4();\n\t}\n\tprivate SingletonDemo4(){}\n\n\t//方法没有同步，调用效率高\n\tpublic static SingletonDemo4 getInstance(){\n\t\treturn SingletonClassInstance.instance;//调用时才加载静态内部类，并由静态内部类获取实例\n\t}\n}\n```\n\n*   枚举单例 （最安全）\n \t*   枚举对象天然是单例的\n    *   天然防止反射和反序列化\n\n```java\n/*\n * 枚举模式实现单例，枚举没有延时加载\n */\npublic enum SingletonDemo5 {\n\n\t//这个枚举元素本身就是单例\n\tINSTANCE;\n\t//添加自己需要的操作\n\tpublic void singletonOperation(){\n\t}\n}\n```\n\n* 如何选用\n\t*   单例对象 占用资源少 不需要延时加载：枚举 好于 饿汉\n\t*   单例对象 占用资源多 需要延时加载：静态内部类 好于 懒汉\n\n* 问题\n\n\t* [反射破解除枚举外的单例模式，](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/Client2.java)（[在构造器中判断实例是否为空](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/SingletonDemo6.java)，不是的话抛出异常，不初始化新实例）\n\t* [反序列化破解除枚举外的单例模式](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/Client2.java)。（[使用 readResolve() 防止](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/SingletonDemo6.java)）。","source":"_posts/DesignPattern_Creational1.md","raw":"---\ntitle: Design Pattern - Creational 1\nid: 304\ncategories:\n  - Desing Pattern\ndate: 2015-08-13 12:37:50\ntags:\n---\n\n# [单例模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/singleton)\n\n一个类只有一个对象，并且提供一个访问该实例的全局访问点, 例如，windows的任务管理器，回收站。\n\n* 调用效率，线程安全，懒加载\n\n* 优点：只有一个实例，内存占用和系统开销小，\n\n## 饿汉式：\n\n* 线程安全，调用效率高，不能延时加载\n\n```java\n/*\n * 测试饿汉式单例模式\n */\npublic class SingletonDemo1 {\n\n\t//由于加载类时天然的线程安全\n\tprivate static SingletonDemo1 instance = new SingletonDemo1();//2.类初始化时立即直接构造函数实例（饿汉式）（没有延时加载的优势）\n\n\tprivate SingletonDemo1(){\n\t}//1.构造函数私有化\n\n\t//方法没有同步，调用效率高\n\tpublic static SingletonDemo1 getInstance(){\n\t\treturn instance;\n\t}//3.实例唯一的访问方法\n}\n```\n\n## 懒汉式：\n\n*   线程安全，调用效率低，延时加载（懒加载，只有用的时候才new实例),\n*   需要同步，并发效率低。\n\n```java\n/*\n * 单例模式懒汉式\n */\npublic class SingletonDemo2 {\n\n\tprivate static SingletonDemo2 instance;//2.类初始化时不初始化对象实例，延时加载，真正使用的时候再加载\n\n\tprivate SingletonDemo2(){ }//1.构造函数私有化\n\n\t//4.SYNCHRONIZED 需要同步，调用效率低，保证同一时间只有一个线程访问获取实例函数，这样就不会有多个实例被创建\n\tpublic static synchronized SingletonDemo2 getInstance(){\n\t\tif( instance == null)\n\t\t{\n\t\t\tinstance = new SingletonDemo2();//3.使用的时候才真正构造对象实例，加载对象\n\t\t}\n\t\treturn instance;\n\t} \n}\n```\n\n*  双重检测锁 double check lock\n*  将同步检测放在if下，提高了调用的效率\n\n```java\n/*\n * 双重检查锁实现单例模式\n */\npublic class SingletonDemo3 {\n\tprivate static SingletonDemo3 instance = null;\n\n\tprivate SingletonDemo3(){}\n\n\tpublic static SingletonDemo3 getInstance(){\n\n\t\tif(instance == null){\n\t\t\tSingletonDemo3 sc;\n\t\t\tsynchronized (SingletonDemo3.class){\n\t\t\t\tsc = instance;\n\t\t\t\tif(sc == null){\n\t\t\t\t\tsynchronized (SingletonDemo3.class){\n\t\t\t\t\t\tif(sc == null){\n\t\t\t\t\t\t\tsc = new SingletonDemo3();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tinstance  = sc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n```\n\n*   静态内部类(并发高效调用，和延时加载）\n\t*   也是一种懒加载\n\t*   使用静态内部类\n\n```java\n/*\n * 静态内部类实现单例模式\n * 这种方式线程安全，调用效率高，实现了延时加载\n */\n\npublic class SingletonDemo4 {\n\n\t//静态内部类\n\tprivate static class SingletonClassInstance{\n\t\tprivate static final SingletonDemo4 instance =  new SingletonDemo4();\n\t}\n\tprivate SingletonDemo4(){}\n\n\t//方法没有同步，调用效率高\n\tpublic static SingletonDemo4 getInstance(){\n\t\treturn SingletonClassInstance.instance;//调用时才加载静态内部类，并由静态内部类获取实例\n\t}\n}\n```\n\n*   枚举单例 （最安全）\n \t*   枚举对象天然是单例的\n    *   天然防止反射和反序列化\n\n```java\n/*\n * 枚举模式实现单例，枚举没有延时加载\n */\npublic enum SingletonDemo5 {\n\n\t//这个枚举元素本身就是单例\n\tINSTANCE;\n\t//添加自己需要的操作\n\tpublic void singletonOperation(){\n\t}\n}\n```\n\n* 如何选用\n\t*   单例对象 占用资源少 不需要延时加载：枚举 好于 饿汉\n\t*   单例对象 占用资源多 需要延时加载：静态内部类 好于 懒汉\n\n* 问题\n\n\t* [反射破解除枚举外的单例模式，](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/Client2.java)（[在构造器中判断实例是否为空](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/SingletonDemo6.java)，不是的话抛出异常，不初始化新实例）\n\t* [反序列化破解除枚举外的单例模式](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/Client2.java)。（[使用 readResolve() 防止](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/SingletonDemo6.java)）。","slug":"DesignPattern_Creational1","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk160011lkgu2my6pz27","content":"<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/singleton\" target=\"_blank\" rel=\"noopener\">单例模式</a></h1><p>一个类只有一个对象，并且提供一个访问该实例的全局访问点, 例如，windows的任务管理器，回收站。</p>\n<ul>\n<li><p>调用效率，线程安全，懒加载</p>\n</li>\n<li><p>优点：只有一个实例，内存占用和系统开销小，</p>\n</li>\n</ul>\n<h2 id=\"饿汉式：\"><a href=\"#饿汉式：\" class=\"headerlink\" title=\"饿汉式：\"></a>饿汉式：</h2><ul>\n<li>线程安全，调用效率高，不能延时加载</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试饿汉式单例模式</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDemo1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//由于加载类时天然的线程安全</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingletonDemo1 instance = <span class=\"keyword\">new</span> SingletonDemo1();<span class=\"comment\">//2.类初始化时立即直接构造函数实例（饿汉式）（没有延时加载的优势）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonDemo1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t&#125;<span class=\"comment\">//1.构造函数私有化</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//方法没有同步，调用效率高</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonDemo1 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;<span class=\"comment\">//3.实例唯一的访问方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"懒汉式：\"><a href=\"#懒汉式：\" class=\"headerlink\" title=\"懒汉式：\"></a>懒汉式：</h2><ul>\n<li>线程安全，调用效率低，延时加载（懒加载，只有用的时候才new实例),</li>\n<li>需要同步，并发效率低。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 单例模式懒汉式</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDemo2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingletonDemo2 instance;<span class=\"comment\">//2.类初始化时不初始化对象实例，延时加载，真正使用的时候再加载</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonDemo2</span><span class=\"params\">()</span></span>&#123; &#125;<span class=\"comment\">//1.构造函数私有化</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//4.SYNCHRONIZED 需要同步，调用效率低，保证同一时间只有一个线程访问获取实例函数，这样就不会有多个实例被创建</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> SingletonDemo2 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>( instance == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tinstance = <span class=\"keyword\">new</span> SingletonDemo2();<span class=\"comment\">//3.使用的时候才真正构造对象实例，加载对象</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>双重检测锁 double check lock</li>\n<li>将同步检测放在if下，提高了调用的效率</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双重检查锁实现单例模式</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDemo3</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingletonDemo3 instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonDemo3</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonDemo3 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tSingletonDemo3 sc;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (SingletonDemo3.class)&#123;</span><br><span class=\"line\">\t\t\t\tsc = instance;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(sc == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">synchronized</span> (SingletonDemo3.class)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(sc == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tsc = <span class=\"keyword\">new</span> SingletonDemo3();</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tinstance  = sc;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>静态内部类(并发高效调用，和延时加载）<ul>\n<li>也是一种懒加载</li>\n<li>使用静态内部类</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 静态内部类实现单例模式</span></span><br><span class=\"line\"><span class=\"comment\"> * 这种方式线程安全，调用效率高，实现了延时加载</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDemo4</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//静态内部类</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonClassInstance</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> SingletonDemo4 instance =  <span class=\"keyword\">new</span> SingletonDemo4();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonDemo4</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//方法没有同步，调用效率高</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonDemo4 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> SingletonClassInstance.instance;<span class=\"comment\">//调用时才加载静态内部类，并由静态内部类获取实例</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>枚举单例 （最安全）<ul>\n<li>枚举对象天然是单例的<ul>\n<li>天然防止反射和反序列化</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 枚举模式实现单例，枚举没有延时加载</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> SingletonDemo5 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//这个枚举元素本身就是单例</span></span><br><span class=\"line\">\tINSTANCE;</span><br><span class=\"line\">\t<span class=\"comment\">//添加自己需要的操作</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">singletonOperation</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>如何选用</p>\n<ul>\n<li>单例对象 占用资源少 不需要延时加载：枚举 好于 饿汉</li>\n<li>单例对象 占用资源多 需要延时加载：静态内部类 好于 懒汉</li>\n</ul>\n</li>\n<li><p>问题</p>\n<ul>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/Client2.java\" target=\"_blank\" rel=\"noopener\">反射破解除枚举外的单例模式，</a>（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/SingletonDemo6.java\" target=\"_blank\" rel=\"noopener\">在构造器中判断实例是否为空</a>，不是的话抛出异常，不初始化新实例）</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/Client2.java\" target=\"_blank\" rel=\"noopener\">反序列化破解除枚举外的单例模式</a>。（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/SingletonDemo6.java\" target=\"_blank\" rel=\"noopener\">使用 readResolve() 防止</a>）。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/singleton\" target=\"_blank\" rel=\"noopener\">单例模式</a></h1><p>一个类只有一个对象，并且提供一个访问该实例的全局访问点, 例如，windows的任务管理器，回收站。</p>\n<ul>\n<li><p>调用效率，线程安全，懒加载</p>\n</li>\n<li><p>优点：只有一个实例，内存占用和系统开销小，</p>\n</li>\n</ul>\n<h2 id=\"饿汉式：\"><a href=\"#饿汉式：\" class=\"headerlink\" title=\"饿汉式：\"></a>饿汉式：</h2><ul>\n<li>线程安全，调用效率高，不能延时加载</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试饿汉式单例模式</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDemo1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//由于加载类时天然的线程安全</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingletonDemo1 instance = <span class=\"keyword\">new</span> SingletonDemo1();<span class=\"comment\">//2.类初始化时立即直接构造函数实例（饿汉式）（没有延时加载的优势）</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonDemo1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t&#125;<span class=\"comment\">//1.构造函数私有化</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//方法没有同步，调用效率高</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonDemo1 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;<span class=\"comment\">//3.实例唯一的访问方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"懒汉式：\"><a href=\"#懒汉式：\" class=\"headerlink\" title=\"懒汉式：\"></a>懒汉式：</h2><ul>\n<li>线程安全，调用效率低，延时加载（懒加载，只有用的时候才new实例),</li>\n<li>需要同步，并发效率低。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 单例模式懒汉式</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDemo2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingletonDemo2 instance;<span class=\"comment\">//2.类初始化时不初始化对象实例，延时加载，真正使用的时候再加载</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonDemo2</span><span class=\"params\">()</span></span>&#123; &#125;<span class=\"comment\">//1.构造函数私有化</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//4.SYNCHRONIZED 需要同步，调用效率低，保证同一时间只有一个线程访问获取实例函数，这样就不会有多个实例被创建</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> SingletonDemo2 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>( instance == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tinstance = <span class=\"keyword\">new</span> SingletonDemo2();<span class=\"comment\">//3.使用的时候才真正构造对象实例，加载对象</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>双重检测锁 double check lock</li>\n<li>将同步检测放在if下，提高了调用的效率</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 双重检查锁实现单例模式</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDemo3</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingletonDemo3 instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonDemo3</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonDemo3 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\tSingletonDemo3 sc;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">synchronized</span> (SingletonDemo3.class)&#123;</span><br><span class=\"line\">\t\t\t\tsc = instance;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(sc == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">synchronized</span> (SingletonDemo3.class)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(sc == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tsc = <span class=\"keyword\">new</span> SingletonDemo3();</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tinstance  = sc;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>静态内部类(并发高效调用，和延时加载）<ul>\n<li>也是一种懒加载</li>\n<li>使用静态内部类</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 静态内部类实现单例模式</span></span><br><span class=\"line\"><span class=\"comment\"> * 这种方式线程安全，调用效率高，实现了延时加载</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDemo4</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//静态内部类</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonClassInstance</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> SingletonDemo4 instance =  <span class=\"keyword\">new</span> SingletonDemo4();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonDemo4</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//方法没有同步，调用效率高</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonDemo4 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> SingletonClassInstance.instance;<span class=\"comment\">//调用时才加载静态内部类，并由静态内部类获取实例</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>枚举单例 （最安全）<ul>\n<li>枚举对象天然是单例的<ul>\n<li>天然防止反射和反序列化</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 枚举模式实现单例，枚举没有延时加载</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> SingletonDemo5 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//这个枚举元素本身就是单例</span></span><br><span class=\"line\">\tINSTANCE;</span><br><span class=\"line\">\t<span class=\"comment\">//添加自己需要的操作</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">singletonOperation</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>如何选用</p>\n<ul>\n<li>单例对象 占用资源少 不需要延时加载：枚举 好于 饿汉</li>\n<li>单例对象 占用资源多 需要延时加载：静态内部类 好于 懒汉</li>\n</ul>\n</li>\n<li><p>问题</p>\n<ul>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/Client2.java\" target=\"_blank\" rel=\"noopener\">反射破解除枚举外的单例模式，</a>（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/SingletonDemo6.java\" target=\"_blank\" rel=\"noopener\">在构造器中判断实例是否为空</a>，不是的话抛出异常，不初始化新实例）</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/Client2.java\" target=\"_blank\" rel=\"noopener\">反序列化破解除枚举外的单例模式</a>。（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/singleton/SingletonDemo6.java\" target=\"_blank\" rel=\"noopener\">使用 readResolve() 防止</a>）。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Design Pattern - Creational 2","id":"307","date":"2015-08-14T17:57:13.000Z","_content":"\n# 工厂模式\n\n* 实现创建者和调用者的分离\n* 面向对象的基本设计原则，分工\n\t* OCP(open close principle): 一个软件的实体应当对扩展开发对修改关闭，添加新类来扩展功能\n\t* DIP(dependency Inversion Principle): 针对接口编程，不要针对实现编程\n\tLoD(Law of Demeter): 只与你直接的朋友通信，而避免和陌生人通信\n* 分为 简单工厂模式，工厂方法模式，抽象工厂模式\n\t*   [简单工厂模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/simpleFactory)静态工厂，方法都是静态的， 通过接受不同参数创建不同实例， 增加新的类需要修改已有方法，扩展困难, 实际使用最多。\n\t*   [工厂方法模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/facotryMethod)：避免了简单工厂不满足ocp的缺点，简单工厂只有一个工厂类，而工厂方法模式有一组实现了相同接口的工厂类（一般都用简单工厂模式), 不修改已有类的前提下，增加新的工厂类来实现扩展\n\t*   [抽象工厂模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/abstractFactory)：用来生成不同产品族的全部产品， 工厂方法的升级版，不能增加产品，但能增加产品族。\n\n# [建造者模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/builder)\n\n* 对象的组件多，装配顺序复杂\n* 装配的问题，零件之间有一个装配顺序，分离了对象子组件的单独构造（[builder](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/builder/godlzrAirshipBuilder.java)）和装配（[director](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/builder/godlzrAirshipDirector.java)）\n* 实现了构建和装配的解耦，不同的构建器，相同的装配器，构建不同的对象。相同的构建器，不同的装配器，构建不同的对象。实现了构建算法和装配算法的解耦，有很好的复用性。\n\n# 原型模式 [Prototype](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/prototype)（克隆模式)\n\n* 以某个对象为原型，复制拷贝出新的对象，实现数据的复用。新对象具备原型对象的特点。\n* 优势：效率高\n* 克隆类似于new，但new的对象的属性采用默认值，克隆的对象属性与原型一样。克隆的对象改变不会影响原型。例如，opencv中 mat 的clone(), copyTo().\n* 有[深克隆](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Sheep.java)浅克隆</span>](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Sheep2.java) 之分。 对浅克隆来说，如果对象中的某些属性也是对象，则克隆的对象与原型对象的同一个属性对象在内存中只有一个，该属性对象并没有被复制。如果修改了该属性，则无论是克隆对象和原型对象的该属性都被修改。\n\n``` java\npublic class Sheep implements Cloneable{ \n\n\tprivate String sname;\n\tprivate Date birthday;\n\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\tObject obj = super.clone();//直接调用object的clone方法\n\n\t\t//实现deep clone\n\t\tSheep s = (Sheep)obj;\n\t\ts.birthday = (Date) this.birthday.clone();//把属性也进行克隆\n\t\treturn obj;\n\t}\n}\n```\n\n* 实现深克隆就要把原型对象的所有属性都复制。\n* 深克隆可以利用[序列化和反序列化技术实现](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Client2.java).\n\n```java\npublic static void main(String[] args) throws  IOException, ClassNotFoundException {\n\t\tDate date = new Date(11123123L);\n\t\tSheep2 s1 = new Sheep2(&quot;Dori&quot;, date);\n\n\t\t//使用序列化将对象输出到数据流\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\tObjectOutputStream oos = new ObjectOutputStream(bos);\n\t\toos.writeObject(s1);//输出s1的拷贝\n\t\tbyte[] bytes = bos.toByteArray();\n\n\t\t//使用反序列化将数据流中的对象读入并实现深克隆\n\t\tByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n\t\tObjectInputStream ois = new ObjectInputStream(bis);\n\t\tSheep2 s2 = (Sheep2) ois.readObject();//拷贝给s2\n}\n```\n\n* [使用情景](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Client3.java)：使用new创建对象很耗时间时，利用原型模式拷贝来提高效率。\n* 原型模式一般和工厂模式结合起来\n","source":"_posts/DesignPattern_Creational2.md","raw":"---\ntitle: Design Pattern - Creational 2\nid: 307\ncategories:\n  - Design Pattern\ndate: 2015-08-14 13:57:13\ntags:\n---\n\n# 工厂模式\n\n* 实现创建者和调用者的分离\n* 面向对象的基本设计原则，分工\n\t* OCP(open close principle): 一个软件的实体应当对扩展开发对修改关闭，添加新类来扩展功能\n\t* DIP(dependency Inversion Principle): 针对接口编程，不要针对实现编程\n\tLoD(Law of Demeter): 只与你直接的朋友通信，而避免和陌生人通信\n* 分为 简单工厂模式，工厂方法模式，抽象工厂模式\n\t*   [简单工厂模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/simpleFactory)静态工厂，方法都是静态的， 通过接受不同参数创建不同实例， 增加新的类需要修改已有方法，扩展困难, 实际使用最多。\n\t*   [工厂方法模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/facotryMethod)：避免了简单工厂不满足ocp的缺点，简单工厂只有一个工厂类，而工厂方法模式有一组实现了相同接口的工厂类（一般都用简单工厂模式), 不修改已有类的前提下，增加新的工厂类来实现扩展\n\t*   [抽象工厂模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/abstractFactory)：用来生成不同产品族的全部产品， 工厂方法的升级版，不能增加产品，但能增加产品族。\n\n# [建造者模式](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/builder)\n\n* 对象的组件多，装配顺序复杂\n* 装配的问题，零件之间有一个装配顺序，分离了对象子组件的单独构造（[builder](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/builder/godlzrAirshipBuilder.java)）和装配（[director](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/builder/godlzrAirshipDirector.java)）\n* 实现了构建和装配的解耦，不同的构建器，相同的装配器，构建不同的对象。相同的构建器，不同的装配器，构建不同的对象。实现了构建算法和装配算法的解耦，有很好的复用性。\n\n# 原型模式 [Prototype](https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/prototype)（克隆模式)\n\n* 以某个对象为原型，复制拷贝出新的对象，实现数据的复用。新对象具备原型对象的特点。\n* 优势：效率高\n* 克隆类似于new，但new的对象的属性采用默认值，克隆的对象属性与原型一样。克隆的对象改变不会影响原型。例如，opencv中 mat 的clone(), copyTo().\n* 有[深克隆](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Sheep.java)浅克隆</span>](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Sheep2.java) 之分。 对浅克隆来说，如果对象中的某些属性也是对象，则克隆的对象与原型对象的同一个属性对象在内存中只有一个，该属性对象并没有被复制。如果修改了该属性，则无论是克隆对象和原型对象的该属性都被修改。\n\n``` java\npublic class Sheep implements Cloneable{ \n\n\tprivate String sname;\n\tprivate Date birthday;\n\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\tObject obj = super.clone();//直接调用object的clone方法\n\n\t\t//实现deep clone\n\t\tSheep s = (Sheep)obj;\n\t\ts.birthday = (Date) this.birthday.clone();//把属性也进行克隆\n\t\treturn obj;\n\t}\n}\n```\n\n* 实现深克隆就要把原型对象的所有属性都复制。\n* 深克隆可以利用[序列化和反序列化技术实现](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Client2.java).\n\n```java\npublic static void main(String[] args) throws  IOException, ClassNotFoundException {\n\t\tDate date = new Date(11123123L);\n\t\tSheep2 s1 = new Sheep2(&quot;Dori&quot;, date);\n\n\t\t//使用序列化将对象输出到数据流\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\tObjectOutputStream oos = new ObjectOutputStream(bos);\n\t\toos.writeObject(s1);//输出s1的拷贝\n\t\tbyte[] bytes = bos.toByteArray();\n\n\t\t//使用反序列化将数据流中的对象读入并实现深克隆\n\t\tByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n\t\tObjectInputStream ois = new ObjectInputStream(bis);\n\t\tSheep2 s2 = (Sheep2) ois.readObject();//拷贝给s2\n}\n```\n\n* [使用情景](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Client3.java)：使用new创建对象很耗时间时，利用原型模式拷贝来提高效率。\n* 原型模式一般和工厂模式结合起来\n","slug":"DesignPattern_Creational2","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk170013lkguqx6o5tsf","content":"<h1 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h1><ul>\n<li>实现创建者和调用者的分离</li>\n<li>面向对象的基本设计原则，分工<ul>\n<li>OCP(open close principle): 一个软件的实体应当对扩展开发对修改关闭，添加新类来扩展功能</li>\n<li>DIP(dependency Inversion Principle): 针对接口编程，不要针对实现编程<br>LoD(Law of Demeter): 只与你直接的朋友通信，而避免和陌生人通信</li>\n</ul>\n</li>\n<li>分为 简单工厂模式，工厂方法模式，抽象工厂模式<ul>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/simpleFactory\" target=\"_blank\" rel=\"noopener\">简单工厂模式</a>静态工厂，方法都是静态的， 通过接受不同参数创建不同实例， 增加新的类需要修改已有方法，扩展困难, 实际使用最多。</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/facotryMethod\" target=\"_blank\" rel=\"noopener\">工厂方法模式</a>：避免了简单工厂不满足ocp的缺点，简单工厂只有一个工厂类，而工厂方法模式有一组实现了相同接口的工厂类（一般都用简单工厂模式), 不修改已有类的前提下，增加新的工厂类来实现扩展</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/abstractFactory\" target=\"_blank\" rel=\"noopener\">抽象工厂模式</a>：用来生成不同产品族的全部产品， 工厂方法的升级版，不能增加产品，但能增加产品族。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/builder\" target=\"_blank\" rel=\"noopener\">建造者模式</a></h1><ul>\n<li>对象的组件多，装配顺序复杂</li>\n<li>装配的问题，零件之间有一个装配顺序，分离了对象子组件的单独构造（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/builder/godlzrAirshipBuilder.java\" target=\"_blank\" rel=\"noopener\">builder</a>）和装配（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/builder/godlzrAirshipDirector.java\" target=\"_blank\" rel=\"noopener\">director</a>）</li>\n<li>实现了构建和装配的解耦，不同的构建器，相同的装配器，构建不同的对象。相同的构建器，不同的装配器，构建不同的对象。实现了构建算法和装配算法的解耦，有很好的复用性。</li>\n</ul>\n<h1 id=\"原型模式-Prototype（克隆模式\"><a href=\"#原型模式-Prototype（克隆模式\" class=\"headerlink\" title=\"原型模式 Prototype（克隆模式)\"></a>原型模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/prototype\" target=\"_blank\" rel=\"noopener\">Prototype</a>（克隆模式)</h1><ul>\n<li>以某个对象为原型，复制拷贝出新的对象，实现数据的复用。新对象具备原型对象的特点。</li>\n<li>优势：效率高</li>\n<li>克隆类似于new，但new的对象的属性采用默认值，克隆的对象属性与原型一样。克隆的对象改变不会影响原型。例如，opencv中 mat 的clone(), copyTo().</li>\n<li>有<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Sheep2.java\" target=\"_blank\" rel=\"noopener\">深克隆](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Sheep.java)浅克隆</a> 之分。 对浅克隆来说，如果对象中的某些属性也是对象，则克隆的对象与原型对象的同一个属性对象在内存中只有一个，该属性对象并没有被复制。如果修改了该属性，则无论是克隆对象和原型对象的该属性都被修改。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sheep</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String sname;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Date birthday;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">\t\tObject obj = <span class=\"keyword\">super</span>.clone();<span class=\"comment\">//直接调用object的clone方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//实现deep clone</span></span><br><span class=\"line\">\t\tSheep s = (Sheep)obj;</span><br><span class=\"line\">\t\ts.birthday = (Date) <span class=\"keyword\">this</span>.birthday.clone();<span class=\"comment\">//把属性也进行克隆</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现深克隆就要把原型对象的所有属性都复制。</li>\n<li>深克隆可以利用<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Client2.java\" target=\"_blank\" rel=\"noopener\">序列化和反序列化技术实现</a>.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span>  IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">\t\tDate date = <span class=\"keyword\">new</span> Date(<span class=\"number\">11123123L</span>);</span><br><span class=\"line\">\t\tSheep2 s1 = <span class=\"keyword\">new</span> Sheep2(&amp;quot;Dori&amp;quot;, date);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//使用序列化将对象输出到数据流</span></span><br><span class=\"line\">\t\tByteArrayOutputStream bos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">\t\tObjectOutputStream oos = <span class=\"keyword\">new</span> ObjectOutputStream(bos);</span><br><span class=\"line\">\t\toos.writeObject(s1);<span class=\"comment\">//输出s1的拷贝</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] bytes = bos.toByteArray();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//使用反序列化将数据流中的对象读入并实现深克隆</span></span><br><span class=\"line\">\t\tByteArrayInputStream bis = <span class=\"keyword\">new</span> ByteArrayInputStream(bytes);</span><br><span class=\"line\">\t\tObjectInputStream ois = <span class=\"keyword\">new</span> ObjectInputStream(bis);</span><br><span class=\"line\">\t\tSheep2 s2 = (Sheep2) ois.readObject();<span class=\"comment\">//拷贝给s2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Client3.java\" target=\"_blank\" rel=\"noopener\">使用情景</a>：使用new创建对象很耗时间时，利用原型模式拷贝来提高效率。</li>\n<li>原型模式一般和工厂模式结合起来</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h1><ul>\n<li>实现创建者和调用者的分离</li>\n<li>面向对象的基本设计原则，分工<ul>\n<li>OCP(open close principle): 一个软件的实体应当对扩展开发对修改关闭，添加新类来扩展功能</li>\n<li>DIP(dependency Inversion Principle): 针对接口编程，不要针对实现编程<br>LoD(Law of Demeter): 只与你直接的朋友通信，而避免和陌生人通信</li>\n</ul>\n</li>\n<li>分为 简单工厂模式，工厂方法模式，抽象工厂模式<ul>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/simpleFactory\" target=\"_blank\" rel=\"noopener\">简单工厂模式</a>静态工厂，方法都是静态的， 通过接受不同参数创建不同实例， 增加新的类需要修改已有方法，扩展困难, 实际使用最多。</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/facotryMethod\" target=\"_blank\" rel=\"noopener\">工厂方法模式</a>：避免了简单工厂不满足ocp的缺点，简单工厂只有一个工厂类，而工厂方法模式有一组实现了相同接口的工厂类（一般都用简单工厂模式), 不修改已有类的前提下，增加新的工厂类来实现扩展</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/factory/abstractFactory\" target=\"_blank\" rel=\"noopener\">抽象工厂模式</a>：用来生成不同产品族的全部产品， 工厂方法的升级版，不能增加产品，但能增加产品族。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/builder\" target=\"_blank\" rel=\"noopener\">建造者模式</a></h1><ul>\n<li>对象的组件多，装配顺序复杂</li>\n<li>装配的问题，零件之间有一个装配顺序，分离了对象子组件的单独构造（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/builder/godlzrAirshipBuilder.java\" target=\"_blank\" rel=\"noopener\">builder</a>）和装配（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/builder/godlzrAirshipDirector.java\" target=\"_blank\" rel=\"noopener\">director</a>）</li>\n<li>实现了构建和装配的解耦，不同的构建器，相同的装配器，构建不同的对象。相同的构建器，不同的装配器，构建不同的对象。实现了构建算法和装配算法的解耦，有很好的复用性。</li>\n</ul>\n<h1 id=\"原型模式-Prototype（克隆模式\"><a href=\"#原型模式-Prototype（克隆模式\" class=\"headerlink\" title=\"原型模式 Prototype（克隆模式)\"></a>原型模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/src/com/godlzr/GOF23/prototype\" target=\"_blank\" rel=\"noopener\">Prototype</a>（克隆模式)</h1><ul>\n<li>以某个对象为原型，复制拷贝出新的对象，实现数据的复用。新对象具备原型对象的特点。</li>\n<li>优势：效率高</li>\n<li>克隆类似于new，但new的对象的属性采用默认值，克隆的对象属性与原型一样。克隆的对象改变不会影响原型。例如，opencv中 mat 的clone(), copyTo().</li>\n<li>有<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Sheep2.java\" target=\"_blank\" rel=\"noopener\">深克隆](https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Sheep.java)浅克隆</a> 之分。 对浅克隆来说，如果对象中的某些属性也是对象，则克隆的对象与原型对象的同一个属性对象在内存中只有一个，该属性对象并没有被复制。如果修改了该属性，则无论是克隆对象和原型对象的该属性都被修改。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sheep</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String sname;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Date birthday;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">\t\tObject obj = <span class=\"keyword\">super</span>.clone();<span class=\"comment\">//直接调用object的clone方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//实现deep clone</span></span><br><span class=\"line\">\t\tSheep s = (Sheep)obj;</span><br><span class=\"line\">\t\ts.birthday = (Date) <span class=\"keyword\">this</span>.birthday.clone();<span class=\"comment\">//把属性也进行克隆</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实现深克隆就要把原型对象的所有属性都复制。</li>\n<li>深克隆可以利用<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Client2.java\" target=\"_blank\" rel=\"noopener\">序列化和反序列化技术实现</a>.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span>  IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">\t\tDate date = <span class=\"keyword\">new</span> Date(<span class=\"number\">11123123L</span>);</span><br><span class=\"line\">\t\tSheep2 s1 = <span class=\"keyword\">new</span> Sheep2(&amp;quot;Dori&amp;quot;, date);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//使用序列化将对象输出到数据流</span></span><br><span class=\"line\">\t\tByteArrayOutputStream bos = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">\t\tObjectOutputStream oos = <span class=\"keyword\">new</span> ObjectOutputStream(bos);</span><br><span class=\"line\">\t\toos.writeObject(s1);<span class=\"comment\">//输出s1的拷贝</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] bytes = bos.toByteArray();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//使用反序列化将数据流中的对象读入并实现深克隆</span></span><br><span class=\"line\">\t\tByteArrayInputStream bis = <span class=\"keyword\">new</span> ByteArrayInputStream(bytes);</span><br><span class=\"line\">\t\tObjectInputStream ois = <span class=\"keyword\">new</span> ObjectInputStream(bis);</span><br><span class=\"line\">\t\tSheep2 s2 = (Sheep2) ois.readObject();<span class=\"comment\">//拷贝给s2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/src/com/godlzr/GOF23/prototype/Client3.java\" target=\"_blank\" rel=\"noopener\">使用情景</a>：使用new创建对象很耗时间时，利用原型模式拷贝来提高效率。</li>\n<li>原型模式一般和工厂模式结合起来</li>\n</ul>\n"},{"title":"Design Pattern - Structural 2","id":"333","date":"2015-08-17T23:17:57.000Z","_content":"\n# 桥接模式 [Bridge](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/bridge)\n\n* 多层继承结构 扩展性问题，类个数膨胀问题，违反单一职责原则\n* 处理多层继承 结构，处理 多维度变化场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关系。\n\n\t[![](https://upload.wikimedia.org/wikipedia/commons/c/cf/Bridge_UML_class_diagram.svg)](https://en.wikipedia.org/wiki/File:Bridge_UML_class_diagram.svg)\n\n# 装饰模式 [Decorator](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/decorator)\n\n* 动态的为一个对象增加新的功能降低系统耦合度，具体类和装饰类可以独立变换。\n* 装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。\n* 使用对象的关联关系代替继承关系更加灵活，避免类型体系的快速膨胀。\n* Component抽象构件\n\t*   ConcreteComponent具体构件（真实对象）\n\t*   Decorator装饰器\n\t*   ConcreteDecorator具体装饰器\n* 也可称为Wrapper\n* 缺点：产生很多小对象，易出错，调试麻烦\n\n\t![](https://upload.wikimedia.org/wikipedia/commons/e/e9/Decorator_UML_class_diagram.svg)\n\n# 组合模式 [Composite](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/composite)\n\n* 组合（A类中定义B类的对象b属性）与组合模式不同。\n* 把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。\n* 组合模式核心：\n\t*   Component抽象构件角色：定义了叶子和容器构件的共同点\n\t*   Leaf叶子构件角色：无子节点\n\t*   Composite容器构件角色：有容器特征，可以包含子节点\n* 场景：资源管理器，GUI容器层次，XML文件解析，组织结构处理，Junit单元测试框架\n\n\t![](https://upload.wikimedia.org/wikipedia/commons/5/5a/Composite_UML_class_diagram_%28fixed%29.svg)","source":"_posts/DesignPattern_Structural2.md","raw":"---\ntitle: Design Pattern - Structural 2\nid: 333\ncategories:\n  - Design Pattern\ndate: 2015-08-17 19:17:57\ntags:\n---\n\n# 桥接模式 [Bridge](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/bridge)\n\n* 多层继承结构 扩展性问题，类个数膨胀问题，违反单一职责原则\n* 处理多层继承 结构，处理 多维度变化场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关系。\n\n\t[![](https://upload.wikimedia.org/wikipedia/commons/c/cf/Bridge_UML_class_diagram.svg)](https://en.wikipedia.org/wiki/File:Bridge_UML_class_diagram.svg)\n\n# 装饰模式 [Decorator](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/decorator)\n\n* 动态的为一个对象增加新的功能降低系统耦合度，具体类和装饰类可以独立变换。\n* 装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。\n* 使用对象的关联关系代替继承关系更加灵活，避免类型体系的快速膨胀。\n* Component抽象构件\n\t*   ConcreteComponent具体构件（真实对象）\n\t*   Decorator装饰器\n\t*   ConcreteDecorator具体装饰器\n* 也可称为Wrapper\n* 缺点：产生很多小对象，易出错，调试麻烦\n\n\t![](https://upload.wikimedia.org/wikipedia/commons/e/e9/Decorator_UML_class_diagram.svg)\n\n# 组合模式 [Composite](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/composite)\n\n* 组合（A类中定义B类的对象b属性）与组合模式不同。\n* 把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。\n* 组合模式核心：\n\t*   Component抽象构件角色：定义了叶子和容器构件的共同点\n\t*   Leaf叶子构件角色：无子节点\n\t*   Composite容器构件角色：有容器特征，可以包含子节点\n* 场景：资源管理器，GUI容器层次，XML文件解析，组织结构处理，Junit单元测试框架\n\n\t![](https://upload.wikimedia.org/wikipedia/commons/5/5a/Composite_UML_class_diagram_%28fixed%29.svg)","slug":"DesignPattern_Structural2","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk170017lkgu9ftusx2f","content":"<h1 id=\"桥接模式-Bridge\"><a href=\"#桥接模式-Bridge\" class=\"headerlink\" title=\"桥接模式 Bridge\"></a>桥接模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/bridge\" target=\"_blank\" rel=\"noopener\">Bridge</a></h1><ul>\n<li>多层继承结构 扩展性问题，类个数膨胀问题，违反单一职责原则</li>\n<li><p>处理多层继承 结构，处理 多维度变化场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关系。</p>\n<p>  <a href=\"https://en.wikipedia.org/wiki/File:Bridge_UML_class_diagram.svg\" target=\"_blank\" rel=\"noopener\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/c/cf/Bridge_UML_class_diagram.svg\" alt=\"\"></a></p>\n</li>\n</ul>\n<h1 id=\"装饰模式-Decorator\"><a href=\"#装饰模式-Decorator\" class=\"headerlink\" title=\"装饰模式 Decorator\"></a>装饰模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/decorator\" target=\"_blank\" rel=\"noopener\">Decorator</a></h1><ul>\n<li>动态的为一个对象增加新的功能降低系统耦合度，具体类和装饰类可以独立变换。</li>\n<li>装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。</li>\n<li>使用对象的关联关系代替继承关系更加灵活，避免类型体系的快速膨胀。</li>\n<li>Component抽象构件<ul>\n<li>ConcreteComponent具体构件（真实对象）</li>\n<li>Decorator装饰器</li>\n<li>ConcreteDecorator具体装饰器</li>\n</ul>\n</li>\n<li>也可称为Wrapper</li>\n<li><p>缺点：产生很多小对象，易出错，调试麻烦</p>\n<p>  <img src=\"https://upload.wikimedia.org/wikipedia/commons/e/e9/Decorator_UML_class_diagram.svg\" alt=\"\"></p>\n</li>\n</ul>\n<h1 id=\"组合模式-Composite\"><a href=\"#组合模式-Composite\" class=\"headerlink\" title=\"组合模式 Composite\"></a>组合模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/composite\" target=\"_blank\" rel=\"noopener\">Composite</a></h1><ul>\n<li>组合（A类中定义B类的对象b属性）与组合模式不同。</li>\n<li>把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。</li>\n<li>组合模式核心：<ul>\n<li>Component抽象构件角色：定义了叶子和容器构件的共同点</li>\n<li>Leaf叶子构件角色：无子节点</li>\n<li>Composite容器构件角色：有容器特征，可以包含子节点</li>\n</ul>\n</li>\n<li><p>场景：资源管理器，GUI容器层次，XML文件解析，组织结构处理，Junit单元测试框架</p>\n<p>  <img src=\"https://upload.wikimedia.org/wikipedia/commons/5/5a/Composite_UML_class_diagram_%28fixed%29.svg\" alt=\"\"></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"桥接模式-Bridge\"><a href=\"#桥接模式-Bridge\" class=\"headerlink\" title=\"桥接模式 Bridge\"></a>桥接模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/bridge\" target=\"_blank\" rel=\"noopener\">Bridge</a></h1><ul>\n<li>多层继承结构 扩展性问题，类个数膨胀问题，违反单一职责原则</li>\n<li><p>处理多层继承 结构，处理 多维度变化场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关系。</p>\n<p>  <a href=\"https://en.wikipedia.org/wiki/File:Bridge_UML_class_diagram.svg\" target=\"_blank\" rel=\"noopener\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/c/cf/Bridge_UML_class_diagram.svg\" alt=\"\"></a></p>\n</li>\n</ul>\n<h1 id=\"装饰模式-Decorator\"><a href=\"#装饰模式-Decorator\" class=\"headerlink\" title=\"装饰模式 Decorator\"></a>装饰模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/decorator\" target=\"_blank\" rel=\"noopener\">Decorator</a></h1><ul>\n<li>动态的为一个对象增加新的功能降低系统耦合度，具体类和装饰类可以独立变换。</li>\n<li>装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。</li>\n<li>使用对象的关联关系代替继承关系更加灵活，避免类型体系的快速膨胀。</li>\n<li>Component抽象构件<ul>\n<li>ConcreteComponent具体构件（真实对象）</li>\n<li>Decorator装饰器</li>\n<li>ConcreteDecorator具体装饰器</li>\n</ul>\n</li>\n<li>也可称为Wrapper</li>\n<li><p>缺点：产生很多小对象，易出错，调试麻烦</p>\n<p>  <img src=\"https://upload.wikimedia.org/wikipedia/commons/e/e9/Decorator_UML_class_diagram.svg\" alt=\"\"></p>\n</li>\n</ul>\n<h1 id=\"组合模式-Composite\"><a href=\"#组合模式-Composite\" class=\"headerlink\" title=\"组合模式 Composite\"></a>组合模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/composite\" target=\"_blank\" rel=\"noopener\">Composite</a></h1><ul>\n<li>组合（A类中定义B类的对象b属性）与组合模式不同。</li>\n<li>把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。</li>\n<li>组合模式核心：<ul>\n<li>Component抽象构件角色：定义了叶子和容器构件的共同点</li>\n<li>Leaf叶子构件角色：无子节点</li>\n<li>Composite容器构件角色：有容器特征，可以包含子节点</li>\n</ul>\n</li>\n<li><p>场景：资源管理器，GUI容器层次，XML文件解析，组织结构处理，Junit单元测试框架</p>\n<p>  <img src=\"https://upload.wikimedia.org/wikipedia/commons/5/5a/Composite_UML_class_diagram_%28fixed%29.svg\" alt=\"\"></p>\n</li>\n</ul>\n"},{"title":"Design Pattern - Structural","id":"329","date":"2015-08-17T01:04:56.000Z","_content":"\n# 结构型模式\n*   核心作用：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题\n*   分类：适配器模式，代理模式，桥接模式，装饰模式，组合模式，外观模式，享元模式。\n\n\n1.[适配器模式 Adapter](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/adapter)\n\n* 将一个类的接口转成希望的另一个接口，使得原来接口不兼容的类可以一起工作.\n* 模型中的角色\n\t* 目标接口（[Target](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Target.java)）：期待的接口，目标可以是具体的或抽象的类，也可以是接口。\n\t* 需要适配的类（[Adaptee](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adaptee.java)）：需要适配的类或者适配者类\n\t* 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口\n\t* 两种方式：[类继承](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adapter.java)，或者[类组合](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adapter2.java)的方式.\n\t* 场景：旧系统改造和升级\n\n2.代理模式 Proxy Pattern\n\n* 通过代理，控制对对象的访问。可以详细控制访问某个对象的方法，在调用这个方法前做前置处理，后做后置处理，从而将统一流程代码放到代理类中处理。\nAOP Aspect Oriented Programming面向切面编程的核心实现机制。\n\n* 核心角色：\n\t*  抽象角色：定义代理角色和真实角色的公开对外方法\n\t*  真实角色：实现抽象角色，真正的业务逻辑，定义真实角色所需要实现的业务逻辑，供代理角色调用\n\t*  代理角色：实现抽象角色， 统一的控制流程在代理角色中处理，是真实角色的代理通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。\n\t 应用：安全代理，远程代理，延迟加载 \n\n* 分类：\n\t* [静态代理static](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/staticProxy)\n\t* [自己定义代理类](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/staticProxy/ProxySinger.java)\n\t* [动态代理dynamic](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/dynamicProxy)（由程序生成代理类）动态代理:动态生成代理类，灵活统一 \n\n* JDK自带的动态代理 \n\n* java.lang.reflect.Proxy \n\n* java.lang.reflect.[InvocationHandler(](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/dynamicProxy/SingerHandler.java)处理器接口) javaassist字节码操作库实现 \n\n* CGLIB\n\n* ASM（底层使用指令，可维护性差）","source":"_posts/DesignPattern_Structural.md","raw":"---\ntitle: Design Pattern - Structural\nid: 329\ncategories:\n  - Design Patterns\ndate: 2015-08-16 21:04:56\ntags:\n---\n\n# 结构型模式\n*   核心作用：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题\n*   分类：适配器模式，代理模式，桥接模式，装饰模式，组合模式，外观模式，享元模式。\n\n\n1.[适配器模式 Adapter](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/adapter)\n\n* 将一个类的接口转成希望的另一个接口，使得原来接口不兼容的类可以一起工作.\n* 模型中的角色\n\t* 目标接口（[Target](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Target.java)）：期待的接口，目标可以是具体的或抽象的类，也可以是接口。\n\t* 需要适配的类（[Adaptee](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adaptee.java)）：需要适配的类或者适配者类\n\t* 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口\n\t* 两种方式：[类继承](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adapter.java)，或者[类组合](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adapter2.java)的方式.\n\t* 场景：旧系统改造和升级\n\n2.代理模式 Proxy Pattern\n\n* 通过代理，控制对对象的访问。可以详细控制访问某个对象的方法，在调用这个方法前做前置处理，后做后置处理，从而将统一流程代码放到代理类中处理。\nAOP Aspect Oriented Programming面向切面编程的核心实现机制。\n\n* 核心角色：\n\t*  抽象角色：定义代理角色和真实角色的公开对外方法\n\t*  真实角色：实现抽象角色，真正的业务逻辑，定义真实角色所需要实现的业务逻辑，供代理角色调用\n\t*  代理角色：实现抽象角色， 统一的控制流程在代理角色中处理，是真实角色的代理通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。\n\t 应用：安全代理，远程代理，延迟加载 \n\n* 分类：\n\t* [静态代理static](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/staticProxy)\n\t* [自己定义代理类](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/staticProxy/ProxySinger.java)\n\t* [动态代理dynamic](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/dynamicProxy)（由程序生成代理类）动态代理:动态生成代理类，灵活统一 \n\n* JDK自带的动态代理 \n\n* java.lang.reflect.Proxy \n\n* java.lang.reflect.[InvocationHandler(](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/dynamicProxy/SingerHandler.java)处理器接口) javaassist字节码操作库实现 \n\n* CGLIB\n\n* ASM（底层使用指令，可维护性差）","slug":"DesignPattern_Structural","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk180018lkguonrkhrkr","content":"<h1 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h1><ul>\n<li>核心作用：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题</li>\n<li>分类：适配器模式，代理模式，桥接模式，装饰模式，组合模式，外观模式，享元模式。</li>\n</ul>\n<p>1.<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/adapter\" target=\"_blank\" rel=\"noopener\">适配器模式 Adapter</a></p>\n<ul>\n<li>将一个类的接口转成希望的另一个接口，使得原来接口不兼容的类可以一起工作.</li>\n<li>模型中的角色<ul>\n<li>目标接口（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Target.java\" target=\"_blank\" rel=\"noopener\">Target</a>）：期待的接口，目标可以是具体的或抽象的类，也可以是接口。</li>\n<li>需要适配的类（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adaptee.java\" target=\"_blank\" rel=\"noopener\">Adaptee</a>）：需要适配的类或者适配者类</li>\n<li>适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口</li>\n<li>两种方式：<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adapter.java\" target=\"_blank\" rel=\"noopener\">类继承</a>，或者<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adapter2.java\" target=\"_blank\" rel=\"noopener\">类组合</a>的方式.</li>\n<li>场景：旧系统改造和升级</li>\n</ul>\n</li>\n</ul>\n<p>2.代理模式 Proxy Pattern</p>\n<ul>\n<li><p>通过代理，控制对对象的访问。可以详细控制访问某个对象的方法，在调用这个方法前做前置处理，后做后置处理，从而将统一流程代码放到代理类中处理。<br>AOP Aspect Oriented Programming面向切面编程的核心实现机制。</p>\n</li>\n<li><p>核心角色：</p>\n<ul>\n<li>抽象角色：定义代理角色和真实角色的公开对外方法</li>\n<li>真实角色：实现抽象角色，真正的业务逻辑，定义真实角色所需要实现的业务逻辑，供代理角色调用</li>\n<li>代理角色：实现抽象角色， 统一的控制流程在代理角色中处理，是真实角色的代理通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。<br>应用：安全代理，远程代理，延迟加载 </li>\n</ul>\n</li>\n<li><p>分类：</p>\n<ul>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/staticProxy\" target=\"_blank\" rel=\"noopener\">静态代理static</a></li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/staticProxy/ProxySinger.java\" target=\"_blank\" rel=\"noopener\">自己定义代理类</a></li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/dynamicProxy\" target=\"_blank\" rel=\"noopener\">动态代理dynamic</a>（由程序生成代理类）动态代理:动态生成代理类，灵活统一 </li>\n</ul>\n</li>\n<li><p>JDK自带的动态代理 </p>\n</li>\n<li><p>java.lang.reflect.Proxy </p>\n</li>\n<li><p>java.lang.reflect.<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/dynamicProxy/SingerHandler.java\" target=\"_blank\" rel=\"noopener\">InvocationHandler(</a>处理器接口) javaassist字节码操作库实现 </p>\n</li>\n<li><p>CGLIB</p>\n</li>\n<li><p>ASM（底层使用指令，可维护性差）</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h1><ul>\n<li>核心作用：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题</li>\n<li>分类：适配器模式，代理模式，桥接模式，装饰模式，组合模式，外观模式，享元模式。</li>\n</ul>\n<p>1.<a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/adapter\" target=\"_blank\" rel=\"noopener\">适配器模式 Adapter</a></p>\n<ul>\n<li>将一个类的接口转成希望的另一个接口，使得原来接口不兼容的类可以一起工作.</li>\n<li>模型中的角色<ul>\n<li>目标接口（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Target.java\" target=\"_blank\" rel=\"noopener\">Target</a>）：期待的接口，目标可以是具体的或抽象的类，也可以是接口。</li>\n<li>需要适配的类（<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adaptee.java\" target=\"_blank\" rel=\"noopener\">Adaptee</a>）：需要适配的类或者适配者类</li>\n<li>适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口</li>\n<li>两种方式：<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adapter.java\" target=\"_blank\" rel=\"noopener\">类继承</a>，或者<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/adapter/Adapter2.java\" target=\"_blank\" rel=\"noopener\">类组合</a>的方式.</li>\n<li>场景：旧系统改造和升级</li>\n</ul>\n</li>\n</ul>\n<p>2.代理模式 Proxy Pattern</p>\n<ul>\n<li><p>通过代理，控制对对象的访问。可以详细控制访问某个对象的方法，在调用这个方法前做前置处理，后做后置处理，从而将统一流程代码放到代理类中处理。<br>AOP Aspect Oriented Programming面向切面编程的核心实现机制。</p>\n</li>\n<li><p>核心角色：</p>\n<ul>\n<li>抽象角色：定义代理角色和真实角色的公开对外方法</li>\n<li>真实角色：实现抽象角色，真正的业务逻辑，定义真实角色所需要实现的业务逻辑，供代理角色调用</li>\n<li>代理角色：实现抽象角色， 统一的控制流程在代理角色中处理，是真实角色的代理通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。<br>应用：安全代理，远程代理，延迟加载 </li>\n</ul>\n</li>\n<li><p>分类：</p>\n<ul>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/staticProxy\" target=\"_blank\" rel=\"noopener\">静态代理static</a></li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/staticProxy/ProxySinger.java\" target=\"_blank\" rel=\"noopener\">自己定义代理类</a></li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/dynamicProxy\" target=\"_blank\" rel=\"noopener\">动态代理dynamic</a>（由程序生成代理类）动态代理:动态生成代理类，灵活统一 </li>\n</ul>\n</li>\n<li><p>JDK自带的动态代理 </p>\n</li>\n<li><p>java.lang.reflect.Proxy </p>\n</li>\n<li><p>java.lang.reflect.<a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/dynamicProxy/SingerHandler.java\" target=\"_blank\" rel=\"noopener\">InvocationHandler(</a>处理器接口) javaassist字节码操作库实现 </p>\n</li>\n<li><p>CGLIB</p>\n</li>\n<li><p>ASM（底层使用指令，可维护性差）</p>\n</li>\n</ul>\n"},{"title":"Design Pattern - Structural 3","id":"340","date":"2015-08-17T23:23:33.000Z","_content":"\n# 外观模式 [Facade](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/facade)\n\n* 迪米特法则：（最少知识原则）一个软件实体应当尽可能少的与其他实体发生相互作用。\n* 为子系统提供一个入口，封装子系统的复习性，便于客户端使用。最简单的设计模式。\n* 使用频率很高。\n\n\t![](https://upload.wikimedia.org/wikipedia/en/5/57/Example_of_Facade_design_pattern_in_UML.png)\n\n# 享元模式 [FlyWeight](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/flyweight)（轻量级）\n\n* 如果存在很多完全相同或相似的对象，我们可以通过享元模式，节省内存\n\n* 以共享的方式高效的支持大量细粒度对象的重用。\n\n* 区分了内部状态和外部状态：\n\n\t*   内部状态：可以共享，不会随环境的变化而改变。\n\t*   外部状体：不可以共享，会随环境变化而改变。\n\n\t例如围棋软件中的棋子对象有属性：颜色，形状，大小（内部状态，不会改变都一样，可以恭喜那个）位置（外部状态，不同，不可共享）\n*   [FlyweightFactory](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeightFactory.java): 享元工厂类，创建并管理享元对象，享元池一般设计成键对值\n*   [Flyweight](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeight.java)：抽象享元类，通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。\n*   [ConcreteFlyWeight](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeight.java)：具体的享元类，为内部状态提供成员变量进行存储\n*   [UnsharedConcreteFlyweight](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/Coordinate.java)：非共享享元类，不能被共享的子类可以设计外部状态\n\n* 应用场景主要是线程池，数据连接池\n\n* 优点：\n\n\t*   极大减少内存的对象数量\n\t*   相同相似的对象内存中只存一份，极大结缘资源，提高系统性能\n\t*   外部状态相对独立，不影响内部状态\n\n* 缺点：\n\n\t*   模式复杂，使程序逻辑复杂化\n\t*   节省内存，共享内部状态，分离出外部状态，而读取外部状态是运行时间变长，时间换空间。\n\t![](http://www.dofactory.com/images/diagrams/net/flyweight.gif)","source":"_posts/DesignPattern_Structural3.md","raw":"---\ntitle: Design Pattern - Structural 3\nid: 340\ncategories:\n  - Design Pattern\ndate: 2015-08-17 19:23:33\ntags:\n---\n\n# 外观模式 [Facade](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/facade)\n\n* 迪米特法则：（最少知识原则）一个软件实体应当尽可能少的与其他实体发生相互作用。\n* 为子系统提供一个入口，封装子系统的复习性，便于客户端使用。最简单的设计模式。\n* 使用频率很高。\n\n\t![](https://upload.wikimedia.org/wikipedia/en/5/57/Example_of_Facade_design_pattern_in_UML.png)\n\n# 享元模式 [FlyWeight](https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/flyweight)（轻量级）\n\n* 如果存在很多完全相同或相似的对象，我们可以通过享元模式，节省内存\n\n* 以共享的方式高效的支持大量细粒度对象的重用。\n\n* 区分了内部状态和外部状态：\n\n\t*   内部状态：可以共享，不会随环境的变化而改变。\n\t*   外部状体：不可以共享，会随环境变化而改变。\n\n\t例如围棋软件中的棋子对象有属性：颜色，形状，大小（内部状态，不会改变都一样，可以恭喜那个）位置（外部状态，不同，不可共享）\n*   [FlyweightFactory](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeightFactory.java): 享元工厂类，创建并管理享元对象，享元池一般设计成键对值\n*   [Flyweight](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeight.java)：抽象享元类，通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。\n*   [ConcreteFlyWeight](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeight.java)：具体的享元类，为内部状态提供成员变量进行存储\n*   [UnsharedConcreteFlyweight](https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/Coordinate.java)：非共享享元类，不能被共享的子类可以设计外部状态\n\n* 应用场景主要是线程池，数据连接池\n\n* 优点：\n\n\t*   极大减少内存的对象数量\n\t*   相同相似的对象内存中只存一份，极大结缘资源，提高系统性能\n\t*   外部状态相对独立，不影响内部状态\n\n* 缺点：\n\n\t*   模式复杂，使程序逻辑复杂化\n\t*   节省内存，共享内部状态，分离出外部状态，而读取外部状态是运行时间变长，时间换空间。\n\t![](http://www.dofactory.com/images/diagrams/net/flyweight.gif)","slug":"DesignPattern_Structural3","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk19001alkgurejooph9","content":"<h1 id=\"外观模式-Facade\"><a href=\"#外观模式-Facade\" class=\"headerlink\" title=\"外观模式 Facade\"></a>外观模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/facade\" target=\"_blank\" rel=\"noopener\">Facade</a></h1><ul>\n<li>迪米特法则：（最少知识原则）一个软件实体应当尽可能少的与其他实体发生相互作用。</li>\n<li>为子系统提供一个入口，封装子系统的复习性，便于客户端使用。最简单的设计模式。</li>\n<li><p>使用频率很高。</p>\n<p>  <img src=\"https://upload.wikimedia.org/wikipedia/en/5/57/Example_of_Facade_design_pattern_in_UML.png\" alt=\"\"></p>\n</li>\n</ul>\n<h1 id=\"享元模式-FlyWeight（轻量级）\"><a href=\"#享元模式-FlyWeight（轻量级）\" class=\"headerlink\" title=\"享元模式 FlyWeight（轻量级）\"></a>享元模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/flyweight\" target=\"_blank\" rel=\"noopener\">FlyWeight</a>（轻量级）</h1><ul>\n<li><p>如果存在很多完全相同或相似的对象，我们可以通过享元模式，节省内存</p>\n</li>\n<li><p>以共享的方式高效的支持大量细粒度对象的重用。</p>\n</li>\n<li><p>区分了内部状态和外部状态：</p>\n<ul>\n<li>内部状态：可以共享，不会随环境的变化而改变。</li>\n<li><p>外部状体：不可以共享，会随环境变化而改变。</p>\n<p>例如围棋软件中的棋子对象有属性：颜色，形状，大小（内部状态，不会改变都一样，可以恭喜那个）位置（外部状态，不同，不可共享）</p>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeightFactory.java\" target=\"_blank\" rel=\"noopener\">FlyweightFactory</a>: 享元工厂类，创建并管理享元对象，享元池一般设计成键对值</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeight.java\" target=\"_blank\" rel=\"noopener\">Flyweight</a>：抽象享元类，通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeight.java\" target=\"_blank\" rel=\"noopener\">ConcreteFlyWeight</a>：具体的享元类，为内部状态提供成员变量进行存储</li>\n<li><p><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/Coordinate.java\" target=\"_blank\" rel=\"noopener\">UnsharedConcreteFlyweight</a>：非共享享元类，不能被共享的子类可以设计外部状态</p>\n</li>\n<li><p>应用场景主要是线程池，数据连接池</p>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>极大减少内存的对象数量</li>\n<li>相同相似的对象内存中只存一份，极大结缘资源，提高系统性能</li>\n<li>外部状态相对独立，不影响内部状态</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>模式复杂，使程序逻辑复杂化</li>\n<li>节省内存，共享内部状态，分离出外部状态，而读取外部状态是运行时间变长，时间换空间。<br><img src=\"http://www.dofactory.com/images/diagrams/net/flyweight.gif\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"外观模式-Facade\"><a href=\"#外观模式-Facade\" class=\"headerlink\" title=\"外观模式 Facade\"></a>外观模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/facade\" target=\"_blank\" rel=\"noopener\">Facade</a></h1><ul>\n<li>迪米特法则：（最少知识原则）一个软件实体应当尽可能少的与其他实体发生相互作用。</li>\n<li>为子系统提供一个入口，封装子系统的复习性，便于客户端使用。最简单的设计模式。</li>\n<li><p>使用频率很高。</p>\n<p>  <img src=\"https://upload.wikimedia.org/wikipedia/en/5/57/Example_of_Facade_design_pattern_in_UML.png\" alt=\"\"></p>\n</li>\n</ul>\n<h1 id=\"享元模式-FlyWeight（轻量级）\"><a href=\"#享元模式-FlyWeight（轻量级）\" class=\"headerlink\" title=\"享元模式 FlyWeight（轻量级）\"></a>享元模式 <a href=\"https://github.com/godlzr/GOF23_DesignPattern/tree/master/com.godlzr.GOF23.structural/flyweight\" target=\"_blank\" rel=\"noopener\">FlyWeight</a>（轻量级）</h1><ul>\n<li><p>如果存在很多完全相同或相似的对象，我们可以通过享元模式，节省内存</p>\n</li>\n<li><p>以共享的方式高效的支持大量细粒度对象的重用。</p>\n</li>\n<li><p>区分了内部状态和外部状态：</p>\n<ul>\n<li>内部状态：可以共享，不会随环境的变化而改变。</li>\n<li><p>外部状体：不可以共享，会随环境变化而改变。</p>\n<p>例如围棋软件中的棋子对象有属性：颜色，形状，大小（内部状态，不会改变都一样，可以恭喜那个）位置（外部状态，不同，不可共享）</p>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeightFactory.java\" target=\"_blank\" rel=\"noopener\">FlyweightFactory</a>: 享元工厂类，创建并管理享元对象，享元池一般设计成键对值</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeight.java\" target=\"_blank\" rel=\"noopener\">Flyweight</a>：抽象享元类，通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。</li>\n<li><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/ChessFlyWeight.java\" target=\"_blank\" rel=\"noopener\">ConcreteFlyWeight</a>：具体的享元类，为内部状态提供成员变量进行存储</li>\n<li><p><a href=\"https://github.com/godlzr/GOF23_DesignPattern/blob/master/com.godlzr.GOF23.structural/flyweight/Coordinate.java\" target=\"_blank\" rel=\"noopener\">UnsharedConcreteFlyweight</a>：非共享享元类，不能被共享的子类可以设计外部状态</p>\n</li>\n<li><p>应用场景主要是线程池，数据连接池</p>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>极大减少内存的对象数量</li>\n<li>相同相似的对象内存中只存一份，极大结缘资源，提高系统性能</li>\n<li>外部状态相对独立，不影响内部状态</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>模式复杂，使程序逻辑复杂化</li>\n<li>节省内存，共享内部状态，分离出外部状态，而读取外部状态是运行时间变长，时间换空间。<br><img src=\"http://www.dofactory.com/images/diagrams/net/flyweight.gif\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n"},{"title":"Eegeo","id":"509","date":"2017-02-08T04:20:06.000Z","_content":"","source":"_posts/Eegeo.md","raw":"---\ntitle: Eegeo\nid: 509\ncategories:\n  - Computer Graphics\ndate: 2017-02-07 23:20:06\ntags:\n---","slug":"Eegeo","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk19001clkgug144uxjd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"GNU Toolchain","id":"170","date":"2015-07-24T01:23:10.000Z","_content":"\nGNU toolchain is a free C/C++ programming toolchain, it is an important part during the improvement of Linux system. Most of CPU manufacturers support the GNU compiler toolchain include the native- compile toolchain and cross-compile toolchain, that also makes the GNU toolchain become the most popular toolchain of embedded software development. It supports wide range of CPU architecture, such as x86, IA-32, MIPS,tile, PowerPC, Spark etc.\n\nIn common, GNU toolchain consists of these parts:\n\n1.  GUN C Library.\n2.  GNU Compiler Collection(GCC).\n3.  Binutils(GNU Binary Utilities), includes objdump, readelf, strip, ar, nm, ldd, ngprof, gcov etc.\n4.  GNU Remote Debugger(GDB).\n5.  GNU make\n6.  kernel debugger (KGDB).\n\nGenerally, GNU toolchain also includes:\n\t1. GNU code editor (vi, emacs, vim etc.\n\t2. GNU automake tool, in order to improve the portability of the code。\n\n[翻译]\nGNU编译工具链是一个“免费”的C/C++工具链，有力的支撑了Linux系统的发展。众多的处理器厂家都提供了对GNU编译工具链的支持（本地编译工具链（native-compile toolchain）、交叉编译（cross-compile toolchain）），这也使得其成为了嵌入式软件开发中最流行的工具集。其支持的体系结构非常广泛，其中包括：X86, IA-32, MIPS, tile, PowerPC, Spark etc.\n\n通常来讲，我们认为GNU工具链主要由以下几个大的单元构成：\n\n1.  GNU C Library，也就是通常所说的glibc，另外在嵌入式领域，往往采用glibc兼容的uclibc、newlib等。glibc是由GNU项目提供的标准C运行库，它针对PC应用设计，较庞大，但能提供最优的兼容性。如果一般的嵌入式开发可选用uClibc。uClibc原本是uCLinux开发过程中的一个C语言库，现已经独立于uCLinux项目并且进一步完善。它对glibc的大部分函数进行了重写，并且目标就定位于嵌入式，所以其相对glibc而言要小巧很多。此外由于它的函数与glibc保持一致，这样很多原本基于glibc开发的软件基本无需改动便可改用uClibc编译运行，使得在嵌入式系统上占用的内存和磁盘空间更少。但由于毕竟不是标准的C运行库，因此uClibc拥有着一定的兼容性问题。 Newlib是一个面向嵌入式系统的C运行库.最初是由Solutions收集组装的一个源代码集合,取名为newlib, 现在由Red Hat维护,对于与GNU兼容的嵌入式C运行库,Newlib并不是唯一的选择,但是从成熟度来讲,newlib是最优秀的.newlib具有独特的体系结构,使得它能够非常好地满足深度嵌入式系统的要求.newlib可移植性强, 具有可重入特性,功能完备等特点,已广泛应用于各种嵌入式系统中.\n2.  编译工具GNU Compiler Collection (GCC)，\n3.  二进制实用程序Binutils (GNU binary utilities)，其中包括：objdump、readelf、strip、ar、nm、ldd、ngprof、gcov等。\n4.  调试工具GNU Remote Debugger (GDB)\n5.  GNU make\n6.  内核调试工具kgdb.\n\n从广义上来讲，GNU的工具链还包括如下几个单元：\n1.  GNU代码编辑器(vi, emacs, vim etc.)\n2.  GNU自动化工具，旨在提高程序可移植性。","source":"_posts/GUNToolchina.md","raw":"---\ntitle: GNU Toolchain\nid: 170\ncategories:\n  - Operating System\ndate: 2015-07-23 21:23:10\ntags:\n---\n\nGNU toolchain is a free C/C++ programming toolchain, it is an important part during the improvement of Linux system. Most of CPU manufacturers support the GNU compiler toolchain include the native- compile toolchain and cross-compile toolchain, that also makes the GNU toolchain become the most popular toolchain of embedded software development. It supports wide range of CPU architecture, such as x86, IA-32, MIPS,tile, PowerPC, Spark etc.\n\nIn common, GNU toolchain consists of these parts:\n\n1.  GUN C Library.\n2.  GNU Compiler Collection(GCC).\n3.  Binutils(GNU Binary Utilities), includes objdump, readelf, strip, ar, nm, ldd, ngprof, gcov etc.\n4.  GNU Remote Debugger(GDB).\n5.  GNU make\n6.  kernel debugger (KGDB).\n\nGenerally, GNU toolchain also includes:\n\t1. GNU code editor (vi, emacs, vim etc.\n\t2. GNU automake tool, in order to improve the portability of the code。\n\n[翻译]\nGNU编译工具链是一个“免费”的C/C++工具链，有力的支撑了Linux系统的发展。众多的处理器厂家都提供了对GNU编译工具链的支持（本地编译工具链（native-compile toolchain）、交叉编译（cross-compile toolchain）），这也使得其成为了嵌入式软件开发中最流行的工具集。其支持的体系结构非常广泛，其中包括：X86, IA-32, MIPS, tile, PowerPC, Spark etc.\n\n通常来讲，我们认为GNU工具链主要由以下几个大的单元构成：\n\n1.  GNU C Library，也就是通常所说的glibc，另外在嵌入式领域，往往采用glibc兼容的uclibc、newlib等。glibc是由GNU项目提供的标准C运行库，它针对PC应用设计，较庞大，但能提供最优的兼容性。如果一般的嵌入式开发可选用uClibc。uClibc原本是uCLinux开发过程中的一个C语言库，现已经独立于uCLinux项目并且进一步完善。它对glibc的大部分函数进行了重写，并且目标就定位于嵌入式，所以其相对glibc而言要小巧很多。此外由于它的函数与glibc保持一致，这样很多原本基于glibc开发的软件基本无需改动便可改用uClibc编译运行，使得在嵌入式系统上占用的内存和磁盘空间更少。但由于毕竟不是标准的C运行库，因此uClibc拥有着一定的兼容性问题。 Newlib是一个面向嵌入式系统的C运行库.最初是由Solutions收集组装的一个源代码集合,取名为newlib, 现在由Red Hat维护,对于与GNU兼容的嵌入式C运行库,Newlib并不是唯一的选择,但是从成熟度来讲,newlib是最优秀的.newlib具有独特的体系结构,使得它能够非常好地满足深度嵌入式系统的要求.newlib可移植性强, 具有可重入特性,功能完备等特点,已广泛应用于各种嵌入式系统中.\n2.  编译工具GNU Compiler Collection (GCC)，\n3.  二进制实用程序Binutils (GNU binary utilities)，其中包括：objdump、readelf、strip、ar、nm、ldd、ngprof、gcov等。\n4.  调试工具GNU Remote Debugger (GDB)\n5.  GNU make\n6.  内核调试工具kgdb.\n\n从广义上来讲，GNU的工具链还包括如下几个单元：\n1.  GNU代码编辑器(vi, emacs, vim etc.)\n2.  GNU自动化工具，旨在提高程序可移植性。","slug":"GUNToolchina","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1a001dlkgugrw1zcox","content":"<p>GNU toolchain is a free C/C++ programming toolchain, it is an important part during the improvement of Linux system. Most of CPU manufacturers support the GNU compiler toolchain include the native- compile toolchain and cross-compile toolchain, that also makes the GNU toolchain become the most popular toolchain of embedded software development. It supports wide range of CPU architecture, such as x86, IA-32, MIPS,tile, PowerPC, Spark etc.</p>\n<p>In common, GNU toolchain consists of these parts:</p>\n<ol>\n<li>GUN C Library.</li>\n<li>GNU Compiler Collection(GCC).</li>\n<li>Binutils(GNU Binary Utilities), includes objdump, readelf, strip, ar, nm, ldd, ngprof, gcov etc.</li>\n<li>GNU Remote Debugger(GDB).</li>\n<li>GNU make</li>\n<li>kernel debugger (KGDB).</li>\n</ol>\n<p>Generally, GNU toolchain also includes:</p>\n<pre><code>1. GNU code editor (vi, emacs, vim etc.\n2. GNU automake tool, in order to improve the portability of the code。\n</code></pre><p>[翻译]<br>GNU编译工具链是一个“免费”的C/C++工具链，有力的支撑了Linux系统的发展。众多的处理器厂家都提供了对GNU编译工具链的支持（本地编译工具链（native-compile toolchain）、交叉编译（cross-compile toolchain）），这也使得其成为了嵌入式软件开发中最流行的工具集。其支持的体系结构非常广泛，其中包括：X86, IA-32, MIPS, tile, PowerPC, Spark etc.</p>\n<p>通常来讲，我们认为GNU工具链主要由以下几个大的单元构成：</p>\n<ol>\n<li>GNU C Library，也就是通常所说的glibc，另外在嵌入式领域，往往采用glibc兼容的uclibc、newlib等。glibc是由GNU项目提供的标准C运行库，它针对PC应用设计，较庞大，但能提供最优的兼容性。如果一般的嵌入式开发可选用uClibc。uClibc原本是uCLinux开发过程中的一个C语言库，现已经独立于uCLinux项目并且进一步完善。它对glibc的大部分函数进行了重写，并且目标就定位于嵌入式，所以其相对glibc而言要小巧很多。此外由于它的函数与glibc保持一致，这样很多原本基于glibc开发的软件基本无需改动便可改用uClibc编译运行，使得在嵌入式系统上占用的内存和磁盘空间更少。但由于毕竟不是标准的C运行库，因此uClibc拥有着一定的兼容性问题。 Newlib是一个面向嵌入式系统的C运行库.最初是由Solutions收集组装的一个源代码集合,取名为newlib, 现在由Red Hat维护,对于与GNU兼容的嵌入式C运行库,Newlib并不是唯一的选择,但是从成熟度来讲,newlib是最优秀的.newlib具有独特的体系结构,使得它能够非常好地满足深度嵌入式系统的要求.newlib可移植性强, 具有可重入特性,功能完备等特点,已广泛应用于各种嵌入式系统中.</li>\n<li>编译工具GNU Compiler Collection (GCC)，</li>\n<li>二进制实用程序Binutils (GNU binary utilities)，其中包括：objdump、readelf、strip、ar、nm、ldd、ngprof、gcov等。</li>\n<li>调试工具GNU Remote Debugger (GDB)</li>\n<li>GNU make</li>\n<li>内核调试工具kgdb.</li>\n</ol>\n<p>从广义上来讲，GNU的工具链还包括如下几个单元：</p>\n<ol>\n<li>GNU代码编辑器(vi, emacs, vim etc.)</li>\n<li>GNU自动化工具，旨在提高程序可移植性。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>GNU toolchain is a free C/C++ programming toolchain, it is an important part during the improvement of Linux system. Most of CPU manufacturers support the GNU compiler toolchain include the native- compile toolchain and cross-compile toolchain, that also makes the GNU toolchain become the most popular toolchain of embedded software development. It supports wide range of CPU architecture, such as x86, IA-32, MIPS,tile, PowerPC, Spark etc.</p>\n<p>In common, GNU toolchain consists of these parts:</p>\n<ol>\n<li>GUN C Library.</li>\n<li>GNU Compiler Collection(GCC).</li>\n<li>Binutils(GNU Binary Utilities), includes objdump, readelf, strip, ar, nm, ldd, ngprof, gcov etc.</li>\n<li>GNU Remote Debugger(GDB).</li>\n<li>GNU make</li>\n<li>kernel debugger (KGDB).</li>\n</ol>\n<p>Generally, GNU toolchain also includes:</p>\n<pre><code>1. GNU code editor (vi, emacs, vim etc.\n2. GNU automake tool, in order to improve the portability of the code。\n</code></pre><p>[翻译]<br>GNU编译工具链是一个“免费”的C/C++工具链，有力的支撑了Linux系统的发展。众多的处理器厂家都提供了对GNU编译工具链的支持（本地编译工具链（native-compile toolchain）、交叉编译（cross-compile toolchain）），这也使得其成为了嵌入式软件开发中最流行的工具集。其支持的体系结构非常广泛，其中包括：X86, IA-32, MIPS, tile, PowerPC, Spark etc.</p>\n<p>通常来讲，我们认为GNU工具链主要由以下几个大的单元构成：</p>\n<ol>\n<li>GNU C Library，也就是通常所说的glibc，另外在嵌入式领域，往往采用glibc兼容的uclibc、newlib等。glibc是由GNU项目提供的标准C运行库，它针对PC应用设计，较庞大，但能提供最优的兼容性。如果一般的嵌入式开发可选用uClibc。uClibc原本是uCLinux开发过程中的一个C语言库，现已经独立于uCLinux项目并且进一步完善。它对glibc的大部分函数进行了重写，并且目标就定位于嵌入式，所以其相对glibc而言要小巧很多。此外由于它的函数与glibc保持一致，这样很多原本基于glibc开发的软件基本无需改动便可改用uClibc编译运行，使得在嵌入式系统上占用的内存和磁盘空间更少。但由于毕竟不是标准的C运行库，因此uClibc拥有着一定的兼容性问题。 Newlib是一个面向嵌入式系统的C运行库.最初是由Solutions收集组装的一个源代码集合,取名为newlib, 现在由Red Hat维护,对于与GNU兼容的嵌入式C运行库,Newlib并不是唯一的选择,但是从成熟度来讲,newlib是最优秀的.newlib具有独特的体系结构,使得它能够非常好地满足深度嵌入式系统的要求.newlib可移植性强, 具有可重入特性,功能完备等特点,已广泛应用于各种嵌入式系统中.</li>\n<li>编译工具GNU Compiler Collection (GCC)，</li>\n<li>二进制实用程序Binutils (GNU binary utilities)，其中包括：objdump、readelf、strip、ar、nm、ldd、ngprof、gcov等。</li>\n<li>调试工具GNU Remote Debugger (GDB)</li>\n<li>GNU make</li>\n<li>内核调试工具kgdb.</li>\n</ol>\n<p>从广义上来讲，GNU的工具链还包括如下几个单元：</p>\n<ol>\n<li>GNU代码编辑器(vi, emacs, vim etc.)</li>\n<li>GNU自动化工具，旨在提高程序可移植性。</li>\n</ol>\n"},{"title":"GPU 图形处理器","id":"270","date":"2015-08-03T03:20:18.000Z","_content":"# 图形处理器\n\n图形处理器（英语：Graphics Processing Unit，缩写：GPU），又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上图像运算工作的微处理器。\n\n\n显卡的处理器称为图形处理器（GPU），它是显卡的心脏，与CPU类似，只不过GPU是专为执行复杂的数学和几何计算而设计的，这些计算是图形渲染所必需的。某些最快速的GPU集成的晶体管数甚至超过了普通CPU。\n\n时下的GPU多数拥有2D或3D图形加速功能。如果CPU想画一个二维图形，只需要发个指令给GPU，如在坐标位置（x, y）处画个长和宽为a x b大小的长方形，GPU就可以迅速计算出该图形的所有像素，并在显示器上指定位置画出相应的图形，画完后就通知CPU我画完了，然后等待CPU发出下一条图形指令。\n\n有了GPU，CPU就从图形处理的任务中解放出来，可以执行其他更多的系统任务，这样可以大大提高计算机的整体性能。GPU是显示卡的大脑，GPU决定了该显卡的档次和大部分性能，同时GPU也是2D显示卡和3D显示卡的区别依据。2D显示芯片在处理3D图像与特效时主要依赖CPU的处理能力，称为软加速。3D显示芯片是把三维图像和特效处理功能集中在显示芯片内，也就是所谓的硬件加速\n\n今天，GPU已经不再局限于3D图形处理了，GPU通用计算技术发展已经引起业界不少的关注，事实也证明在 浮点运算 并行计算 等部分计算方面，GPU可以提供数十倍乃至于上百倍于CPU的性能，如此强悍的新星难免会让CPU厂商老大 英特尔 为未来而紧张， NVIDIA和英特尔也经常为CPU和GPU谁更重要而展开口水战。GPU通用计算方面的标准目前有 OPEN CL、CUDA、ATI STREAM。其中，OpenCL(全称Open Computing Language，开放运算语言)是第一个面向异构系统通用目的并行编程的开放式、免费标准，也是一个统一的 编程环境，便于软件开发人员为高性能计算服务器、桌面计算系统、手持设备编写高效轻便的代码，而且广泛适用于 多核心 处理器(CPU)、图形处理器(GPU)、Cell类型架构以及 数字信号处理器 (DSP)等其他并行处理器，在游戏、娱乐、科研、医疗等各种领域都有广阔的发展前景， \n\n简单说GPU就是能够从硬件上支持T&L（Transform and Lighting，多边形转换和光源处理）的 显示芯片，由于T&L是3D 中的一个重要部分，其作用是计算多边形的3D位置与处理动态光线效果，也能称为几何处理。一个好的T&L单元，能提供细致的3D物体和高级的光线特效；只不过大多数PC中，T&L的大部分运算是交由CPU处理的(这就也就是所谓软件T&L)，因为CPU的任务繁多，除了T&L之外，还要做 内存管理 和输入响应等非3D图形处理工作，所以在实际运算的时候性能会大打折扣，一般出现显卡等待CPU数据的情况，CPU运算速度远跟不上时下复杂三维游戏的要求。即使CPU的 工作频率 超出1GHz或更高，对它的帮助也不大，因为这是PC本身设计造成的问题，与CPU的速度无太大关系。\n","source":"_posts/GPU.md","raw":"---\ntitle: GPU 图形处理器\nid: 270\ncategories:\n  - Computer Graphics\ndate: 2015-08-02 23:20:18\ntags:\n---\n# 图形处理器\n\n图形处理器（英语：Graphics Processing Unit，缩写：GPU），又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上图像运算工作的微处理器。\n\n\n显卡的处理器称为图形处理器（GPU），它是显卡的心脏，与CPU类似，只不过GPU是专为执行复杂的数学和几何计算而设计的，这些计算是图形渲染所必需的。某些最快速的GPU集成的晶体管数甚至超过了普通CPU。\n\n时下的GPU多数拥有2D或3D图形加速功能。如果CPU想画一个二维图形，只需要发个指令给GPU，如在坐标位置（x, y）处画个长和宽为a x b大小的长方形，GPU就可以迅速计算出该图形的所有像素，并在显示器上指定位置画出相应的图形，画完后就通知CPU我画完了，然后等待CPU发出下一条图形指令。\n\n有了GPU，CPU就从图形处理的任务中解放出来，可以执行其他更多的系统任务，这样可以大大提高计算机的整体性能。GPU是显示卡的大脑，GPU决定了该显卡的档次和大部分性能，同时GPU也是2D显示卡和3D显示卡的区别依据。2D显示芯片在处理3D图像与特效时主要依赖CPU的处理能力，称为软加速。3D显示芯片是把三维图像和特效处理功能集中在显示芯片内，也就是所谓的硬件加速\n\n今天，GPU已经不再局限于3D图形处理了，GPU通用计算技术发展已经引起业界不少的关注，事实也证明在 浮点运算 并行计算 等部分计算方面，GPU可以提供数十倍乃至于上百倍于CPU的性能，如此强悍的新星难免会让CPU厂商老大 英特尔 为未来而紧张， NVIDIA和英特尔也经常为CPU和GPU谁更重要而展开口水战。GPU通用计算方面的标准目前有 OPEN CL、CUDA、ATI STREAM。其中，OpenCL(全称Open Computing Language，开放运算语言)是第一个面向异构系统通用目的并行编程的开放式、免费标准，也是一个统一的 编程环境，便于软件开发人员为高性能计算服务器、桌面计算系统、手持设备编写高效轻便的代码，而且广泛适用于 多核心 处理器(CPU)、图形处理器(GPU)、Cell类型架构以及 数字信号处理器 (DSP)等其他并行处理器，在游戏、娱乐、科研、医疗等各种领域都有广阔的发展前景， \n\n简单说GPU就是能够从硬件上支持T&L（Transform and Lighting，多边形转换和光源处理）的 显示芯片，由于T&L是3D 中的一个重要部分，其作用是计算多边形的3D位置与处理动态光线效果，也能称为几何处理。一个好的T&L单元，能提供细致的3D物体和高级的光线特效；只不过大多数PC中，T&L的大部分运算是交由CPU处理的(这就也就是所谓软件T&L)，因为CPU的任务繁多，除了T&L之外，还要做 内存管理 和输入响应等非3D图形处理工作，所以在实际运算的时候性能会大打折扣，一般出现显卡等待CPU数据的情况，CPU运算速度远跟不上时下复杂三维游戏的要求。即使CPU的 工作频率 超出1GHz或更高，对它的帮助也不大，因为这是PC本身设计造成的问题，与CPU的速度无太大关系。\n","slug":"GPU","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1b001glkguunwxoe6z","content":"<h1 id=\"图形处理器\"><a href=\"#图形处理器\" class=\"headerlink\" title=\"图形处理器\"></a>图形处理器</h1><p>图形处理器（英语：Graphics Processing Unit，缩写：GPU），又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上图像运算工作的微处理器。</p>\n<p>显卡的处理器称为图形处理器（GPU），它是显卡的心脏，与CPU类似，只不过GPU是专为执行复杂的数学和几何计算而设计的，这些计算是图形渲染所必需的。某些最快速的GPU集成的晶体管数甚至超过了普通CPU。</p>\n<p>时下的GPU多数拥有2D或3D图形加速功能。如果CPU想画一个二维图形，只需要发个指令给GPU，如在坐标位置（x, y）处画个长和宽为a x b大小的长方形，GPU就可以迅速计算出该图形的所有像素，并在显示器上指定位置画出相应的图形，画完后就通知CPU我画完了，然后等待CPU发出下一条图形指令。</p>\n<p>有了GPU，CPU就从图形处理的任务中解放出来，可以执行其他更多的系统任务，这样可以大大提高计算机的整体性能。GPU是显示卡的大脑，GPU决定了该显卡的档次和大部分性能，同时GPU也是2D显示卡和3D显示卡的区别依据。2D显示芯片在处理3D图像与特效时主要依赖CPU的处理能力，称为软加速。3D显示芯片是把三维图像和特效处理功能集中在显示芯片内，也就是所谓的硬件加速</p>\n<p>今天，GPU已经不再局限于3D图形处理了，GPU通用计算技术发展已经引起业界不少的关注，事实也证明在 浮点运算 并行计算 等部分计算方面，GPU可以提供数十倍乃至于上百倍于CPU的性能，如此强悍的新星难免会让CPU厂商老大 英特尔 为未来而紧张， NVIDIA和英特尔也经常为CPU和GPU谁更重要而展开口水战。GPU通用计算方面的标准目前有 OPEN CL、CUDA、ATI STREAM。其中，OpenCL(全称Open Computing Language，开放运算语言)是第一个面向异构系统通用目的并行编程的开放式、免费标准，也是一个统一的 编程环境，便于软件开发人员为高性能计算服务器、桌面计算系统、手持设备编写高效轻便的代码，而且广泛适用于 多核心 处理器(CPU)、图形处理器(GPU)、Cell类型架构以及 数字信号处理器 (DSP)等其他并行处理器，在游戏、娱乐、科研、医疗等各种领域都有广阔的发展前景， </p>\n<p>简单说GPU就是能够从硬件上支持T&amp;L（Transform and Lighting，多边形转换和光源处理）的 显示芯片，由于T&amp;L是3D 中的一个重要部分，其作用是计算多边形的3D位置与处理动态光线效果，也能称为几何处理。一个好的T&amp;L单元，能提供细致的3D物体和高级的光线特效；只不过大多数PC中，T&amp;L的大部分运算是交由CPU处理的(这就也就是所谓软件T&amp;L)，因为CPU的任务繁多，除了T&amp;L之外，还要做 内存管理 和输入响应等非3D图形处理工作，所以在实际运算的时候性能会大打折扣，一般出现显卡等待CPU数据的情况，CPU运算速度远跟不上时下复杂三维游戏的要求。即使CPU的 工作频率 超出1GHz或更高，对它的帮助也不大，因为这是PC本身设计造成的问题，与CPU的速度无太大关系。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"图形处理器\"><a href=\"#图形处理器\" class=\"headerlink\" title=\"图形处理器\"></a>图形处理器</h1><p>图形处理器（英语：Graphics Processing Unit，缩写：GPU），又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上图像运算工作的微处理器。</p>\n<p>显卡的处理器称为图形处理器（GPU），它是显卡的心脏，与CPU类似，只不过GPU是专为执行复杂的数学和几何计算而设计的，这些计算是图形渲染所必需的。某些最快速的GPU集成的晶体管数甚至超过了普通CPU。</p>\n<p>时下的GPU多数拥有2D或3D图形加速功能。如果CPU想画一个二维图形，只需要发个指令给GPU，如在坐标位置（x, y）处画个长和宽为a x b大小的长方形，GPU就可以迅速计算出该图形的所有像素，并在显示器上指定位置画出相应的图形，画完后就通知CPU我画完了，然后等待CPU发出下一条图形指令。</p>\n<p>有了GPU，CPU就从图形处理的任务中解放出来，可以执行其他更多的系统任务，这样可以大大提高计算机的整体性能。GPU是显示卡的大脑，GPU决定了该显卡的档次和大部分性能，同时GPU也是2D显示卡和3D显示卡的区别依据。2D显示芯片在处理3D图像与特效时主要依赖CPU的处理能力，称为软加速。3D显示芯片是把三维图像和特效处理功能集中在显示芯片内，也就是所谓的硬件加速</p>\n<p>今天，GPU已经不再局限于3D图形处理了，GPU通用计算技术发展已经引起业界不少的关注，事实也证明在 浮点运算 并行计算 等部分计算方面，GPU可以提供数十倍乃至于上百倍于CPU的性能，如此强悍的新星难免会让CPU厂商老大 英特尔 为未来而紧张， NVIDIA和英特尔也经常为CPU和GPU谁更重要而展开口水战。GPU通用计算方面的标准目前有 OPEN CL、CUDA、ATI STREAM。其中，OpenCL(全称Open Computing Language，开放运算语言)是第一个面向异构系统通用目的并行编程的开放式、免费标准，也是一个统一的 编程环境，便于软件开发人员为高性能计算服务器、桌面计算系统、手持设备编写高效轻便的代码，而且广泛适用于 多核心 处理器(CPU)、图形处理器(GPU)、Cell类型架构以及 数字信号处理器 (DSP)等其他并行处理器，在游戏、娱乐、科研、医疗等各种领域都有广阔的发展前景， </p>\n<p>简单说GPU就是能够从硬件上支持T&amp;L（Transform and Lighting，多边形转换和光源处理）的 显示芯片，由于T&amp;L是3D 中的一个重要部分，其作用是计算多边形的3D位置与处理动态光线效果，也能称为几何处理。一个好的T&amp;L单元，能提供细致的3D物体和高级的光线特效；只不过大多数PC中，T&amp;L的大部分运算是交由CPU处理的(这就也就是所谓软件T&amp;L)，因为CPU的任务繁多，除了T&amp;L之外，还要做 内存管理 和输入响应等非3D图形处理工作，所以在实际运算的时候性能会大打折扣，一般出现显卡等待CPU数据的情况，CPU运算速度远跟不上时下复杂三维游戏的要求。即使CPU的 工作频率 超出1GHz或更高，对它的帮助也不大，因为这是PC本身设计造成的问题，与CPU的速度无太大关系。</p>\n"},{"title":"Git Command","id":"503","date":"2015-10-01T21:03:01.000Z","_content":"\n### Git configuration\n\n*   `$ git config --global user.name Your Name`\n*   `$ git config --global user.email email@example.com`\n\n### Great Respository\n\n*   `$ git init`\n*   `$ git add file`\n*   `$ git commit -m XXXXXX`\n\n###  Respository Reset\n\n*   `$ git status`\n*   `$ git diff`\n*   `$ git diff reset --hard commit_id`\n*   `$ git log --pretty=oneline`\n*   `$ git reflog`\n*   `$ git checkout --file`\n*   `$ git rm`\n\n### Add remote Responsitory\n\n*   `$ git remote add origin gitaddress`\n*   `$ git clone gitaddress`\n\n### Branch Manage\n\n*   查看分支：`git branch`\n*   创建分支：`git branch name`\n*   切换分支：`git checkout name`\n*   创建+切换分支：`git checkout -b name`\n*   合并某分支到当前分支：`git merge name`\n*   删除分支：`git branch -d name`\n*   查看分支图： 'git log --graph'\n*   当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，修复后，再`git stash pop`，回到工作现场\n\n### Coorpration\n\n*   查看远程库信息，使用`git remote -v`；\n*   本地新建的分支如果不推送到远程，对其他人就是不可见的；\n*   从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\n*   在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\n*   建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\n*   从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n","source":"_posts/GitCommands.md","raw":"---\ntitle: Git Command\nid: 503\ncategories:\n  - Tech\ndate: 2015-10-01 17:03:01\ntags:\n---\n\n### Git configuration\n\n*   `$ git config --global user.name Your Name`\n*   `$ git config --global user.email email@example.com`\n\n### Great Respository\n\n*   `$ git init`\n*   `$ git add file`\n*   `$ git commit -m XXXXXX`\n\n###  Respository Reset\n\n*   `$ git status`\n*   `$ git diff`\n*   `$ git diff reset --hard commit_id`\n*   `$ git log --pretty=oneline`\n*   `$ git reflog`\n*   `$ git checkout --file`\n*   `$ git rm`\n\n### Add remote Responsitory\n\n*   `$ git remote add origin gitaddress`\n*   `$ git clone gitaddress`\n\n### Branch Manage\n\n*   查看分支：`git branch`\n*   创建分支：`git branch name`\n*   切换分支：`git checkout name`\n*   创建+切换分支：`git checkout -b name`\n*   合并某分支到当前分支：`git merge name`\n*   删除分支：`git branch -d name`\n*   查看分支图： 'git log --graph'\n*   当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，修复后，再`git stash pop`，回到工作现场\n\n### Coorpration\n\n*   查看远程库信息，使用`git remote -v`；\n*   本地新建的分支如果不推送到远程，对其他人就是不可见的；\n*   从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\n*   在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\n*   建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\n*   从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n","slug":"GitCommands","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1c001ilkgu5fuasmu1","content":"<h3 id=\"Git-configuration\"><a href=\"#Git-configuration\" class=\"headerlink\" title=\"Git configuration\"></a>Git configuration</h3><ul>\n<li><code>$ git config --global user.name Your Name</code></li>\n<li><code>$ git config --global user.email email@example.com</code></li>\n</ul>\n<h3 id=\"Great-Respository\"><a href=\"#Great-Respository\" class=\"headerlink\" title=\"Great Respository\"></a>Great Respository</h3><ul>\n<li><code>$ git init</code></li>\n<li><code>$ git add file</code></li>\n<li><code>$ git commit -m XXXXXX</code></li>\n</ul>\n<h3 id=\"Respository-Reset\"><a href=\"#Respository-Reset\" class=\"headerlink\" title=\"Respository Reset\"></a>Respository Reset</h3><ul>\n<li><code>$ git status</code></li>\n<li><code>$ git diff</code></li>\n<li><code>$ git diff reset --hard commit_id</code></li>\n<li><code>$ git log --pretty=oneline</code></li>\n<li><code>$ git reflog</code></li>\n<li><code>$ git checkout --file</code></li>\n<li><code>$ git rm</code></li>\n</ul>\n<h3 id=\"Add-remote-Responsitory\"><a href=\"#Add-remote-Responsitory\" class=\"headerlink\" title=\"Add remote Responsitory\"></a>Add remote Responsitory</h3><ul>\n<li><code>$ git remote add origin gitaddress</code></li>\n<li><code>$ git clone gitaddress</code></li>\n</ul>\n<h3 id=\"Branch-Manage\"><a href=\"#Branch-Manage\" class=\"headerlink\" title=\"Branch Manage\"></a>Branch Manage</h3><ul>\n<li>查看分支：<code>git branch</code></li>\n<li>创建分支：<code>git branch name</code></li>\n<li>切换分支：<code>git checkout name</code></li>\n<li>创建+切换分支：<code>git checkout -b name</code></li>\n<li>合并某分支到当前分支：<code>git merge name</code></li>\n<li>删除分支：<code>git branch -d name</code></li>\n<li>查看分支图： ‘git log –graph’</li>\n<li>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场</li>\n</ul>\n<h3 id=\"Coorpration\"><a href=\"#Coorpration\" class=\"headerlink\" title=\"Coorpration\"></a>Coorpration</h3><ul>\n<li>查看远程库信息，使用<code>git remote -v</code>；</li>\n<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>\n<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>\n<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>\n<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>\n<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Git-configuration\"><a href=\"#Git-configuration\" class=\"headerlink\" title=\"Git configuration\"></a>Git configuration</h3><ul>\n<li><code>$ git config --global user.name Your Name</code></li>\n<li><code>$ git config --global user.email email@example.com</code></li>\n</ul>\n<h3 id=\"Great-Respository\"><a href=\"#Great-Respository\" class=\"headerlink\" title=\"Great Respository\"></a>Great Respository</h3><ul>\n<li><code>$ git init</code></li>\n<li><code>$ git add file</code></li>\n<li><code>$ git commit -m XXXXXX</code></li>\n</ul>\n<h3 id=\"Respository-Reset\"><a href=\"#Respository-Reset\" class=\"headerlink\" title=\"Respository Reset\"></a>Respository Reset</h3><ul>\n<li><code>$ git status</code></li>\n<li><code>$ git diff</code></li>\n<li><code>$ git diff reset --hard commit_id</code></li>\n<li><code>$ git log --pretty=oneline</code></li>\n<li><code>$ git reflog</code></li>\n<li><code>$ git checkout --file</code></li>\n<li><code>$ git rm</code></li>\n</ul>\n<h3 id=\"Add-remote-Responsitory\"><a href=\"#Add-remote-Responsitory\" class=\"headerlink\" title=\"Add remote Responsitory\"></a>Add remote Responsitory</h3><ul>\n<li><code>$ git remote add origin gitaddress</code></li>\n<li><code>$ git clone gitaddress</code></li>\n</ul>\n<h3 id=\"Branch-Manage\"><a href=\"#Branch-Manage\" class=\"headerlink\" title=\"Branch Manage\"></a>Branch Manage</h3><ul>\n<li>查看分支：<code>git branch</code></li>\n<li>创建分支：<code>git branch name</code></li>\n<li>切换分支：<code>git checkout name</code></li>\n<li>创建+切换分支：<code>git checkout -b name</code></li>\n<li>合并某分支到当前分支：<code>git merge name</code></li>\n<li>删除分支：<code>git branch -d name</code></li>\n<li>查看分支图： ‘git log –graph’</li>\n<li>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场</li>\n</ul>\n<h3 id=\"Coorpration\"><a href=\"#Coorpration\" class=\"headerlink\" title=\"Coorpration\"></a>Coorpration</h3><ul>\n<li>查看远程库信息，使用<code>git remote -v</code>；</li>\n<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>\n<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>\n<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>\n<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>\n<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>\n</ul>\n"},{"title":"Ubuntu 下安装googletest","id":"14","date":"2015-03-02T12:24:18.000Z","_content":"\n1.下载googletest\n\n2.解压gtest包\n\n3.配置gtest\n\n```\ncmake CMakeList.txt\n\nmake\n```\ngtest 不需要make install, 我们只使用gtest库\n\n3.编译libgtest.a包， 这个包包含了gtest的核心，将来会被用于qt工程的单元测试中将该包拷贝到系统目录下\n```\ncp *.a /usr/lib/\n```","source":"_posts/GoogleTest.md","raw":"---\ntitle: Ubuntu 下安装googletest\ntags:\n  - GoogleTest\n  - Ubuntu\nid: 14\ncategories:\n  - Issues Solution\ndate: 2015-03-02 07:24:18\n---\n\n1.下载googletest\n\n2.解压gtest包\n\n3.配置gtest\n\n```\ncmake CMakeList.txt\n\nmake\n```\ngtest 不需要make install, 我们只使用gtest库\n\n3.编译libgtest.a包， 这个包包含了gtest的核心，将来会被用于qt工程的单元测试中将该包拷贝到系统目录下\n```\ncp *.a /usr/lib/\n```","slug":"GoogleTest","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1d001llkguvhr5ede2","content":"<p>1.下载googletest</p>\n<p>2.解压gtest包</p>\n<p>3.配置gtest</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake CMakeList.txt</span><br><span class=\"line\"></span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p>gtest 不需要make install, 我们只使用gtest库</p>\n<p>3.编译libgtest.a包， 这个包包含了gtest的核心，将来会被用于qt工程的单元测试中将该包拷贝到系统目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp *.a /usr/lib/</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.下载googletest</p>\n<p>2.解压gtest包</p>\n<p>3.配置gtest</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake CMakeList.txt</span><br><span class=\"line\"></span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p>gtest 不需要make install, 我们只使用gtest库</p>\n<p>3.编译libgtest.a包， 这个包包含了gtest的核心，将来会被用于qt工程的单元测试中将该包拷贝到系统目录下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp *.a /usr/lib/</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Header Files, Libraries and DLLs","id":"267","date":"2015-08-02T23:33:43.000Z","_content":"\n### DLL\nIn real world project, you don`t build the program from scratch, instead you download SDK, it comes with DLL, headers and lib files. DLLs are just the a compiled set of functions, the main benefit of DLL is reusable, for example some games in your computer may use the same graphics library, so this library can be packaged into a DLL. And DLL always comes with header files and lib files.\n\n### Header\nHeader are usually a text file in a.h extension. All these are a description of functions you can call. But there is no implementation of the functions in the header file. Instead the implementations are all in the DLL. You can use keyword include in you program, the means to search the header file locally and means to search the header file elsewhere.\n\n### LIB\nLib related header file to DLL. Lib file is a binary file and tell us where in the DLL we can find the funcitons. For example, if we include a header file the project needs the lib file so that when we comilpe it we know where inside the DLL to find the functions, and then during the runtime in thoes exactly where to look inside that DLL for these functions.","source":"_posts/HeaderLibDLL.md","raw":"---\ntitle: 'Header Files, Libraries and DLLs'\nid: 267\ncategories:\n  - C/C++\ndate: 2015-08-02 19:33:43\ntags:\n---\n\n### DLL\nIn real world project, you don`t build the program from scratch, instead you download SDK, it comes with DLL, headers and lib files. DLLs are just the a compiled set of functions, the main benefit of DLL is reusable, for example some games in your computer may use the same graphics library, so this library can be packaged into a DLL. And DLL always comes with header files and lib files.\n\n### Header\nHeader are usually a text file in a.h extension. All these are a description of functions you can call. But there is no implementation of the functions in the header file. Instead the implementations are all in the DLL. You can use keyword include in you program, the means to search the header file locally and means to search the header file elsewhere.\n\n### LIB\nLib related header file to DLL. Lib file is a binary file and tell us where in the DLL we can find the funcitons. For example, if we include a header file the project needs the lib file so that when we comilpe it we know where inside the DLL to find the functions, and then during the runtime in thoes exactly where to look inside that DLL for these functions.","slug":"HeaderLibDLL","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1e001nlkguf3qqt3le","content":"<h3 id=\"DLL\"><a href=\"#DLL\" class=\"headerlink\" title=\"DLL\"></a>DLL</h3><p>In real world project, you don`t build the program from scratch, instead you download SDK, it comes with DLL, headers and lib files. DLLs are just the a compiled set of functions, the main benefit of DLL is reusable, for example some games in your computer may use the same graphics library, so this library can be packaged into a DLL. And DLL always comes with header files and lib files.</p>\n<h3 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h3><p>Header are usually a text file in a.h extension. All these are a description of functions you can call. But there is no implementation of the functions in the header file. Instead the implementations are all in the DLL. You can use keyword include in you program, the means to search the header file locally and means to search the header file elsewhere.</p>\n<h3 id=\"LIB\"><a href=\"#LIB\" class=\"headerlink\" title=\"LIB\"></a>LIB</h3><p>Lib related header file to DLL. Lib file is a binary file and tell us where in the DLL we can find the funcitons. For example, if we include a header file the project needs the lib file so that when we comilpe it we know where inside the DLL to find the functions, and then during the runtime in thoes exactly where to look inside that DLL for these functions.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"DLL\"><a href=\"#DLL\" class=\"headerlink\" title=\"DLL\"></a>DLL</h3><p>In real world project, you don`t build the program from scratch, instead you download SDK, it comes with DLL, headers and lib files. DLLs are just the a compiled set of functions, the main benefit of DLL is reusable, for example some games in your computer may use the same graphics library, so this library can be packaged into a DLL. And DLL always comes with header files and lib files.</p>\n<h3 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h3><p>Header are usually a text file in a.h extension. All these are a description of functions you can call. But there is no implementation of the functions in the header file. Instead the implementations are all in the DLL. You can use keyword include in you program, the means to search the header file locally and means to search the header file elsewhere.</p>\n<h3 id=\"LIB\"><a href=\"#LIB\" class=\"headerlink\" title=\"LIB\"></a>LIB</h3><p>Lib related header file to DLL. Lib file is a binary file and tell us where in the DLL we can find the funcitons. For example, if we include a header file the project needs the lib file so that when we comilpe it we know where inside the DLL to find the functions, and then during the runtime in thoes exactly where to look inside that DLL for these functions.</p>\n"},{"title":"Java, difference between abstract class and interface","id":"344","date":"2015-08-31T21:03:41.000Z","_content":"\n# 接口和抽象类有什么区别\n\n你选择使用接口和抽象类的依据是什么？\n\n接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。\n\n抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话），他们的抽象类是人。说明，他们都是人。\n\n人可以吃东西，狗也可以吃东西，你可以把吃东西定义成一个接口，然后让这些类去实现它.\n\n所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。\n\n1. 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。\n\n2. 接口可以多继承，抽象类不行\n\n3. 接口定义方法，不能实现，而抽象类可以实现部分方法。\n\n4. 接口中基本数据类型为static 而抽类象不是的。\n\n当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。\n\n抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的\n\n所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。\n\n","source":"_posts/JavaAbstractClassInterface.md","raw":"---\ntitle: 'Java, difference between abstract class and interface'\nid: 344\ncategories:\n  - Java\ndate: 2015-08-31 17:03:41\ntags:\n  - Java\n---\n\n# 接口和抽象类有什么区别\n\n你选择使用接口和抽象类的依据是什么？\n\n接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。\n\n抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话），他们的抽象类是人。说明，他们都是人。\n\n人可以吃东西，狗也可以吃东西，你可以把吃东西定义成一个接口，然后让这些类去实现它.\n\n所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。\n\n1. 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。\n\n2. 接口可以多继承，抽象类不行\n\n3. 接口定义方法，不能实现，而抽象类可以实现部分方法。\n\n4. 接口中基本数据类型为static 而抽类象不是的。\n\n当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。\n\n抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的\n\n所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。\n\n","slug":"JavaAbstractClassInterface","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1f001rlkgu6kwmwji8","content":"<h1 id=\"接口和抽象类有什么区别\"><a href=\"#接口和抽象类有什么区别\" class=\"headerlink\" title=\"接口和抽象类有什么区别\"></a>接口和抽象类有什么区别</h1><p>你选择使用接口和抽象类的依据是什么？</p>\n<p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。</p>\n<p>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话），他们的抽象类是人。说明，他们都是人。</p>\n<p>人可以吃东西，狗也可以吃东西，你可以把吃东西定义成一个接口，然后让这些类去实现它.</p>\n<p>所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</p>\n<ol>\n<li><p>接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。</p>\n</li>\n<li><p>接口可以多继承，抽象类不行</p>\n</li>\n<li><p>接口定义方法，不能实现，而抽象类可以实现部分方法。</p>\n</li>\n<li><p>接口中基本数据类型为static 而抽类象不是的。</p>\n</li>\n</ol>\n<p>当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>\n<p>抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的</p>\n<p>所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"接口和抽象类有什么区别\"><a href=\"#接口和抽象类有什么区别\" class=\"headerlink\" title=\"接口和抽象类有什么区别\"></a>接口和抽象类有什么区别</h1><p>你选择使用接口和抽象类的依据是什么？</p>\n<p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。</p>\n<p>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话），他们的抽象类是人。说明，他们都是人。</p>\n<p>人可以吃东西，狗也可以吃东西，你可以把吃东西定义成一个接口，然后让这些类去实现它.</p>\n<p>所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</p>\n<ol>\n<li><p>接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。</p>\n</li>\n<li><p>接口可以多继承，抽象类不行</p>\n</li>\n<li><p>接口定义方法，不能实现，而抽象类可以实现部分方法。</p>\n</li>\n<li><p>接口中基本数据类型为static 而抽类象不是的。</p>\n</li>\n</ol>\n<p>当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>\n<p>抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的</p>\n<p>所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。</p>\n"},{"title":"[转] Linux  FHS2.3目录结构","id":"135","date":"2015-05-31T04:49:06.000Z","_content":"\n# [转] Linux FHS2.3 目录结构\n\n![](https://dn-anything-about-doc.qbox.me/linux_base/4-1.png/logoblackfont)\n","source":"_posts/LinuxFhsCat.md","raw":"---\ntitle: \"[转] Linux  FHS2.3目录结构\"\nid: 135\ncategories: \n  - Ubuntu\ndate: 2015-05-31 00:49:06\ntags:\n---\n\n# [转] Linux FHS2.3 目录结构\n\n![](https://dn-anything-about-doc.qbox.me/linux_base/4-1.png/logoblackfont)\n","slug":"LinuxFhsCat","published":1,"updated":"2019-02-12T00:37:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1f001tlkgurtjfg5dx","content":"<h1 id=\"转-Linux-FHS2-3-目录结构\"><a href=\"#转-Linux-FHS2-3-目录结构\" class=\"headerlink\" title=\"[转] Linux FHS2.3 目录结构\"></a>[转] Linux FHS2.3 目录结构</h1><p><img src=\"https://dn-anything-about-doc.qbox.me/linux_base/4-1.png/logoblackfont\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"转-Linux-FHS2-3-目录结构\"><a href=\"#转-Linux-FHS2-3-目录结构\" class=\"headerlink\" title=\"[转] Linux FHS2.3 目录结构\"></a>[转] Linux FHS2.3 目录结构</h1><p><img src=\"https://dn-anything-about-doc.qbox.me/linux_base/4-1.png/logoblackfont\" alt=\"\"></p>\n"},{"title":"【转】Java中的对象释放问题","id":"16","date":"2015-03-07T20:31:03.000Z","_content":"# 【转】Java中的对象释放问题\n\n许多方面，Java 类似于 C++。Java 的语法非常类似于 C++，Java 有类、方法和数据成员；Java 的类有构造函数； Java 有异常处理。\n\n但是，如果你使用过 C++ 会发现 Java 也丢掉一些可能是你熟悉的特性。这些特性之一就是析构函数。取代使用析构函数，Java 支持finalize() 方法。\n\n在本文中，我们将描述 finalize() 与 C++ 析构函数的区别。另外，我们将创建一个简单的 Applet 来演示 finalize() 是如何工作的。\n\n最终的界限\n\n与 Java 不同，C++ 支持局部对象（基于栈）和全局对象（基于堆）。因为这一双重支持，C++ 也提供了自动构造和析构，这导致了对构造函数和析构函数的调用，（对于堆对象）就是内存的分配和释放。\n\n在 Java 中，所有对象都驻留在堆内存，因此局部对象就不存在。结果，Java 的设计者觉得不需要析构函数（象 C++ 中所实现的）。\n\n取而代之，Java 定义了一个特殊的方法叫做finalize() ，它提供了 C++ 析构函数的一些功能。但是，finalize() 并不完全与 C++ 的析构函数一样，并可以假设它会导致一系列的问题。finalize() 方法作用的一个关键元素是 Java 的垃圾回收器。\n\n垃圾回收器\n\n在 C/C++、Pascal和其他几种多种用途的编程语言中，开发者有责任在内存管理上发挥积极的作用。例如，如果你为一个对象或数据结构分配了内存，那么当你不再使用它时必须释放掉该内存。\n\n在 Java 中，当你创建一个对象时，Java 虚拟机（JVM）为该对象分配内存、调用构造函数并开始跟踪你使用的对象。当你停止使用一个对象（就是说，当没有对该对象有效的引用时），JVM 通过垃圾回收器将该对象标记为释放状态。\n\n当垃圾回收器将要释放一个对象的内存时，它调用该对象的finalize() 方法（如果该对象定义了此方法）。垃圾回收器以独立的低优先级的方式运行，只有当其他线程挂起等待该内存释放的情况出现时，它才开始运行释放对象的内 存。（事实上，你可以调用System.gc() 方法强制垃圾回收器来释放这些对象的内存。）\n\n在以上的描述中，有一些重要的事情需要注意。首先，只有当垃圾回收器释放该对象的内存时，才会执行finalize()。如果在 Applet 或应用程序退出之前垃圾回收器没有释放内存，垃圾回收器将不会调用finalize()。\n\n其次，除非垃圾回收器认为你的 Applet 或应用程序需要额外的内存，否则它不会试图释放不再使用的对象的内存。换句话说，这是完全可能的：一个 Applet 给少量的对象分配内存，没有造成严重的内存需求，于是垃圾回收器没有释放这些对象的内存就退出了。\n\n显然，如果你为某个对象定义了finalize() 方法，JVM 可能不会调用它，因为垃圾回收器不曾释放过那些对象的内存。调用System.gc() 也不会起作用，因为它仅仅是给 JVM 一个建议而不是命令。\n\nfinalize() 有什么优点呢？\n\n如果finalize() 不是析构函数，JVM 不一定会调用它，你可能会疑惑它是否在任何情况下都有好处。事实上，在 Java 1.0 中它并没有太多的优点。\n\n根据 Java 文档，finalize() 是一个用于释放非 Java 资源的方法。但是，JVM 有很大的可能不调用对象的finalize() 方法，因此很难证明使用该方法释放资源是有效的。\n\nJava 1.1 通过提供一个System.runFinalizersOnExit() 方法部分地解决了这个问题。（不要将这个方法与 Java 1.0 中的System.runFinalizations() 方法相混淆。）不象System.gc() 方法那样，System.runFinalizersOnExit() 方法并不立即试图启动垃圾回收器。而是当应用程序或 Applet 退出时，它调用每个对象的finalize() 方法。\n\n正如你可能猜测的那样，通过调用System.runFinalizersOnExit() 方法强制垃圾回收器清除所有独立对象的内存，当清除代码执行时可能会引起明显的延迟。现在建立一个示例 Applet 来演示 Java 垃圾回收器和finalize() 方法是如何相互作用的。\n\n回收垃圾\n\n通过使用Java Applet Wizard 创建一个新的 Applet 开始。当提示这样做时，输入 final_things 作为 Applet 名，并选择不要生成源文件注释。\n\n接下来，在Java Applet Wizard 进行第三步，不要选择多线程选项。在第五步之前，根据需要修改 Applet 的描述。\n\n当你单击Finish 后，Applet Wizard 将生成一个新的工作空间，并为该项目创建缺省的 Java 文件。从列表 A 中选择适当的代码输入（我们已经突出显示了你需要输入的代码）。\n\n当你完成代码的输入后，配置Internet 浏览器将System.out 的输出信息写到Javalog.txt 文件中。（在IE 选项对话框的高级页面中选择起用 Java Logging。）\n\n编译并运行该 Applet。然后，等待 Applet 运行（你将在状态栏中看到 Applet 已启动的信息），退出浏览器，并打开Javalog.txt 文件。你将会发现类似于下列行的信息：\n\n1000 things constructed\n\n0 things finalized\n\n正如你能够看到的那样，建立了1,000个对象仍然没有迫使垃圾回收器开始回收空间，即使在 Applet 退出时也没有对象被使用。\n\n现在，删除在stop() 方法第一行中的注释符以起用System.gc() 方法。再次编译并运行该 Applet ，等待 Applet 完成运行，并退出浏览器。当你再次打开Javalog.txt 文件，你将看到下列行：\n\n1000 things constructed\n\n963 things finalized\n\n这次，垃圾回收器认为大多数对象未被使用，并将它们回收。按顺序，当垃圾回收器开始释放这些对象的内存时，JVM 调用它们的finalize() 方法。\n\n继承finalize()?\n\n顺便，如果你在类中定义了finalize() ，它将不会自动调用基类中的方法。在我们讨论了finalize() 与 C++ 的析构函数的不同点后，对这个结论不会惊讶，因为为某个类定制的清除代码另一个类不一定会需要。\n\n如果你决定要通过派生一个类的finalize() 方法来调用基类中的finalize() 方法，你可以象其他继承方法一样处理。\n```java\nprotected void finalize()\n\n{\n\nsuper.finalize();\n\n// other finalization code...\n\n}\n```\n除了允许你控制是否执行清除操作外，这个技术还使你可以控制当前类的finalize() 方法何时执行。\n\n结论\n\n然而有益的是，Java 的自动垃圾回收器不会失去平衡。作为便利的代价，你不得不放弃对系统资源释放的控制。不象 C++ 中的析构函数，Java Applet 不会自动执行你的类中的finalize() 方法。事实上，如果你正在使用 Java 1.0，即使你试图强制它调用finalize() 方法，也不能确保将调用它。\n\n因此，你不应当依靠finalize() 来执行你的 Applet 和应用程序的资源清除工作。取而代之，你应当明确的清除那些资源或创建一个try...finally 块（或类似的机制）来实现。\n\n[view plain](http://blog.csdn.net/lclai/article/details/4458031# \"view plain\")\n\n[copy](http://blog.csdn.net/lclai/article/details/4458031# \"copy\")\n\n[http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf](http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf)\n\n```java\n1.  import java.applet.*;\n2.  import java.awt.*;\n3.  class thing\n4.  {\n5.    public static int thingcount = 0;\n6.    public static int thingfinal = 0;\n7.    public thing()\n8.    {\n9.      ++thingcount;\n10.    }\n11.    protected void finalize()\n12.    {\n13.      ++thingfinal;\n14.    }\n15.  }\n16.  public class final_things extends Applet\n17.  {\n18.    public final_things()\n19.    {\n20.    }\n21.    public String getAppletInfo()\n22.    {\n23.      return \"Name: final_thing/r/n\" +\n24.             \"Author: Tim Gooch/r/n\" +\n25.             \"Created with Microsoft \" +\n26.             \"Visual J++ Version 1.1\";\n27.    }\n28.    public void init()\n29.    {\n30.        resize(320, 240);\n31.    }\n32.    public void destroy()\n33.    {\n34.    }\n35.    public void paint(Graphics g)\n36.    {\n37.      g.drawString(\"Created with Microsoft\" +\n38.        \"Visual J++ Version 1.1\", 10, 20);\n39.    }\n40.    public void start()\n41.    {\n42.      while(thing.thingfinal > 1)\n43.      {\n44.        new thing();\n45.      }\n46.    }\n47.    public void stop()\n48.    {\n49.      // System.gc();\n50.      System.out.println(thing.thingcount +\n51.        \" things constructed\");\n52.      System.out.println(thing.thingfinal +\n53.        \" things finalized\");\n54.    }\n55.  }\n```","source":"_posts/JavaObjectRelease.md","raw":"---\ntitle: 【转】Java中的对象释放问题\ntags:\n  - Java\nid: 16\ncategories:\n  - Java\ndate: 2015-03-07 15:31:03\n---\n# 【转】Java中的对象释放问题\n\n许多方面，Java 类似于 C++。Java 的语法非常类似于 C++，Java 有类、方法和数据成员；Java 的类有构造函数； Java 有异常处理。\n\n但是，如果你使用过 C++ 会发现 Java 也丢掉一些可能是你熟悉的特性。这些特性之一就是析构函数。取代使用析构函数，Java 支持finalize() 方法。\n\n在本文中，我们将描述 finalize() 与 C++ 析构函数的区别。另外，我们将创建一个简单的 Applet 来演示 finalize() 是如何工作的。\n\n最终的界限\n\n与 Java 不同，C++ 支持局部对象（基于栈）和全局对象（基于堆）。因为这一双重支持，C++ 也提供了自动构造和析构，这导致了对构造函数和析构函数的调用，（对于堆对象）就是内存的分配和释放。\n\n在 Java 中，所有对象都驻留在堆内存，因此局部对象就不存在。结果，Java 的设计者觉得不需要析构函数（象 C++ 中所实现的）。\n\n取而代之，Java 定义了一个特殊的方法叫做finalize() ，它提供了 C++ 析构函数的一些功能。但是，finalize() 并不完全与 C++ 的析构函数一样，并可以假设它会导致一系列的问题。finalize() 方法作用的一个关键元素是 Java 的垃圾回收器。\n\n垃圾回收器\n\n在 C/C++、Pascal和其他几种多种用途的编程语言中，开发者有责任在内存管理上发挥积极的作用。例如，如果你为一个对象或数据结构分配了内存，那么当你不再使用它时必须释放掉该内存。\n\n在 Java 中，当你创建一个对象时，Java 虚拟机（JVM）为该对象分配内存、调用构造函数并开始跟踪你使用的对象。当你停止使用一个对象（就是说，当没有对该对象有效的引用时），JVM 通过垃圾回收器将该对象标记为释放状态。\n\n当垃圾回收器将要释放一个对象的内存时，它调用该对象的finalize() 方法（如果该对象定义了此方法）。垃圾回收器以独立的低优先级的方式运行，只有当其他线程挂起等待该内存释放的情况出现时，它才开始运行释放对象的内 存。（事实上，你可以调用System.gc() 方法强制垃圾回收器来释放这些对象的内存。）\n\n在以上的描述中，有一些重要的事情需要注意。首先，只有当垃圾回收器释放该对象的内存时，才会执行finalize()。如果在 Applet 或应用程序退出之前垃圾回收器没有释放内存，垃圾回收器将不会调用finalize()。\n\n其次，除非垃圾回收器认为你的 Applet 或应用程序需要额外的内存，否则它不会试图释放不再使用的对象的内存。换句话说，这是完全可能的：一个 Applet 给少量的对象分配内存，没有造成严重的内存需求，于是垃圾回收器没有释放这些对象的内存就退出了。\n\n显然，如果你为某个对象定义了finalize() 方法，JVM 可能不会调用它，因为垃圾回收器不曾释放过那些对象的内存。调用System.gc() 也不会起作用，因为它仅仅是给 JVM 一个建议而不是命令。\n\nfinalize() 有什么优点呢？\n\n如果finalize() 不是析构函数，JVM 不一定会调用它，你可能会疑惑它是否在任何情况下都有好处。事实上，在 Java 1.0 中它并没有太多的优点。\n\n根据 Java 文档，finalize() 是一个用于释放非 Java 资源的方法。但是，JVM 有很大的可能不调用对象的finalize() 方法，因此很难证明使用该方法释放资源是有效的。\n\nJava 1.1 通过提供一个System.runFinalizersOnExit() 方法部分地解决了这个问题。（不要将这个方法与 Java 1.0 中的System.runFinalizations() 方法相混淆。）不象System.gc() 方法那样，System.runFinalizersOnExit() 方法并不立即试图启动垃圾回收器。而是当应用程序或 Applet 退出时，它调用每个对象的finalize() 方法。\n\n正如你可能猜测的那样，通过调用System.runFinalizersOnExit() 方法强制垃圾回收器清除所有独立对象的内存，当清除代码执行时可能会引起明显的延迟。现在建立一个示例 Applet 来演示 Java 垃圾回收器和finalize() 方法是如何相互作用的。\n\n回收垃圾\n\n通过使用Java Applet Wizard 创建一个新的 Applet 开始。当提示这样做时，输入 final_things 作为 Applet 名，并选择不要生成源文件注释。\n\n接下来，在Java Applet Wizard 进行第三步，不要选择多线程选项。在第五步之前，根据需要修改 Applet 的描述。\n\n当你单击Finish 后，Applet Wizard 将生成一个新的工作空间，并为该项目创建缺省的 Java 文件。从列表 A 中选择适当的代码输入（我们已经突出显示了你需要输入的代码）。\n\n当你完成代码的输入后，配置Internet 浏览器将System.out 的输出信息写到Javalog.txt 文件中。（在IE 选项对话框的高级页面中选择起用 Java Logging。）\n\n编译并运行该 Applet。然后，等待 Applet 运行（你将在状态栏中看到 Applet 已启动的信息），退出浏览器，并打开Javalog.txt 文件。你将会发现类似于下列行的信息：\n\n1000 things constructed\n\n0 things finalized\n\n正如你能够看到的那样，建立了1,000个对象仍然没有迫使垃圾回收器开始回收空间，即使在 Applet 退出时也没有对象被使用。\n\n现在，删除在stop() 方法第一行中的注释符以起用System.gc() 方法。再次编译并运行该 Applet ，等待 Applet 完成运行，并退出浏览器。当你再次打开Javalog.txt 文件，你将看到下列行：\n\n1000 things constructed\n\n963 things finalized\n\n这次，垃圾回收器认为大多数对象未被使用，并将它们回收。按顺序，当垃圾回收器开始释放这些对象的内存时，JVM 调用它们的finalize() 方法。\n\n继承finalize()?\n\n顺便，如果你在类中定义了finalize() ，它将不会自动调用基类中的方法。在我们讨论了finalize() 与 C++ 的析构函数的不同点后，对这个结论不会惊讶，因为为某个类定制的清除代码另一个类不一定会需要。\n\n如果你决定要通过派生一个类的finalize() 方法来调用基类中的finalize() 方法，你可以象其他继承方法一样处理。\n```java\nprotected void finalize()\n\n{\n\nsuper.finalize();\n\n// other finalization code...\n\n}\n```\n除了允许你控制是否执行清除操作外，这个技术还使你可以控制当前类的finalize() 方法何时执行。\n\n结论\n\n然而有益的是，Java 的自动垃圾回收器不会失去平衡。作为便利的代价，你不得不放弃对系统资源释放的控制。不象 C++ 中的析构函数，Java Applet 不会自动执行你的类中的finalize() 方法。事实上，如果你正在使用 Java 1.0，即使你试图强制它调用finalize() 方法，也不能确保将调用它。\n\n因此，你不应当依靠finalize() 来执行你的 Applet 和应用程序的资源清除工作。取而代之，你应当明确的清除那些资源或创建一个try...finally 块（或类似的机制）来实现。\n\n[view plain](http://blog.csdn.net/lclai/article/details/4458031# \"view plain\")\n\n[copy](http://blog.csdn.net/lclai/article/details/4458031# \"copy\")\n\n[http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf](http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf)\n\n```java\n1.  import java.applet.*;\n2.  import java.awt.*;\n3.  class thing\n4.  {\n5.    public static int thingcount = 0;\n6.    public static int thingfinal = 0;\n7.    public thing()\n8.    {\n9.      ++thingcount;\n10.    }\n11.    protected void finalize()\n12.    {\n13.      ++thingfinal;\n14.    }\n15.  }\n16.  public class final_things extends Applet\n17.  {\n18.    public final_things()\n19.    {\n20.    }\n21.    public String getAppletInfo()\n22.    {\n23.      return \"Name: final_thing/r/n\" +\n24.             \"Author: Tim Gooch/r/n\" +\n25.             \"Created with Microsoft \" +\n26.             \"Visual J++ Version 1.1\";\n27.    }\n28.    public void init()\n29.    {\n30.        resize(320, 240);\n31.    }\n32.    public void destroy()\n33.    {\n34.    }\n35.    public void paint(Graphics g)\n36.    {\n37.      g.drawString(\"Created with Microsoft\" +\n38.        \"Visual J++ Version 1.1\", 10, 20);\n39.    }\n40.    public void start()\n41.    {\n42.      while(thing.thingfinal > 1)\n43.      {\n44.        new thing();\n45.      }\n46.    }\n47.    public void stop()\n48.    {\n49.      // System.gc();\n50.      System.out.println(thing.thingcount +\n51.        \" things constructed\");\n52.      System.out.println(thing.thingfinal +\n53.        \" things finalized\");\n54.    }\n55.  }\n```","slug":"JavaObjectRelease","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1h001wlkguroibsjmz","content":"<h1 id=\"【转】Java中的对象释放问题\"><a href=\"#【转】Java中的对象释放问题\" class=\"headerlink\" title=\"【转】Java中的对象释放问题\"></a>【转】Java中的对象释放问题</h1><p>许多方面，Java 类似于 C++。Java 的语法非常类似于 C++，Java 有类、方法和数据成员；Java 的类有构造函数； Java 有异常处理。</p>\n<p>但是，如果你使用过 C++ 会发现 Java 也丢掉一些可能是你熟悉的特性。这些特性之一就是析构函数。取代使用析构函数，Java 支持finalize() 方法。</p>\n<p>在本文中，我们将描述 finalize() 与 C++ 析构函数的区别。另外，我们将创建一个简单的 Applet 来演示 finalize() 是如何工作的。</p>\n<p>最终的界限</p>\n<p>与 Java 不同，C++ 支持局部对象（基于栈）和全局对象（基于堆）。因为这一双重支持，C++ 也提供了自动构造和析构，这导致了对构造函数和析构函数的调用，（对于堆对象）就是内存的分配和释放。</p>\n<p>在 Java 中，所有对象都驻留在堆内存，因此局部对象就不存在。结果，Java 的设计者觉得不需要析构函数（象 C++ 中所实现的）。</p>\n<p>取而代之，Java 定义了一个特殊的方法叫做finalize() ，它提供了 C++ 析构函数的一些功能。但是，finalize() 并不完全与 C++ 的析构函数一样，并可以假设它会导致一系列的问题。finalize() 方法作用的一个关键元素是 Java 的垃圾回收器。</p>\n<p>垃圾回收器</p>\n<p>在 C/C++、Pascal和其他几种多种用途的编程语言中，开发者有责任在内存管理上发挥积极的作用。例如，如果你为一个对象或数据结构分配了内存，那么当你不再使用它时必须释放掉该内存。</p>\n<p>在 Java 中，当你创建一个对象时，Java 虚拟机（JVM）为该对象分配内存、调用构造函数并开始跟踪你使用的对象。当你停止使用一个对象（就是说，当没有对该对象有效的引用时），JVM 通过垃圾回收器将该对象标记为释放状态。</p>\n<p>当垃圾回收器将要释放一个对象的内存时，它调用该对象的finalize() 方法（如果该对象定义了此方法）。垃圾回收器以独立的低优先级的方式运行，只有当其他线程挂起等待该内存释放的情况出现时，它才开始运行释放对象的内 存。（事实上，你可以调用System.gc() 方法强制垃圾回收器来释放这些对象的内存。）</p>\n<p>在以上的描述中，有一些重要的事情需要注意。首先，只有当垃圾回收器释放该对象的内存时，才会执行finalize()。如果在 Applet 或应用程序退出之前垃圾回收器没有释放内存，垃圾回收器将不会调用finalize()。</p>\n<p>其次，除非垃圾回收器认为你的 Applet 或应用程序需要额外的内存，否则它不会试图释放不再使用的对象的内存。换句话说，这是完全可能的：一个 Applet 给少量的对象分配内存，没有造成严重的内存需求，于是垃圾回收器没有释放这些对象的内存就退出了。</p>\n<p>显然，如果你为某个对象定义了finalize() 方法，JVM 可能不会调用它，因为垃圾回收器不曾释放过那些对象的内存。调用System.gc() 也不会起作用，因为它仅仅是给 JVM 一个建议而不是命令。</p>\n<p>finalize() 有什么优点呢？</p>\n<p>如果finalize() 不是析构函数，JVM 不一定会调用它，你可能会疑惑它是否在任何情况下都有好处。事实上，在 Java 1.0 中它并没有太多的优点。</p>\n<p>根据 Java 文档，finalize() 是一个用于释放非 Java 资源的方法。但是，JVM 有很大的可能不调用对象的finalize() 方法，因此很难证明使用该方法释放资源是有效的。</p>\n<p>Java 1.1 通过提供一个System.runFinalizersOnExit() 方法部分地解决了这个问题。（不要将这个方法与 Java 1.0 中的System.runFinalizations() 方法相混淆。）不象System.gc() 方法那样，System.runFinalizersOnExit() 方法并不立即试图启动垃圾回收器。而是当应用程序或 Applet 退出时，它调用每个对象的finalize() 方法。</p>\n<p>正如你可能猜测的那样，通过调用System.runFinalizersOnExit() 方法强制垃圾回收器清除所有独立对象的内存，当清除代码执行时可能会引起明显的延迟。现在建立一个示例 Applet 来演示 Java 垃圾回收器和finalize() 方法是如何相互作用的。</p>\n<p>回收垃圾</p>\n<p>通过使用Java Applet Wizard 创建一个新的 Applet 开始。当提示这样做时，输入 final_things 作为 Applet 名，并选择不要生成源文件注释。</p>\n<p>接下来，在Java Applet Wizard 进行第三步，不要选择多线程选项。在第五步之前，根据需要修改 Applet 的描述。</p>\n<p>当你单击Finish 后，Applet Wizard 将生成一个新的工作空间，并为该项目创建缺省的 Java 文件。从列表 A 中选择适当的代码输入（我们已经突出显示了你需要输入的代码）。</p>\n<p>当你完成代码的输入后，配置Internet 浏览器将System.out 的输出信息写到Javalog.txt 文件中。（在IE 选项对话框的高级页面中选择起用 Java Logging。）</p>\n<p>编译并运行该 Applet。然后，等待 Applet 运行（你将在状态栏中看到 Applet 已启动的信息），退出浏览器，并打开Javalog.txt 文件。你将会发现类似于下列行的信息：</p>\n<p>1000 things constructed</p>\n<p>0 things finalized</p>\n<p>正如你能够看到的那样，建立了1,000个对象仍然没有迫使垃圾回收器开始回收空间，即使在 Applet 退出时也没有对象被使用。</p>\n<p>现在，删除在stop() 方法第一行中的注释符以起用System.gc() 方法。再次编译并运行该 Applet ，等待 Applet 完成运行，并退出浏览器。当你再次打开Javalog.txt 文件，你将看到下列行：</p>\n<p>1000 things constructed</p>\n<p>963 things finalized</p>\n<p>这次，垃圾回收器认为大多数对象未被使用，并将它们回收。按顺序，当垃圾回收器开始释放这些对象的内存时，JVM 调用它们的finalize() 方法。</p>\n<p>继承finalize()?</p>\n<p>顺便，如果你在类中定义了finalize() ，它将不会自动调用基类中的方法。在我们讨论了finalize() 与 C++ 的析构函数的不同点后，对这个结论不会惊讶，因为为某个类定制的清除代码另一个类不一定会需要。</p>\n<p>如果你决定要通过派生一个类的finalize() 方法来调用基类中的finalize() 方法，你可以象其他继承方法一样处理。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// other finalization code...</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了允许你控制是否执行清除操作外，这个技术还使你可以控制当前类的finalize() 方法何时执行。</p>\n<p>结论</p>\n<p>然而有益的是，Java 的自动垃圾回收器不会失去平衡。作为便利的代价，你不得不放弃对系统资源释放的控制。不象 C++ 中的析构函数，Java Applet 不会自动执行你的类中的finalize() 方法。事实上，如果你正在使用 Java 1.0，即使你试图强制它调用finalize() 方法，也不能确保将调用它。</p>\n<p>因此，你不应当依靠finalize() 来执行你的 Applet 和应用程序的资源清除工作。取而代之，你应当明确的清除那些资源或创建一个try…finally 块（或类似的机制）来实现。</p>\n<p><a href=\"http://blog.csdn.net/lclai/article/details/4458031#\" title=\"view plain\" target=\"_blank\" rel=\"noopener\">view plain</a></p>\n<p><a href=\"http://blog.csdn.net/lclai/article/details/4458031#\" title=\"copy\" target=\"_blank\" rel=\"noopener\">copy</a></p>\n<p><a href=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" target=\"_blank\" rel=\"noopener\">http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>.  <span class=\"keyword\">import</span> java.applet.*;</span><br><span class=\"line\"><span class=\"number\">2</span>.  <span class=\"keyword\">import</span> java.awt.*;</span><br><span class=\"line\"><span class=\"number\">3</span>.  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">thing</span></span></span><br><span class=\"line\"><span class=\"class\">4.  </span>&#123;</span><br><span class=\"line\"><span class=\"number\">5</span>.    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> thingcount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">6</span>.    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> thingfinal = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">7</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">thing</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">8.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">9</span>.      ++thingcount;</span><br><span class=\"line\"><span class=\"number\">10</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">11</span>.    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">12.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">13</span>.      ++thingfinal;</span><br><span class=\"line\"><span class=\"number\">14</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">15</span>.  &#125;</span><br><span class=\"line\"><span class=\"number\">16</span>.  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">final_things</span> <span class=\"keyword\">extends</span> <span class=\"title\">Applet</span></span></span><br><span class=\"line\"><span class=\"class\">17.  </span>&#123;</span><br><span class=\"line\"><span class=\"number\">18</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">final_things</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">19.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">20</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">21</span>.    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAppletInfo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">22.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">23</span>.      <span class=\"keyword\">return</span> <span class=\"string\">\"Name: final_thing/r/n\"</span> +</span><br><span class=\"line\"><span class=\"number\">24</span>.             <span class=\"string\">\"Author: Tim Gooch/r/n\"</span> +</span><br><span class=\"line\"><span class=\"number\">25</span>.             <span class=\"string\">\"Created with Microsoft \"</span> +</span><br><span class=\"line\"><span class=\"number\">26</span>.             <span class=\"string\">\"Visual J++ Version 1.1\"</span>;</span><br><span class=\"line\"><span class=\"number\">27</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">28</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">29.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">30</span>.        resize(<span class=\"number\">320</span>, <span class=\"number\">240</span>);</span><br><span class=\"line\"><span class=\"number\">31</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">32</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">33.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">34</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">35</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">paint</span><span class=\"params\">(Graphics g)</span></span></span><br><span class=\"line\"><span class=\"function\">36.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">37</span>.      g.drawString(<span class=\"string\">\"Created with Microsoft\"</span> +</span><br><span class=\"line\"><span class=\"number\">38</span>.        <span class=\"string\">\"Visual J++ Version 1.1\"</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"number\">39</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">40</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">41.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">42</span>.      <span class=\"keyword\">while</span>(thing.thingfinal &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"number\">43</span>.      &#123;</span><br><span class=\"line\"><span class=\"number\">44</span>.        <span class=\"keyword\">new</span> thing();</span><br><span class=\"line\"><span class=\"number\">45</span>.      &#125;</span><br><span class=\"line\"><span class=\"number\">46</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">47</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">48.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">49</span>.      <span class=\"comment\">// System.gc();</span></span><br><span class=\"line\"><span class=\"number\">50</span>.      System.out.println(thing.thingcount +</span><br><span class=\"line\"><span class=\"number\">51</span>.        <span class=\"string\">\" things constructed\"</span>);</span><br><span class=\"line\"><span class=\"number\">52</span>.      System.out.println(thing.thingfinal +</span><br><span class=\"line\"><span class=\"number\">53</span>.        <span class=\"string\">\" things finalized\"</span>);</span><br><span class=\"line\"><span class=\"number\">54</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">55</span>.  &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"【转】Java中的对象释放问题\"><a href=\"#【转】Java中的对象释放问题\" class=\"headerlink\" title=\"【转】Java中的对象释放问题\"></a>【转】Java中的对象释放问题</h1><p>许多方面，Java 类似于 C++。Java 的语法非常类似于 C++，Java 有类、方法和数据成员；Java 的类有构造函数； Java 有异常处理。</p>\n<p>但是，如果你使用过 C++ 会发现 Java 也丢掉一些可能是你熟悉的特性。这些特性之一就是析构函数。取代使用析构函数，Java 支持finalize() 方法。</p>\n<p>在本文中，我们将描述 finalize() 与 C++ 析构函数的区别。另外，我们将创建一个简单的 Applet 来演示 finalize() 是如何工作的。</p>\n<p>最终的界限</p>\n<p>与 Java 不同，C++ 支持局部对象（基于栈）和全局对象（基于堆）。因为这一双重支持，C++ 也提供了自动构造和析构，这导致了对构造函数和析构函数的调用，（对于堆对象）就是内存的分配和释放。</p>\n<p>在 Java 中，所有对象都驻留在堆内存，因此局部对象就不存在。结果，Java 的设计者觉得不需要析构函数（象 C++ 中所实现的）。</p>\n<p>取而代之，Java 定义了一个特殊的方法叫做finalize() ，它提供了 C++ 析构函数的一些功能。但是，finalize() 并不完全与 C++ 的析构函数一样，并可以假设它会导致一系列的问题。finalize() 方法作用的一个关键元素是 Java 的垃圾回收器。</p>\n<p>垃圾回收器</p>\n<p>在 C/C++、Pascal和其他几种多种用途的编程语言中，开发者有责任在内存管理上发挥积极的作用。例如，如果你为一个对象或数据结构分配了内存，那么当你不再使用它时必须释放掉该内存。</p>\n<p>在 Java 中，当你创建一个对象时，Java 虚拟机（JVM）为该对象分配内存、调用构造函数并开始跟踪你使用的对象。当你停止使用一个对象（就是说，当没有对该对象有效的引用时），JVM 通过垃圾回收器将该对象标记为释放状态。</p>\n<p>当垃圾回收器将要释放一个对象的内存时，它调用该对象的finalize() 方法（如果该对象定义了此方法）。垃圾回收器以独立的低优先级的方式运行，只有当其他线程挂起等待该内存释放的情况出现时，它才开始运行释放对象的内 存。（事实上，你可以调用System.gc() 方法强制垃圾回收器来释放这些对象的内存。）</p>\n<p>在以上的描述中，有一些重要的事情需要注意。首先，只有当垃圾回收器释放该对象的内存时，才会执行finalize()。如果在 Applet 或应用程序退出之前垃圾回收器没有释放内存，垃圾回收器将不会调用finalize()。</p>\n<p>其次，除非垃圾回收器认为你的 Applet 或应用程序需要额外的内存，否则它不会试图释放不再使用的对象的内存。换句话说，这是完全可能的：一个 Applet 给少量的对象分配内存，没有造成严重的内存需求，于是垃圾回收器没有释放这些对象的内存就退出了。</p>\n<p>显然，如果你为某个对象定义了finalize() 方法，JVM 可能不会调用它，因为垃圾回收器不曾释放过那些对象的内存。调用System.gc() 也不会起作用，因为它仅仅是给 JVM 一个建议而不是命令。</p>\n<p>finalize() 有什么优点呢？</p>\n<p>如果finalize() 不是析构函数，JVM 不一定会调用它，你可能会疑惑它是否在任何情况下都有好处。事实上，在 Java 1.0 中它并没有太多的优点。</p>\n<p>根据 Java 文档，finalize() 是一个用于释放非 Java 资源的方法。但是，JVM 有很大的可能不调用对象的finalize() 方法，因此很难证明使用该方法释放资源是有效的。</p>\n<p>Java 1.1 通过提供一个System.runFinalizersOnExit() 方法部分地解决了这个问题。（不要将这个方法与 Java 1.0 中的System.runFinalizations() 方法相混淆。）不象System.gc() 方法那样，System.runFinalizersOnExit() 方法并不立即试图启动垃圾回收器。而是当应用程序或 Applet 退出时，它调用每个对象的finalize() 方法。</p>\n<p>正如你可能猜测的那样，通过调用System.runFinalizersOnExit() 方法强制垃圾回收器清除所有独立对象的内存，当清除代码执行时可能会引起明显的延迟。现在建立一个示例 Applet 来演示 Java 垃圾回收器和finalize() 方法是如何相互作用的。</p>\n<p>回收垃圾</p>\n<p>通过使用Java Applet Wizard 创建一个新的 Applet 开始。当提示这样做时，输入 final_things 作为 Applet 名，并选择不要生成源文件注释。</p>\n<p>接下来，在Java Applet Wizard 进行第三步，不要选择多线程选项。在第五步之前，根据需要修改 Applet 的描述。</p>\n<p>当你单击Finish 后，Applet Wizard 将生成一个新的工作空间，并为该项目创建缺省的 Java 文件。从列表 A 中选择适当的代码输入（我们已经突出显示了你需要输入的代码）。</p>\n<p>当你完成代码的输入后，配置Internet 浏览器将System.out 的输出信息写到Javalog.txt 文件中。（在IE 选项对话框的高级页面中选择起用 Java Logging。）</p>\n<p>编译并运行该 Applet。然后，等待 Applet 运行（你将在状态栏中看到 Applet 已启动的信息），退出浏览器，并打开Javalog.txt 文件。你将会发现类似于下列行的信息：</p>\n<p>1000 things constructed</p>\n<p>0 things finalized</p>\n<p>正如你能够看到的那样，建立了1,000个对象仍然没有迫使垃圾回收器开始回收空间，即使在 Applet 退出时也没有对象被使用。</p>\n<p>现在，删除在stop() 方法第一行中的注释符以起用System.gc() 方法。再次编译并运行该 Applet ，等待 Applet 完成运行，并退出浏览器。当你再次打开Javalog.txt 文件，你将看到下列行：</p>\n<p>1000 things constructed</p>\n<p>963 things finalized</p>\n<p>这次，垃圾回收器认为大多数对象未被使用，并将它们回收。按顺序，当垃圾回收器开始释放这些对象的内存时，JVM 调用它们的finalize() 方法。</p>\n<p>继承finalize()?</p>\n<p>顺便，如果你在类中定义了finalize() ，它将不会自动调用基类中的方法。在我们讨论了finalize() 与 C++ 的析构函数的不同点后，对这个结论不会惊讶，因为为某个类定制的清除代码另一个类不一定会需要。</p>\n<p>如果你决定要通过派生一个类的finalize() 方法来调用基类中的finalize() 方法，你可以象其他继承方法一样处理。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// other finalization code...</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了允许你控制是否执行清除操作外，这个技术还使你可以控制当前类的finalize() 方法何时执行。</p>\n<p>结论</p>\n<p>然而有益的是，Java 的自动垃圾回收器不会失去平衡。作为便利的代价，你不得不放弃对系统资源释放的控制。不象 C++ 中的析构函数，Java Applet 不会自动执行你的类中的finalize() 方法。事实上，如果你正在使用 Java 1.0，即使你试图强制它调用finalize() 方法，也不能确保将调用它。</p>\n<p>因此，你不应当依靠finalize() 来执行你的 Applet 和应用程序的资源清除工作。取而代之，你应当明确的清除那些资源或创建一个try…finally 块（或类似的机制）来实现。</p>\n<p><a href=\"http://blog.csdn.net/lclai/article/details/4458031#\" title=\"view plain\" target=\"_blank\" rel=\"noopener\">view plain</a></p>\n<p><a href=\"http://blog.csdn.net/lclai/article/details/4458031#\" title=\"copy\" target=\"_blank\" rel=\"noopener\">copy</a></p>\n<p><a href=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" target=\"_blank\" rel=\"noopener\">http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>.  <span class=\"keyword\">import</span> java.applet.*;</span><br><span class=\"line\"><span class=\"number\">2</span>.  <span class=\"keyword\">import</span> java.awt.*;</span><br><span class=\"line\"><span class=\"number\">3</span>.  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">thing</span></span></span><br><span class=\"line\"><span class=\"class\">4.  </span>&#123;</span><br><span class=\"line\"><span class=\"number\">5</span>.    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> thingcount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">6</span>.    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> thingfinal = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">7</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">thing</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">8.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">9</span>.      ++thingcount;</span><br><span class=\"line\"><span class=\"number\">10</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">11</span>.    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">12.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">13</span>.      ++thingfinal;</span><br><span class=\"line\"><span class=\"number\">14</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">15</span>.  &#125;</span><br><span class=\"line\"><span class=\"number\">16</span>.  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">final_things</span> <span class=\"keyword\">extends</span> <span class=\"title\">Applet</span></span></span><br><span class=\"line\"><span class=\"class\">17.  </span>&#123;</span><br><span class=\"line\"><span class=\"number\">18</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">final_things</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">19.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">20</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">21</span>.    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAppletInfo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">22.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">23</span>.      <span class=\"keyword\">return</span> <span class=\"string\">\"Name: final_thing/r/n\"</span> +</span><br><span class=\"line\"><span class=\"number\">24</span>.             <span class=\"string\">\"Author: Tim Gooch/r/n\"</span> +</span><br><span class=\"line\"><span class=\"number\">25</span>.             <span class=\"string\">\"Created with Microsoft \"</span> +</span><br><span class=\"line\"><span class=\"number\">26</span>.             <span class=\"string\">\"Visual J++ Version 1.1\"</span>;</span><br><span class=\"line\"><span class=\"number\">27</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">28</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">29.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">30</span>.        resize(<span class=\"number\">320</span>, <span class=\"number\">240</span>);</span><br><span class=\"line\"><span class=\"number\">31</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">32</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">33.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">34</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">35</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">paint</span><span class=\"params\">(Graphics g)</span></span></span><br><span class=\"line\"><span class=\"function\">36.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">37</span>.      g.drawString(<span class=\"string\">\"Created with Microsoft\"</span> +</span><br><span class=\"line\"><span class=\"number\">38</span>.        <span class=\"string\">\"Visual J++ Version 1.1\"</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"number\">39</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">40</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">41.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">42</span>.      <span class=\"keyword\">while</span>(thing.thingfinal &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"number\">43</span>.      &#123;</span><br><span class=\"line\"><span class=\"number\">44</span>.        <span class=\"keyword\">new</span> thing();</span><br><span class=\"line\"><span class=\"number\">45</span>.      &#125;</span><br><span class=\"line\"><span class=\"number\">46</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">47</span>.    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">48.    </span>&#123;</span><br><span class=\"line\"><span class=\"number\">49</span>.      <span class=\"comment\">// System.gc();</span></span><br><span class=\"line\"><span class=\"number\">50</span>.      System.out.println(thing.thingcount +</span><br><span class=\"line\"><span class=\"number\">51</span>.        <span class=\"string\">\" things constructed\"</span>);</span><br><span class=\"line\"><span class=\"number\">52</span>.      System.out.println(thing.thingfinal +</span><br><span class=\"line\"><span class=\"number\">53</span>.        <span class=\"string\">\" things finalized\"</span>);</span><br><span class=\"line\"><span class=\"number\">54</span>.    &#125;</span><br><span class=\"line\"><span class=\"number\">55</span>.  &#125;</span><br></pre></td></tr></table></figure>"},{"title":"[转]大总结：雅思听力答案的写法","id":"299","date":"2015-08-12T15:45:30.000Z","_content":"\n# [转]大总结：雅思听力答案的写法\n\n**For questions where the answers are letters or Roman numbers, you should write ONLY the number of answers required. For example, if the answer is a single letter or number, you should write only one answer. If you have written more letters or numerals than are required, the answer must be marked wrong.**\n\n什么意思呢？（哼，这个都看不懂，就不用去考雅思阅读了！！ [大总结：雅思听力答案的写法 By Danqi] ）\n\n好吧，还是解释一下。也就是说，如果答案要求的是英文单词，你就只能填单词；如果要求写数字，就只能填数字。否则就不给分！与此同时，还需要符合单词和数字的数量要求。\n\n数量要求这一点，也是相当纠结，我们单独拿出说。总的原则是过犹不及，in other words，如果要求写三个单词，你写了四个，即使上下文意思完全正确，语法也 perfect，考官还是会毫不留情的扣分 [大总结：雅思听力答案的写法 By Danqi] 。官方是这样描述的：\n\n**If you are asked to write an answer using a certain number of words and/or (a) number(s), you will be penalized if you exceed this. For example, if a question specifies an answer using NO MORE THAN THREE WORDS and the correct answer is black leather coat, the answer of coat of black leather is incorrect.**\n\n解释一下。比如，如果问题规定答案不能超过三个字，录音中如果出现的是 coat of black leather，你很老实的填了 coat of black leather，就错了。正确的答案应该是只有三个单词， black leather coat。Got it?\n\n雅思听力考试中，凡是填空类型的题目，在题目要求中都会用大写+黑体+斜体出现\n\nNO MORE THAN THREE WORDS AND/OR A NUMBER 的字样。怎么理解这个复杂的要求呢？其实这是三个要求：\n\n（1）不超过三个单词；\n\n（2）不超过一个数字；\n\n（3）最最最多不超过三个单词 + 一个数字\n\n同学们在誊写答案的时候，要仔细阅读每道题目的具体要求，不能自以为是。因为上文的字数要求是最熟悉的，而另外一些时候则会出现 no more than two words，或者 no more than a number，这些 exceptions 就很容易被忽略。在此，建议大家在读题的过程中，务必把题目要求中的字数要求划出来，避免低级错误。 [大总结：雅思听力答案的写法 By Danqi]\n\n那么，可能同学们就要问了。听力录音中要是真的出现了长、难短语，怎么去满足字数要求呢？以下是三个小窍门儿！\n\n第一、省略冠词\n\n像 form filling 和 note completion 等一类题目，不需要遵循严格语法格式和要求。如果录音中是 in the morning，完全可以誊写成 in morning。\n\n第二、A 介词 B 介词 C 结构 - CBA\n\n如果录音中是 a ball of string，可以写成 string ball。如果录音中是 a tour of the sites of London，可以写成 London sites tour。\n\n第三、连字符（hyphen）\n\n连字符的作用起码有两个。首先，凡是被连字符连起来的的几个词，都算一个。是不是有点绕？ [大总结：雅思听力答案的写法 By Danqi] 举个例子吧~ 录音中是 Preparing for IELTS is time and engergy consuming（ 准备雅思考试费时费力，有木有道出你的心声 [大总结：雅思听力答案的写法 By Danqi] ），如果你写成 time-and-engergy-consuming 就算一个字了。因此，可以有效的减少字数。\n\n其实，很多同学都很混乱，到底什么时候要加连字符呢？有时候，在做听力时，听到 door to door service，好开心耶，单词都简单，所以就写了 door to door service。Sorry，没分数 [大总结：雅思听力答案的写法 By Danqi] ~ 练习册后提供的答案是 door-to-door service。为什么呢？看好了哦~ Service 是名词，door to door 在没有加 hyphen 的时候是介词短语，不能修饰 service，加上以后，door-to-door 变成了形容词。同理，face-to-face interview，keep-fit center，drop-off site。\n\nAnswers maybe written in upper or lower case.\n\n答案大写、小写都接受！这条要求，对于那些永远记不住大写原则的同学们来说，真是 bless。什么意思呢？如果录音中听到了 三月，那么，在 answer sheet 上，你既可以写符合英语文法的首字母大写版的 March，也可以写全部字母都大写的 MARCH，两种都符合答案要求。\n\n\\*\\* 除非有特殊的要求，需要答案必须写 lower case（小写）！！对了， 小写的英文是 lower case， 大写怎么表达呢？除了这里的 upper case，还可以说 capital letter 或是 block letter，再或者，用动词形式，capitalize~\n\n\\*\\*In questions where you are expected to complete a gap, you should transfer only the necessary missing word(s) onto the answer sheet. For example,\n\nto complete in the, and the correct answer is morning, the answer in the morning would be incorrect. \\*\\*\n\n这条要求具体是个什么意思呢？如果是填空题，只需要把正确答案那部分写在答题纸上。比如，要填充 in the \\_\\_\\_\\_，正确答案应该是 morning，而你如果誊写了全部的三个字 in the morning，就算答错了！ [大总结：雅思听力答案的写法 By Danqi]\n\n与 新奇合作的前考官们明确表示，如果重复题目中的任何一个词，哪怕是一个小小的 a，the 这种，都会影响得分。 [大总结：雅思听力答案的写法 By Danqi] 例如，**\\_\\_**and**\\_\\_**，录音中念道 animals and plants，答题卡上只能写 animals plants，写了那个 and，就死了... [大总结：雅思听力答案的写法 By Danqi] 在此建议大家，誊写答案后，一定要检查答案是否重复了题目中的单词哟。切记！ [大总结：雅思听力答案的写法 By Danqi]\n\n来看下面一条要求：\n\n**All answers require correct spelling (including words in brackets).**\n\n所有答案必须拼写正确（包括括号中的词）。First of all，神马是 括号中的词啊？\n\n剑桥系列的听力答案中，经常会出现这样的情况：April (the) 18th，或者 put (it) together，再或者(the) best buy。这里的的 the， it， the 在誊答案的时候，是可有可无的，写不写都可以得分，但是如果选择写了，就必须拼写对！因为雅思 Listening 部分，几乎只要出现拼写错误，就不得分。\n\n不过，有没有看到我说的是 几乎？还是有一个例外滴~ 那就是，人名、地名的不拼写原则。换言之，如果答案是录音中没有拼写的人名或地名，只要你的答案符合读音规则，考官就可以接受的。比如，某男的名字叫做 Forest，写最靠谱的 森林当然最理想，实在拼成了有 double r 的 Forrest 也不会丢分。同理，Allen = Alen，Anna=Ana，Green = Grean。很愉快吧！\n\n虽然有点撞大运的意思，但还是要真心的建议同学们，在平时的学习中注意字母组合的认读。有时候，相同的字母组合会发不同的音（e.g. 字母组合 ou 在 pour，out，double，shoulder，soup，could 中的发音都不相同）；不同的字母组合却会发相同的音(e.g.字母组合 ie，ee，ea，ae，eo，oe，e，e，ey 等，都可以发/i:/的音）。\n\n当然，拼写中还包括单复数的问题。我们合作的考官通常建议大家，在不影响理解的情况下，两者均可。多年的教学经验（额，好酸的一句话...），我建议同学们务必先通过 context（上下文）判断用哪一种形式。比如：\\_\\_\\_\\_ are in danger of becoming extinct。这里的 be 动词是 are，填空处一定就要用复数。在无法判断的情况下，复数相对比较保险。因为在一般情况下，只要不是特指，英语中更习惯使用复数形式。\n\nBoth US and UK spellings are acceptable.\n\n包括雅思在内的不少英语考试中，单词的拼写一般都接受来不同英语国家的拼写习惯，即美式或英式拼写都接受。比如：colour=color，neighbour=neighbor， metre=meter，cheque=check。但是 手紧的考官有话说！建议大家在誊答案的时候，统一用某类拼写，最好不要英美混杂。比如：My favourite （英式）shopping center（美式）...这种句子两边不讨好~\n\n**All standard alternatives for numbers, dates and currencies are acceptable.**\n\n有的同学在录音中听到了 2.3 kilometer，看到问题问的是 How long is the tunnel？就孜孜不倦的去拼写 kilometer。不要当劳模好不好~ 浪费时间，而且很容易就错过下面一道题啦~ 雅思听力考试中，所有数字、日期、货币等的标准替代符号都是接受的！！\n\n雅思听力考试数字、日期、货币是常考点，在誊写这类答案时，既可以写成英语单词，也可以写成阿拉伯数字，或直接使用货币符号。例如，5 hours=5hrs，twelve=12，five percent=5%，July 18th 1988=7.18.1988，60 dollars=\\$60。\n\n值得注意的是，关于 money 的，单词要写在数字后，货币符号则要写在数字前。比如，10 dollars 或$10。明白？ [大总结：雅思听力答案的写法 By Danqi]  同学们要用巧劲，使用货币符号 + 阿拉伯数字就既省时间又省空间。再者，$10 只算一个数字，而 10 dollars 则算一个数字加一个单词。\n\n有的同学这时候就开始天马行空了~ 但是时间的分钟，比如 10 minutes 30 seconds，一定不能写成 10:30，只能写成 10.5 minutes。这是因为 10 feet 30 inches 在英语国家也可以写成是 10:30，会引起歧义。\n\n**All standard abbreviations are acceptable.**\n\n不会写联合国，不知道世界卫生组织的全称？没关系，雅思听力中所有标准缩写都被接受。这一条要求简直值得撒花庆祝！！\n\n关于缩写这个问题，雅思听力经常浮现。比如，地址的常考点 街道，就有多种说法吧，这里，Street=St，Road=Rd，Boulevard=Blvd，Avenue=Ave，Drive=Dr... 啊，突然就可以少背好几个单词呢 [大总结：雅思听力答案的写法 By Danqi]\n\n国际组织更是，United Nations=UN，United Nations Education Science and Culture Organization=UNESCO。社会和学术称谓亦然，Doctor=Dr，Professor=Prof。 [大总结：雅思听力答案的写法 By Danqi] 这里提醒一句，使用缩写的时候，拜托大家使用标准缩写，别使用自己的 懒惰版缩写，像 15 minutes 就不能写成 15m，因为这可能会与 15 米混淆。Got it?\n\n好啦，事到如今，雅思官方对听力答案书写要求的所有条款，就为各位童鞋解读完了~ 累史我了 [大总结：雅思听力答案的写法 By Danqi] 还不快谢谢我 [大总结：雅思听力答案的写法 By Danqi]\n","source":"_posts/IELTSListening.md","raw":"---\ntitle: \"[转]大总结：雅思听力答案的写法\"\nid: 299\ncategories: \n  - Others\ndate: 2015-08-12 11:45:30\ntags:\n---\n\n# [转]大总结：雅思听力答案的写法\n\n**For questions where the answers are letters or Roman numbers, you should write ONLY the number of answers required. For example, if the answer is a single letter or number, you should write only one answer. If you have written more letters or numerals than are required, the answer must be marked wrong.**\n\n什么意思呢？（哼，这个都看不懂，就不用去考雅思阅读了！！ [大总结：雅思听力答案的写法 By Danqi] ）\n\n好吧，还是解释一下。也就是说，如果答案要求的是英文单词，你就只能填单词；如果要求写数字，就只能填数字。否则就不给分！与此同时，还需要符合单词和数字的数量要求。\n\n数量要求这一点，也是相当纠结，我们单独拿出说。总的原则是过犹不及，in other words，如果要求写三个单词，你写了四个，即使上下文意思完全正确，语法也 perfect，考官还是会毫不留情的扣分 [大总结：雅思听力答案的写法 By Danqi] 。官方是这样描述的：\n\n**If you are asked to write an answer using a certain number of words and/or (a) number(s), you will be penalized if you exceed this. For example, if a question specifies an answer using NO MORE THAN THREE WORDS and the correct answer is black leather coat, the answer of coat of black leather is incorrect.**\n\n解释一下。比如，如果问题规定答案不能超过三个字，录音中如果出现的是 coat of black leather，你很老实的填了 coat of black leather，就错了。正确的答案应该是只有三个单词， black leather coat。Got it?\n\n雅思听力考试中，凡是填空类型的题目，在题目要求中都会用大写+黑体+斜体出现\n\nNO MORE THAN THREE WORDS AND/OR A NUMBER 的字样。怎么理解这个复杂的要求呢？其实这是三个要求：\n\n（1）不超过三个单词；\n\n（2）不超过一个数字；\n\n（3）最最最多不超过三个单词 + 一个数字\n\n同学们在誊写答案的时候，要仔细阅读每道题目的具体要求，不能自以为是。因为上文的字数要求是最熟悉的，而另外一些时候则会出现 no more than two words，或者 no more than a number，这些 exceptions 就很容易被忽略。在此，建议大家在读题的过程中，务必把题目要求中的字数要求划出来，避免低级错误。 [大总结：雅思听力答案的写法 By Danqi]\n\n那么，可能同学们就要问了。听力录音中要是真的出现了长、难短语，怎么去满足字数要求呢？以下是三个小窍门儿！\n\n第一、省略冠词\n\n像 form filling 和 note completion 等一类题目，不需要遵循严格语法格式和要求。如果录音中是 in the morning，完全可以誊写成 in morning。\n\n第二、A 介词 B 介词 C 结构 - CBA\n\n如果录音中是 a ball of string，可以写成 string ball。如果录音中是 a tour of the sites of London，可以写成 London sites tour。\n\n第三、连字符（hyphen）\n\n连字符的作用起码有两个。首先，凡是被连字符连起来的的几个词，都算一个。是不是有点绕？ [大总结：雅思听力答案的写法 By Danqi] 举个例子吧~ 录音中是 Preparing for IELTS is time and engergy consuming（ 准备雅思考试费时费力，有木有道出你的心声 [大总结：雅思听力答案的写法 By Danqi] ），如果你写成 time-and-engergy-consuming 就算一个字了。因此，可以有效的减少字数。\n\n其实，很多同学都很混乱，到底什么时候要加连字符呢？有时候，在做听力时，听到 door to door service，好开心耶，单词都简单，所以就写了 door to door service。Sorry，没分数 [大总结：雅思听力答案的写法 By Danqi] ~ 练习册后提供的答案是 door-to-door service。为什么呢？看好了哦~ Service 是名词，door to door 在没有加 hyphen 的时候是介词短语，不能修饰 service，加上以后，door-to-door 变成了形容词。同理，face-to-face interview，keep-fit center，drop-off site。\n\nAnswers maybe written in upper or lower case.\n\n答案大写、小写都接受！这条要求，对于那些永远记不住大写原则的同学们来说，真是 bless。什么意思呢？如果录音中听到了 三月，那么，在 answer sheet 上，你既可以写符合英语文法的首字母大写版的 March，也可以写全部字母都大写的 MARCH，两种都符合答案要求。\n\n\\*\\* 除非有特殊的要求，需要答案必须写 lower case（小写）！！对了， 小写的英文是 lower case， 大写怎么表达呢？除了这里的 upper case，还可以说 capital letter 或是 block letter，再或者，用动词形式，capitalize~\n\n\\*\\*In questions where you are expected to complete a gap, you should transfer only the necessary missing word(s) onto the answer sheet. For example,\n\nto complete in the, and the correct answer is morning, the answer in the morning would be incorrect. \\*\\*\n\n这条要求具体是个什么意思呢？如果是填空题，只需要把正确答案那部分写在答题纸上。比如，要填充 in the \\_\\_\\_\\_，正确答案应该是 morning，而你如果誊写了全部的三个字 in the morning，就算答错了！ [大总结：雅思听力答案的写法 By Danqi]\n\n与 新奇合作的前考官们明确表示，如果重复题目中的任何一个词，哪怕是一个小小的 a，the 这种，都会影响得分。 [大总结：雅思听力答案的写法 By Danqi] 例如，**\\_\\_**and**\\_\\_**，录音中念道 animals and plants，答题卡上只能写 animals plants，写了那个 and，就死了... [大总结：雅思听力答案的写法 By Danqi] 在此建议大家，誊写答案后，一定要检查答案是否重复了题目中的单词哟。切记！ [大总结：雅思听力答案的写法 By Danqi]\n\n来看下面一条要求：\n\n**All answers require correct spelling (including words in brackets).**\n\n所有答案必须拼写正确（包括括号中的词）。First of all，神马是 括号中的词啊？\n\n剑桥系列的听力答案中，经常会出现这样的情况：April (the) 18th，或者 put (it) together，再或者(the) best buy。这里的的 the， it， the 在誊答案的时候，是可有可无的，写不写都可以得分，但是如果选择写了，就必须拼写对！因为雅思 Listening 部分，几乎只要出现拼写错误，就不得分。\n\n不过，有没有看到我说的是 几乎？还是有一个例外滴~ 那就是，人名、地名的不拼写原则。换言之，如果答案是录音中没有拼写的人名或地名，只要你的答案符合读音规则，考官就可以接受的。比如，某男的名字叫做 Forest，写最靠谱的 森林当然最理想，实在拼成了有 double r 的 Forrest 也不会丢分。同理，Allen = Alen，Anna=Ana，Green = Grean。很愉快吧！\n\n虽然有点撞大运的意思，但还是要真心的建议同学们，在平时的学习中注意字母组合的认读。有时候，相同的字母组合会发不同的音（e.g. 字母组合 ou 在 pour，out，double，shoulder，soup，could 中的发音都不相同）；不同的字母组合却会发相同的音(e.g.字母组合 ie，ee，ea，ae，eo，oe，e，e，ey 等，都可以发/i:/的音）。\n\n当然，拼写中还包括单复数的问题。我们合作的考官通常建议大家，在不影响理解的情况下，两者均可。多年的教学经验（额，好酸的一句话...），我建议同学们务必先通过 context（上下文）判断用哪一种形式。比如：\\_\\_\\_\\_ are in danger of becoming extinct。这里的 be 动词是 are，填空处一定就要用复数。在无法判断的情况下，复数相对比较保险。因为在一般情况下，只要不是特指，英语中更习惯使用复数形式。\n\nBoth US and UK spellings are acceptable.\n\n包括雅思在内的不少英语考试中，单词的拼写一般都接受来不同英语国家的拼写习惯，即美式或英式拼写都接受。比如：colour=color，neighbour=neighbor， metre=meter，cheque=check。但是 手紧的考官有话说！建议大家在誊答案的时候，统一用某类拼写，最好不要英美混杂。比如：My favourite （英式）shopping center（美式）...这种句子两边不讨好~\n\n**All standard alternatives for numbers, dates and currencies are acceptable.**\n\n有的同学在录音中听到了 2.3 kilometer，看到问题问的是 How long is the tunnel？就孜孜不倦的去拼写 kilometer。不要当劳模好不好~ 浪费时间，而且很容易就错过下面一道题啦~ 雅思听力考试中，所有数字、日期、货币等的标准替代符号都是接受的！！\n\n雅思听力考试数字、日期、货币是常考点，在誊写这类答案时，既可以写成英语单词，也可以写成阿拉伯数字，或直接使用货币符号。例如，5 hours=5hrs，twelve=12，five percent=5%，July 18th 1988=7.18.1988，60 dollars=\\$60。\n\n值得注意的是，关于 money 的，单词要写在数字后，货币符号则要写在数字前。比如，10 dollars 或$10。明白？ [大总结：雅思听力答案的写法 By Danqi]  同学们要用巧劲，使用货币符号 + 阿拉伯数字就既省时间又省空间。再者，$10 只算一个数字，而 10 dollars 则算一个数字加一个单词。\n\n有的同学这时候就开始天马行空了~ 但是时间的分钟，比如 10 minutes 30 seconds，一定不能写成 10:30，只能写成 10.5 minutes。这是因为 10 feet 30 inches 在英语国家也可以写成是 10:30，会引起歧义。\n\n**All standard abbreviations are acceptable.**\n\n不会写联合国，不知道世界卫生组织的全称？没关系，雅思听力中所有标准缩写都被接受。这一条要求简直值得撒花庆祝！！\n\n关于缩写这个问题，雅思听力经常浮现。比如，地址的常考点 街道，就有多种说法吧，这里，Street=St，Road=Rd，Boulevard=Blvd，Avenue=Ave，Drive=Dr... 啊，突然就可以少背好几个单词呢 [大总结：雅思听力答案的写法 By Danqi]\n\n国际组织更是，United Nations=UN，United Nations Education Science and Culture Organization=UNESCO。社会和学术称谓亦然，Doctor=Dr，Professor=Prof。 [大总结：雅思听力答案的写法 By Danqi] 这里提醒一句，使用缩写的时候，拜托大家使用标准缩写，别使用自己的 懒惰版缩写，像 15 minutes 就不能写成 15m，因为这可能会与 15 米混淆。Got it?\n\n好啦，事到如今，雅思官方对听力答案书写要求的所有条款，就为各位童鞋解读完了~ 累史我了 [大总结：雅思听力答案的写法 By Danqi] 还不快谢谢我 [大总结：雅思听力答案的写法 By Danqi]\n","slug":"IELTSListening","published":1,"updated":"2019-02-12T00:38:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1h001zlkguwytra1zw","content":"<h1 id=\"转-大总结：雅思听力答案的写法\"><a href=\"#转-大总结：雅思听力答案的写法\" class=\"headerlink\" title=\"[转]大总结：雅思听力答案的写法\"></a>[转]大总结：雅思听力答案的写法</h1><p><strong>For questions where the answers are letters or Roman numbers, you should write ONLY the number of answers required. For example, if the answer is a single letter or number, you should write only one answer. If you have written more letters or numerals than are required, the answer must be marked wrong.</strong></p>\n<p>什么意思呢？（哼，这个都看不懂，就不用去考雅思阅读了！！ [大总结：雅思听力答案的写法 By Danqi] ）</p>\n<p>好吧，还是解释一下。也就是说，如果答案要求的是英文单词，你就只能填单词；如果要求写数字，就只能填数字。否则就不给分！与此同时，还需要符合单词和数字的数量要求。</p>\n<p>数量要求这一点，也是相当纠结，我们单独拿出说。总的原则是过犹不及，in other words，如果要求写三个单词，你写了四个，即使上下文意思完全正确，语法也 perfect，考官还是会毫不留情的扣分 [大总结：雅思听力答案的写法 By Danqi] 。官方是这样描述的：</p>\n<p><strong>If you are asked to write an answer using a certain number of words and/or (a) number(s), you will be penalized if you exceed this. For example, if a question specifies an answer using NO MORE THAN THREE WORDS and the correct answer is black leather coat, the answer of coat of black leather is incorrect.</strong></p>\n<p>解释一下。比如，如果问题规定答案不能超过三个字，录音中如果出现的是 coat of black leather，你很老实的填了 coat of black leather，就错了。正确的答案应该是只有三个单词， black leather coat。Got it?</p>\n<p>雅思听力考试中，凡是填空类型的题目，在题目要求中都会用大写+黑体+斜体出现</p>\n<p>NO MORE THAN THREE WORDS AND/OR A NUMBER 的字样。怎么理解这个复杂的要求呢？其实这是三个要求：</p>\n<p>（1）不超过三个单词；</p>\n<p>（2）不超过一个数字；</p>\n<p>（3）最最最多不超过三个单词 + 一个数字</p>\n<p>同学们在誊写答案的时候，要仔细阅读每道题目的具体要求，不能自以为是。因为上文的字数要求是最熟悉的，而另外一些时候则会出现 no more than two words，或者 no more than a number，这些 exceptions 就很容易被忽略。在此，建议大家在读题的过程中，务必把题目要求中的字数要求划出来，避免低级错误。 [大总结：雅思听力答案的写法 By Danqi]</p>\n<p>那么，可能同学们就要问了。听力录音中要是真的出现了长、难短语，怎么去满足字数要求呢？以下是三个小窍门儿！</p>\n<p>第一、省略冠词</p>\n<p>像 form filling 和 note completion 等一类题目，不需要遵循严格语法格式和要求。如果录音中是 in the morning，完全可以誊写成 in morning。</p>\n<p>第二、A 介词 B 介词 C 结构 - CBA</p>\n<p>如果录音中是 a ball of string，可以写成 string ball。如果录音中是 a tour of the sites of London，可以写成 London sites tour。</p>\n<p>第三、连字符（hyphen）</p>\n<p>连字符的作用起码有两个。首先，凡是被连字符连起来的的几个词，都算一个。是不是有点绕？ [大总结：雅思听力答案的写法 By Danqi] 举个例子吧~ 录音中是 Preparing for IELTS is time and engergy consuming（ 准备雅思考试费时费力，有木有道出你的心声 [大总结：雅思听力答案的写法 By Danqi] ），如果你写成 time-and-engergy-consuming 就算一个字了。因此，可以有效的减少字数。</p>\n<p>其实，很多同学都很混乱，到底什么时候要加连字符呢？有时候，在做听力时，听到 door to door service，好开心耶，单词都简单，所以就写了 door to door service。Sorry，没分数 [大总结：雅思听力答案的写法 By Danqi] ~ 练习册后提供的答案是 door-to-door service。为什么呢？看好了哦~ Service 是名词，door to door 在没有加 hyphen 的时候是介词短语，不能修饰 service，加上以后，door-to-door 变成了形容词。同理，face-to-face interview，keep-fit center，drop-off site。</p>\n<p>Answers maybe written in upper or lower case.</p>\n<p>答案大写、小写都接受！这条要求，对于那些永远记不住大写原则的同学们来说，真是 bless。什么意思呢？如果录音中听到了 三月，那么，在 answer sheet 上，你既可以写符合英语文法的首字母大写版的 March，也可以写全部字母都大写的 MARCH，两种都符合答案要求。</p>\n<p>** 除非有特殊的要求，需要答案必须写 lower case（小写）！！对了， 小写的英文是 lower case， 大写怎么表达呢？除了这里的 upper case，还可以说 capital letter 或是 block letter，再或者，用动词形式，capitalize~</p>\n<p>**In questions where you are expected to complete a gap, you should transfer only the necessary missing word(s) onto the answer sheet. For example,</p>\n<p>to complete in the, and the correct answer is morning, the answer in the morning would be incorrect. **</p>\n<p>这条要求具体是个什么意思呢？如果是填空题，只需要把正确答案那部分写在答题纸上。比如，要填充 in the ____，正确答案应该是 morning，而你如果誊写了全部的三个字 in the morning，就算答错了！ [大总结：雅思听力答案的写法 By Danqi]</p>\n<p>与 新奇合作的前考官们明确表示，如果重复题目中的任何一个词，哪怕是一个小小的 a，the 这种，都会影响得分。 [大总结：雅思听力答案的写法 By Danqi] 例如，<strong>__</strong>and<strong>__</strong>，录音中念道 animals and plants，答题卡上只能写 animals plants，写了那个 and，就死了… [大总结：雅思听力答案的写法 By Danqi] 在此建议大家，誊写答案后，一定要检查答案是否重复了题目中的单词哟。切记！ [大总结：雅思听力答案的写法 By Danqi]</p>\n<p>来看下面一条要求：</p>\n<p><strong>All answers require correct spelling (including words in brackets).</strong></p>\n<p>所有答案必须拼写正确（包括括号中的词）。First of all，神马是 括号中的词啊？</p>\n<p>剑桥系列的听力答案中，经常会出现这样的情况：April (the) 18th，或者 put (it) together，再或者(the) best buy。这里的的 the， it， the 在誊答案的时候，是可有可无的，写不写都可以得分，但是如果选择写了，就必须拼写对！因为雅思 Listening 部分，几乎只要出现拼写错误，就不得分。</p>\n<p>不过，有没有看到我说的是 几乎？还是有一个例外滴~ 那就是，人名、地名的不拼写原则。换言之，如果答案是录音中没有拼写的人名或地名，只要你的答案符合读音规则，考官就可以接受的。比如，某男的名字叫做 Forest，写最靠谱的 森林当然最理想，实在拼成了有 double r 的 Forrest 也不会丢分。同理，Allen = Alen，Anna=Ana，Green = Grean。很愉快吧！</p>\n<p>虽然有点撞大运的意思，但还是要真心的建议同学们，在平时的学习中注意字母组合的认读。有时候，相同的字母组合会发不同的音（e.g. 字母组合 ou 在 pour，out，double，shoulder，soup，could 中的发音都不相同）；不同的字母组合却会发相同的音(e.g.字母组合 ie，ee，ea，ae，eo，oe，e，e，ey 等，都可以发/i:/的音）。</p>\n<p>当然，拼写中还包括单复数的问题。我们合作的考官通常建议大家，在不影响理解的情况下，两者均可。多年的教学经验（额，好酸的一句话…），我建议同学们务必先通过 context（上下文）判断用哪一种形式。比如：____ are in danger of becoming extinct。这里的 be 动词是 are，填空处一定就要用复数。在无法判断的情况下，复数相对比较保险。因为在一般情况下，只要不是特指，英语中更习惯使用复数形式。</p>\n<p>Both US and UK spellings are acceptable.</p>\n<p>包括雅思在内的不少英语考试中，单词的拼写一般都接受来不同英语国家的拼写习惯，即美式或英式拼写都接受。比如：colour=color，neighbour=neighbor， metre=meter，cheque=check。但是 手紧的考官有话说！建议大家在誊答案的时候，统一用某类拼写，最好不要英美混杂。比如：My favourite （英式）shopping center（美式）…这种句子两边不讨好~</p>\n<p><strong>All standard alternatives for numbers, dates and currencies are acceptable.</strong></p>\n<p>有的同学在录音中听到了 2.3 kilometer，看到问题问的是 How long is the tunnel？就孜孜不倦的去拼写 kilometer。不要当劳模好不好~ 浪费时间，而且很容易就错过下面一道题啦~ 雅思听力考试中，所有数字、日期、货币等的标准替代符号都是接受的！！</p>\n<p>雅思听力考试数字、日期、货币是常考点，在誊写这类答案时，既可以写成英语单词，也可以写成阿拉伯数字，或直接使用货币符号。例如，5 hours=5hrs，twelve=12，five percent=5%，July 18th 1988=7.18.1988，60 dollars=\\$60。</p>\n<p>值得注意的是，关于 money 的，单词要写在数字后，货币符号则要写在数字前。比如，10 dollars 或$10。明白？ [大总结：雅思听力答案的写法 By Danqi]  同学们要用巧劲，使用货币符号 + 阿拉伯数字就既省时间又省空间。再者，$10 只算一个数字，而 10 dollars 则算一个数字加一个单词。</p>\n<p>有的同学这时候就开始天马行空了~ 但是时间的分钟，比如 10 minutes 30 seconds，一定不能写成 10:30，只能写成 10.5 minutes。这是因为 10 feet 30 inches 在英语国家也可以写成是 10:30，会引起歧义。</p>\n<p><strong>All standard abbreviations are acceptable.</strong></p>\n<p>不会写联合国，不知道世界卫生组织的全称？没关系，雅思听力中所有标准缩写都被接受。这一条要求简直值得撒花庆祝！！</p>\n<p>关于缩写这个问题，雅思听力经常浮现。比如，地址的常考点 街道，就有多种说法吧，这里，Street=St，Road=Rd，Boulevard=Blvd，Avenue=Ave，Drive=Dr… 啊，突然就可以少背好几个单词呢 [大总结：雅思听力答案的写法 By Danqi]</p>\n<p>国际组织更是，United Nations=UN，United Nations Education Science and Culture Organization=UNESCO。社会和学术称谓亦然，Doctor=Dr，Professor=Prof。 [大总结：雅思听力答案的写法 By Danqi] 这里提醒一句，使用缩写的时候，拜托大家使用标准缩写，别使用自己的 懒惰版缩写，像 15 minutes 就不能写成 15m，因为这可能会与 15 米混淆。Got it?</p>\n<p>好啦，事到如今，雅思官方对听力答案书写要求的所有条款，就为各位童鞋解读完了~ 累史我了 [大总结：雅思听力答案的写法 By Danqi] 还不快谢谢我 [大总结：雅思听力答案的写法 By Danqi]</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"转-大总结：雅思听力答案的写法\"><a href=\"#转-大总结：雅思听力答案的写法\" class=\"headerlink\" title=\"[转]大总结：雅思听力答案的写法\"></a>[转]大总结：雅思听力答案的写法</h1><p><strong>For questions where the answers are letters or Roman numbers, you should write ONLY the number of answers required. For example, if the answer is a single letter or number, you should write only one answer. If you have written more letters or numerals than are required, the answer must be marked wrong.</strong></p>\n<p>什么意思呢？（哼，这个都看不懂，就不用去考雅思阅读了！！ [大总结：雅思听力答案的写法 By Danqi] ）</p>\n<p>好吧，还是解释一下。也就是说，如果答案要求的是英文单词，你就只能填单词；如果要求写数字，就只能填数字。否则就不给分！与此同时，还需要符合单词和数字的数量要求。</p>\n<p>数量要求这一点，也是相当纠结，我们单独拿出说。总的原则是过犹不及，in other words，如果要求写三个单词，你写了四个，即使上下文意思完全正确，语法也 perfect，考官还是会毫不留情的扣分 [大总结：雅思听力答案的写法 By Danqi] 。官方是这样描述的：</p>\n<p><strong>If you are asked to write an answer using a certain number of words and/or (a) number(s), you will be penalized if you exceed this. For example, if a question specifies an answer using NO MORE THAN THREE WORDS and the correct answer is black leather coat, the answer of coat of black leather is incorrect.</strong></p>\n<p>解释一下。比如，如果问题规定答案不能超过三个字，录音中如果出现的是 coat of black leather，你很老实的填了 coat of black leather，就错了。正确的答案应该是只有三个单词， black leather coat。Got it?</p>\n<p>雅思听力考试中，凡是填空类型的题目，在题目要求中都会用大写+黑体+斜体出现</p>\n<p>NO MORE THAN THREE WORDS AND/OR A NUMBER 的字样。怎么理解这个复杂的要求呢？其实这是三个要求：</p>\n<p>（1）不超过三个单词；</p>\n<p>（2）不超过一个数字；</p>\n<p>（3）最最最多不超过三个单词 + 一个数字</p>\n<p>同学们在誊写答案的时候，要仔细阅读每道题目的具体要求，不能自以为是。因为上文的字数要求是最熟悉的，而另外一些时候则会出现 no more than two words，或者 no more than a number，这些 exceptions 就很容易被忽略。在此，建议大家在读题的过程中，务必把题目要求中的字数要求划出来，避免低级错误。 [大总结：雅思听力答案的写法 By Danqi]</p>\n<p>那么，可能同学们就要问了。听力录音中要是真的出现了长、难短语，怎么去满足字数要求呢？以下是三个小窍门儿！</p>\n<p>第一、省略冠词</p>\n<p>像 form filling 和 note completion 等一类题目，不需要遵循严格语法格式和要求。如果录音中是 in the morning，完全可以誊写成 in morning。</p>\n<p>第二、A 介词 B 介词 C 结构 - CBA</p>\n<p>如果录音中是 a ball of string，可以写成 string ball。如果录音中是 a tour of the sites of London，可以写成 London sites tour。</p>\n<p>第三、连字符（hyphen）</p>\n<p>连字符的作用起码有两个。首先，凡是被连字符连起来的的几个词，都算一个。是不是有点绕？ [大总结：雅思听力答案的写法 By Danqi] 举个例子吧~ 录音中是 Preparing for IELTS is time and engergy consuming（ 准备雅思考试费时费力，有木有道出你的心声 [大总结：雅思听力答案的写法 By Danqi] ），如果你写成 time-and-engergy-consuming 就算一个字了。因此，可以有效的减少字数。</p>\n<p>其实，很多同学都很混乱，到底什么时候要加连字符呢？有时候，在做听力时，听到 door to door service，好开心耶，单词都简单，所以就写了 door to door service。Sorry，没分数 [大总结：雅思听力答案的写法 By Danqi] ~ 练习册后提供的答案是 door-to-door service。为什么呢？看好了哦~ Service 是名词，door to door 在没有加 hyphen 的时候是介词短语，不能修饰 service，加上以后，door-to-door 变成了形容词。同理，face-to-face interview，keep-fit center，drop-off site。</p>\n<p>Answers maybe written in upper or lower case.</p>\n<p>答案大写、小写都接受！这条要求，对于那些永远记不住大写原则的同学们来说，真是 bless。什么意思呢？如果录音中听到了 三月，那么，在 answer sheet 上，你既可以写符合英语文法的首字母大写版的 March，也可以写全部字母都大写的 MARCH，两种都符合答案要求。</p>\n<p>** 除非有特殊的要求，需要答案必须写 lower case（小写）！！对了， 小写的英文是 lower case， 大写怎么表达呢？除了这里的 upper case，还可以说 capital letter 或是 block letter，再或者，用动词形式，capitalize~</p>\n<p>**In questions where you are expected to complete a gap, you should transfer only the necessary missing word(s) onto the answer sheet. For example,</p>\n<p>to complete in the, and the correct answer is morning, the answer in the morning would be incorrect. **</p>\n<p>这条要求具体是个什么意思呢？如果是填空题，只需要把正确答案那部分写在答题纸上。比如，要填充 in the ____，正确答案应该是 morning，而你如果誊写了全部的三个字 in the morning，就算答错了！ [大总结：雅思听力答案的写法 By Danqi]</p>\n<p>与 新奇合作的前考官们明确表示，如果重复题目中的任何一个词，哪怕是一个小小的 a，the 这种，都会影响得分。 [大总结：雅思听力答案的写法 By Danqi] 例如，<strong>__</strong>and<strong>__</strong>，录音中念道 animals and plants，答题卡上只能写 animals plants，写了那个 and，就死了… [大总结：雅思听力答案的写法 By Danqi] 在此建议大家，誊写答案后，一定要检查答案是否重复了题目中的单词哟。切记！ [大总结：雅思听力答案的写法 By Danqi]</p>\n<p>来看下面一条要求：</p>\n<p><strong>All answers require correct spelling (including words in brackets).</strong></p>\n<p>所有答案必须拼写正确（包括括号中的词）。First of all，神马是 括号中的词啊？</p>\n<p>剑桥系列的听力答案中，经常会出现这样的情况：April (the) 18th，或者 put (it) together，再或者(the) best buy。这里的的 the， it， the 在誊答案的时候，是可有可无的，写不写都可以得分，但是如果选择写了，就必须拼写对！因为雅思 Listening 部分，几乎只要出现拼写错误，就不得分。</p>\n<p>不过，有没有看到我说的是 几乎？还是有一个例外滴~ 那就是，人名、地名的不拼写原则。换言之，如果答案是录音中没有拼写的人名或地名，只要你的答案符合读音规则，考官就可以接受的。比如，某男的名字叫做 Forest，写最靠谱的 森林当然最理想，实在拼成了有 double r 的 Forrest 也不会丢分。同理，Allen = Alen，Anna=Ana，Green = Grean。很愉快吧！</p>\n<p>虽然有点撞大运的意思，但还是要真心的建议同学们，在平时的学习中注意字母组合的认读。有时候，相同的字母组合会发不同的音（e.g. 字母组合 ou 在 pour，out，double，shoulder，soup，could 中的发音都不相同）；不同的字母组合却会发相同的音(e.g.字母组合 ie，ee，ea，ae，eo，oe，e，e，ey 等，都可以发/i:/的音）。</p>\n<p>当然，拼写中还包括单复数的问题。我们合作的考官通常建议大家，在不影响理解的情况下，两者均可。多年的教学经验（额，好酸的一句话…），我建议同学们务必先通过 context（上下文）判断用哪一种形式。比如：____ are in danger of becoming extinct。这里的 be 动词是 are，填空处一定就要用复数。在无法判断的情况下，复数相对比较保险。因为在一般情况下，只要不是特指，英语中更习惯使用复数形式。</p>\n<p>Both US and UK spellings are acceptable.</p>\n<p>包括雅思在内的不少英语考试中，单词的拼写一般都接受来不同英语国家的拼写习惯，即美式或英式拼写都接受。比如：colour=color，neighbour=neighbor， metre=meter，cheque=check。但是 手紧的考官有话说！建议大家在誊答案的时候，统一用某类拼写，最好不要英美混杂。比如：My favourite （英式）shopping center（美式）…这种句子两边不讨好~</p>\n<p><strong>All standard alternatives for numbers, dates and currencies are acceptable.</strong></p>\n<p>有的同学在录音中听到了 2.3 kilometer，看到问题问的是 How long is the tunnel？就孜孜不倦的去拼写 kilometer。不要当劳模好不好~ 浪费时间，而且很容易就错过下面一道题啦~ 雅思听力考试中，所有数字、日期、货币等的标准替代符号都是接受的！！</p>\n<p>雅思听力考试数字、日期、货币是常考点，在誊写这类答案时，既可以写成英语单词，也可以写成阿拉伯数字，或直接使用货币符号。例如，5 hours=5hrs，twelve=12，five percent=5%，July 18th 1988=7.18.1988，60 dollars=\\$60。</p>\n<p>值得注意的是，关于 money 的，单词要写在数字后，货币符号则要写在数字前。比如，10 dollars 或$10。明白？ [大总结：雅思听力答案的写法 By Danqi]  同学们要用巧劲，使用货币符号 + 阿拉伯数字就既省时间又省空间。再者，$10 只算一个数字，而 10 dollars 则算一个数字加一个单词。</p>\n<p>有的同学这时候就开始天马行空了~ 但是时间的分钟，比如 10 minutes 30 seconds，一定不能写成 10:30，只能写成 10.5 minutes。这是因为 10 feet 30 inches 在英语国家也可以写成是 10:30，会引起歧义。</p>\n<p><strong>All standard abbreviations are acceptable.</strong></p>\n<p>不会写联合国，不知道世界卫生组织的全称？没关系，雅思听力中所有标准缩写都被接受。这一条要求简直值得撒花庆祝！！</p>\n<p>关于缩写这个问题，雅思听力经常浮现。比如，地址的常考点 街道，就有多种说法吧，这里，Street=St，Road=Rd，Boulevard=Blvd，Avenue=Ave，Drive=Dr… 啊，突然就可以少背好几个单词呢 [大总结：雅思听力答案的写法 By Danqi]</p>\n<p>国际组织更是，United Nations=UN，United Nations Education Science and Culture Organization=UNESCO。社会和学术称谓亦然，Doctor=Dr，Professor=Prof。 [大总结：雅思听力答案的写法 By Danqi] 这里提醒一句，使用缩写的时候，拜托大家使用标准缩写，别使用自己的 懒惰版缩写，像 15 minutes 就不能写成 15m，因为这可能会与 15 米混淆。Got it?</p>\n<p>好啦，事到如今，雅思官方对听力答案书写要求的所有条款，就为各位童鞋解读完了~ 累史我了 [大总结：雅思听力答案的写法 By Danqi] 还不快谢谢我 [大总结：雅思听力答案的写法 By Danqi]</p>\n"},{"title":"The best figure to describe the OpenGL flowchart","id":"500","date":"2015-09-28T21:05:05.000Z","_content":"\n![](http://hi.csdn.net/attachment/201107/8/0_1310133462o5WH.gif)","source":"_posts/OpenGLFlowchart.md","raw":"---\ntitle: The best figure to describe the OpenGL flowchart\nid: 500\ncategories:\n  - Computer Graphics\ndate: 2015-09-28 17:05:05\ntags:\n---\n\n![](http://hi.csdn.net/attachment/201107/8/0_1310133462o5WH.gif)","slug":"OpenGLFlowchart","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1i0022lkgu38ysg2nd","content":"<p><img src=\"http://hi.csdn.net/attachment/201107/8/0_1310133462o5WH.gif\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://hi.csdn.net/attachment/201107/8/0_1310133462o5WH.gif\" alt=\"\"></p>\n"},{"title":"OSPF and RIP","id":"113","date":"2015-05-04T08:10:01.000Z","_content":"\n1. OSPF, open shortest path first is a IGP routing protocol, it works in local area network based on shortest path first algorithm (dijkstra algorithm), it keeps track the topology of the entire network. And each router in the network maintain a shortest path tree indicate the shortest path to each destination and the closet router to send for each communication.\n\n2. While RIP only track the closet router for each destination, and maintain a routing table for the fastest route from computer to computer. It is commonly used for the small network, because it count hops as metric, and it is only works for 15 hops, It use UDP to broadcast .\n\n1.  RIP takes hop count into consideration but OSPF takes Path Cost into consideration to exchange routing information between the routers.\n2.  RIP serves good when small network is taken care of while OSPF is mostly used for large network.","source":"_posts/OPFSRIP.md","raw":"---\ntitle: OSPF and RIP\nid: 113\ncategories:\n  - Networking and Protocol\ndate: 2015-05-04 04:10:01\ntags:\n  - Networking and Protocol\n---\n\n1. OSPF, open shortest path first is a IGP routing protocol, it works in local area network based on shortest path first algorithm (dijkstra algorithm), it keeps track the topology of the entire network. And each router in the network maintain a shortest path tree indicate the shortest path to each destination and the closet router to send for each communication.\n\n2. While RIP only track the closet router for each destination, and maintain a routing table for the fastest route from computer to computer. It is commonly used for the small network, because it count hops as metric, and it is only works for 15 hops, It use UDP to broadcast .\n\n1.  RIP takes hop count into consideration but OSPF takes Path Cost into consideration to exchange routing information between the routers.\n2.  RIP serves good when small network is taken care of while OSPF is mostly used for large network.","slug":"OPFSRIP","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1j0025lkguzighjuic","content":"<ol>\n<li><p>OSPF, open shortest path first is a IGP routing protocol, it works in local area network based on shortest path first algorithm (dijkstra algorithm), it keeps track the topology of the entire network. And each router in the network maintain a shortest path tree indicate the shortest path to each destination and the closet router to send for each communication.</p>\n</li>\n<li><p>While RIP only track the closet router for each destination, and maintain a routing table for the fastest route from computer to computer. It is commonly used for the small network, because it count hops as metric, and it is only works for 15 hops, It use UDP to broadcast .</p>\n</li>\n<li><p>RIP takes hop count into consideration but OSPF takes Path Cost into consideration to exchange routing information between the routers.</p>\n</li>\n<li>RIP serves good when small network is taken care of while OSPF is mostly used for large network.</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>OSPF, open shortest path first is a IGP routing protocol, it works in local area network based on shortest path first algorithm (dijkstra algorithm), it keeps track the topology of the entire network. And each router in the network maintain a shortest path tree indicate the shortest path to each destination and the closet router to send for each communication.</p>\n</li>\n<li><p>While RIP only track the closet router for each destination, and maintain a routing table for the fastest route from computer to computer. It is commonly used for the small network, because it count hops as metric, and it is only works for 15 hops, It use UDP to broadcast .</p>\n</li>\n<li><p>RIP takes hop count into consideration but OSPF takes Path Cost into consideration to exchange routing information between the routers.</p>\n</li>\n<li>RIP serves good when small network is taken care of while OSPF is mostly used for large network.</li>\n</ol>\n"},{"title":"OpenGL and OpenGL ES","id":"168","date":"2015-07-20T22:08:10.000Z","_content":"\n**OpenGL** (**Open Graphics Library**) is a cross-language, multi-platform application programming interface(API) for rendering 2D and 3D vector graphics. The API is typically used to interact with a graphics processing unit(GPU), to achieve hardware-accelerated rendering. It is widely used in CAD, scientific visualization,  virtual reality, flight simulation, video game. Lastest version 4.5. It's a common accepted industry standard and most driver for pc graphics cards have OpenGL implementation.\n\nOpenGL consists of three libraries GL, GLU,glx/wgl/agl\n\n*   GL: geometric primitive operations. Texturing/Image primitive operations. Set states of OpenGL state machine.\n*   GLU: Higher-level utility functions for NURBS, tessellators, quadric shapes etc.\n*   GLX/WGL/AGL: connects OpenGL and the windowing system of the OS.\n*   GLUT: OpenGL utility toolkit is a simple platform-independent GUI and is contained in the lib glut.\n**OpenGL ES (OpenGL for Embedded System) **is a subsetof the OpenGL computer graphics rendering API(application programming interface) for rendering 2D and 3D computer graphics such as those used by video games, typically hardware-accelerated using a GPU(graphics processing unit). It is designed for embedded systems like smartphones, computer tablets, video game consoles and PDAs.\n\nThe API is cross-language and multi-platform. The libraries GLUT and GLU are not available for OpenGL ES. Lastest version 3.1\n\n**Difference between OpenGL and OpenGL ES**\n\nOpenGL ES 1.1 and OpenGL ES 2.0 are subsets of the full OpenGL standard. When using the OpenGL ES API, there are limitations that you must be aware of when developing your applications. For example, the following OpenGL functionality is not present in either OpenGL ES 1.1 or OpenGL ES 2.0:\n\n*   There is no support for `glBegin` or `glEnd`. Use vertex arrays and vertex buffer objects instead.\n*   The only supported rasterization primitives are points, lines and triangles. Quads are not supported.\n*   There is no polynomial function evaluation stage.\n*   You cannot send blocks of fragments directly to individual fragment operations.\n*   There is no support for display lists.\nIn addition, the following OpenGL functionality is not present in OpenGL ES 2.0:\n\n*   There is no support for the fixed-function graphics pipeline. You must use your own vertex and fragment shader programs.\n*   There is no support for viewing transforms such as `glFrustumf`. You must compute your own transformation matrix, pass it to the vertex shader as a uniform variable, and perform the matrix multiplication in the shader.\n*   There is no support for specialized functions such as `glVertexPointer` and `glNormalPointer`. Use `glVertexAttribPointer`instead.","source":"_posts/OpenGLOpenGLES.md","raw":"---\ntitle: OpenGL and OpenGL ES\ntags:\n  - OpenGL\nid: 168\ncategories:\n  - Computer Graphics\ndate: 2015-07-20 18:08:10\n---\n\n**OpenGL** (**Open Graphics Library**) is a cross-language, multi-platform application programming interface(API) for rendering 2D and 3D vector graphics. The API is typically used to interact with a graphics processing unit(GPU), to achieve hardware-accelerated rendering. It is widely used in CAD, scientific visualization,  virtual reality, flight simulation, video game. Lastest version 4.5. It's a common accepted industry standard and most driver for pc graphics cards have OpenGL implementation.\n\nOpenGL consists of three libraries GL, GLU,glx/wgl/agl\n\n*   GL: geometric primitive operations. Texturing/Image primitive operations. Set states of OpenGL state machine.\n*   GLU: Higher-level utility functions for NURBS, tessellators, quadric shapes etc.\n*   GLX/WGL/AGL: connects OpenGL and the windowing system of the OS.\n*   GLUT: OpenGL utility toolkit is a simple platform-independent GUI and is contained in the lib glut.\n**OpenGL ES (OpenGL for Embedded System) **is a subsetof the OpenGL computer graphics rendering API(application programming interface) for rendering 2D and 3D computer graphics such as those used by video games, typically hardware-accelerated using a GPU(graphics processing unit). It is designed for embedded systems like smartphones, computer tablets, video game consoles and PDAs.\n\nThe API is cross-language and multi-platform. The libraries GLUT and GLU are not available for OpenGL ES. Lastest version 3.1\n\n**Difference between OpenGL and OpenGL ES**\n\nOpenGL ES 1.1 and OpenGL ES 2.0 are subsets of the full OpenGL standard. When using the OpenGL ES API, there are limitations that you must be aware of when developing your applications. For example, the following OpenGL functionality is not present in either OpenGL ES 1.1 or OpenGL ES 2.0:\n\n*   There is no support for `glBegin` or `glEnd`. Use vertex arrays and vertex buffer objects instead.\n*   The only supported rasterization primitives are points, lines and triangles. Quads are not supported.\n*   There is no polynomial function evaluation stage.\n*   You cannot send blocks of fragments directly to individual fragment operations.\n*   There is no support for display lists.\nIn addition, the following OpenGL functionality is not present in OpenGL ES 2.0:\n\n*   There is no support for the fixed-function graphics pipeline. You must use your own vertex and fragment shader programs.\n*   There is no support for viewing transforms such as `glFrustumf`. You must compute your own transformation matrix, pass it to the vertex shader as a uniform variable, and perform the matrix multiplication in the shader.\n*   There is no support for specialized functions such as `glVertexPointer` and `glNormalPointer`. Use `glVertexAttribPointer`instead.","slug":"OpenGLOpenGLES","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1k0029lkgu2w0ru3t6","content":"<p><strong>OpenGL</strong> (<strong>Open Graphics Library</strong>) is a cross-language, multi-platform application programming interface(API) for rendering 2D and 3D vector graphics. The API is typically used to interact with a graphics processing unit(GPU), to achieve hardware-accelerated rendering. It is widely used in CAD, scientific visualization,  virtual reality, flight simulation, video game. Lastest version 4.5. It’s a common accepted industry standard and most driver for pc graphics cards have OpenGL implementation.</p>\n<p>OpenGL consists of three libraries GL, GLU,glx/wgl/agl</p>\n<ul>\n<li>GL: geometric primitive operations. Texturing/Image primitive operations. Set states of OpenGL state machine.</li>\n<li>GLU: Higher-level utility functions for NURBS, tessellators, quadric shapes etc.</li>\n<li>GLX/WGL/AGL: connects OpenGL and the windowing system of the OS.</li>\n<li>GLUT: OpenGL utility toolkit is a simple platform-independent GUI and is contained in the lib glut.<br><strong>OpenGL ES (OpenGL for Embedded System) </strong>is a subsetof the OpenGL computer graphics rendering API(application programming interface) for rendering 2D and 3D computer graphics such as those used by video games, typically hardware-accelerated using a GPU(graphics processing unit). It is designed for embedded systems like smartphones, computer tablets, video game consoles and PDAs.</li>\n</ul>\n<p>The API is cross-language and multi-platform. The libraries GLUT and GLU are not available for OpenGL ES. Lastest version 3.1</p>\n<p><strong>Difference between OpenGL and OpenGL ES</strong></p>\n<p>OpenGL ES 1.1 and OpenGL ES 2.0 are subsets of the full OpenGL standard. When using the OpenGL ES API, there are limitations that you must be aware of when developing your applications. For example, the following OpenGL functionality is not present in either OpenGL ES 1.1 or OpenGL ES 2.0:</p>\n<ul>\n<li>There is no support for <code>glBegin</code> or <code>glEnd</code>. Use vertex arrays and vertex buffer objects instead.</li>\n<li>The only supported rasterization primitives are points, lines and triangles. Quads are not supported.</li>\n<li>There is no polynomial function evaluation stage.</li>\n<li>You cannot send blocks of fragments directly to individual fragment operations.</li>\n<li><p>There is no support for display lists.<br>In addition, the following OpenGL functionality is not present in OpenGL ES 2.0:</p>\n</li>\n<li><p>There is no support for the fixed-function graphics pipeline. You must use your own vertex and fragment shader programs.</p>\n</li>\n<li>There is no support for viewing transforms such as <code>glFrustumf</code>. You must compute your own transformation matrix, pass it to the vertex shader as a uniform variable, and perform the matrix multiplication in the shader.</li>\n<li>There is no support for specialized functions such as <code>glVertexPointer</code> and <code>glNormalPointer</code>. Use <code>glVertexAttribPointer</code>instead.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>OpenGL</strong> (<strong>Open Graphics Library</strong>) is a cross-language, multi-platform application programming interface(API) for rendering 2D and 3D vector graphics. The API is typically used to interact with a graphics processing unit(GPU), to achieve hardware-accelerated rendering. It is widely used in CAD, scientific visualization,  virtual reality, flight simulation, video game. Lastest version 4.5. It’s a common accepted industry standard and most driver for pc graphics cards have OpenGL implementation.</p>\n<p>OpenGL consists of three libraries GL, GLU,glx/wgl/agl</p>\n<ul>\n<li>GL: geometric primitive operations. Texturing/Image primitive operations. Set states of OpenGL state machine.</li>\n<li>GLU: Higher-level utility functions for NURBS, tessellators, quadric shapes etc.</li>\n<li>GLX/WGL/AGL: connects OpenGL and the windowing system of the OS.</li>\n<li>GLUT: OpenGL utility toolkit is a simple platform-independent GUI and is contained in the lib glut.<br><strong>OpenGL ES (OpenGL for Embedded System) </strong>is a subsetof the OpenGL computer graphics rendering API(application programming interface) for rendering 2D and 3D computer graphics such as those used by video games, typically hardware-accelerated using a GPU(graphics processing unit). It is designed for embedded systems like smartphones, computer tablets, video game consoles and PDAs.</li>\n</ul>\n<p>The API is cross-language and multi-platform. The libraries GLUT and GLU are not available for OpenGL ES. Lastest version 3.1</p>\n<p><strong>Difference between OpenGL and OpenGL ES</strong></p>\n<p>OpenGL ES 1.1 and OpenGL ES 2.0 are subsets of the full OpenGL standard. When using the OpenGL ES API, there are limitations that you must be aware of when developing your applications. For example, the following OpenGL functionality is not present in either OpenGL ES 1.1 or OpenGL ES 2.0:</p>\n<ul>\n<li>There is no support for <code>glBegin</code> or <code>glEnd</code>. Use vertex arrays and vertex buffer objects instead.</li>\n<li>The only supported rasterization primitives are points, lines and triangles. Quads are not supported.</li>\n<li>There is no polynomial function evaluation stage.</li>\n<li>You cannot send blocks of fragments directly to individual fragment operations.</li>\n<li><p>There is no support for display lists.<br>In addition, the following OpenGL functionality is not present in OpenGL ES 2.0:</p>\n</li>\n<li><p>There is no support for the fixed-function graphics pipeline. You must use your own vertex and fragment shader programs.</p>\n</li>\n<li>There is no support for viewing transforms such as <code>glFrustumf</code>. You must compute your own transformation matrix, pass it to the vertex shader as a uniform variable, and perform the matrix multiplication in the shader.</li>\n<li>There is no support for specialized functions such as <code>glVertexPointer</code> and <code>glNormalPointer</code>. Use <code>glVertexAttribPointer</code>instead.</li>\n</ul>\n"},{"title":"[转] OpenGL Shader Basics","id":"273","date":"2015-08-03T03:24:00.000Z","_content":"\n# [转] OpenGL Shader Basics\n\n使用 OpenGL 创造的物体，在最终被绘制出来之前，有一个流水线处理过程，该过程被称为 graphics pipeline,或者 rendering pipeline，期间大部分工作由 GPU 执行，跟 GPU 紧密相关。\n\nThe pipeline of OpenGL is used for display 2D/3D objects, it is called graphics pipeline or rendering pipeline, during the pipeline most of the work are done by GPU, the work of pipeline has high relevence with GPU.\n\n随着 GPU 的发展，现在的 GPU 加入了可编程处理器，开发人员可直接控制 GPU 的行为。所谓 Shader，就是控制 GPU 的一堆指令集，程序员写出 shader，输入到 GPU 中，GPU 执行。\n\nAlong the development of GPU, the programable processor has become a common part of GPU, developer can control GPU directly by the programmable processor. Shader is a command set of GPU control, developer code the shader and send it to the GPU, and then GPU can execute the shader.\n\n早期的 Shader 是直接使用汇编。后来 OpenGL ARB 组织开发了一种新的编程语言，叫做 GLslang 或者 GLSL, OpenGL shading language.该语言类似于 C 风格，在官方网站上有详细的语法解释，这样，程序员们就可以很方便的写出可直接控制 GPU 的代码了。\n\nShader was coded using assembly in the early time, then OpenGL ARB group developed a new program language named GLslang or GLSL(OpenGL shading language). The GLSL is similiar to C style, so the developer can easily program the shader to control GPU.\n\n所谓控制 GPU，就是控制 GPU 的处理器，现阶段，GPU 有以下几个处理器：\n\nTo control GPU mean control the processors of GPU, right common GPU consist of these processors:\n\n1. Vertext processor\n\n2. Tessellation Control processor\n\n3. Tessellation Evaluation processor\n\n4. Geometry processor\n\n5. Fragment processor\n\n于是，shader 就分为：\n\nSo, here are the related shaders:\n\n1. Vertext shader\n\n2. Tessellation Control shader\n\n3. Tessellation Evaluation shader\n\n4. Geometry shader\n\n5. Fragment shader\n","source":"_posts/OpenGLShaderBasics.md","raw":"---\ntitle: \"[转] OpenGL Shader Basics\"\nid: 273\ncategories: \n  - OpenGL\ndate: 2015-08-02 23:24:00\ntags:\n---\n\n# [转] OpenGL Shader Basics\n\n使用 OpenGL 创造的物体，在最终被绘制出来之前，有一个流水线处理过程，该过程被称为 graphics pipeline,或者 rendering pipeline，期间大部分工作由 GPU 执行，跟 GPU 紧密相关。\n\nThe pipeline of OpenGL is used for display 2D/3D objects, it is called graphics pipeline or rendering pipeline, during the pipeline most of the work are done by GPU, the work of pipeline has high relevence with GPU.\n\n随着 GPU 的发展，现在的 GPU 加入了可编程处理器，开发人员可直接控制 GPU 的行为。所谓 Shader，就是控制 GPU 的一堆指令集，程序员写出 shader，输入到 GPU 中，GPU 执行。\n\nAlong the development of GPU, the programable processor has become a common part of GPU, developer can control GPU directly by the programmable processor. Shader is a command set of GPU control, developer code the shader and send it to the GPU, and then GPU can execute the shader.\n\n早期的 Shader 是直接使用汇编。后来 OpenGL ARB 组织开发了一种新的编程语言，叫做 GLslang 或者 GLSL, OpenGL shading language.该语言类似于 C 风格，在官方网站上有详细的语法解释，这样，程序员们就可以很方便的写出可直接控制 GPU 的代码了。\n\nShader was coded using assembly in the early time, then OpenGL ARB group developed a new program language named GLslang or GLSL(OpenGL shading language). The GLSL is similiar to C style, so the developer can easily program the shader to control GPU.\n\n所谓控制 GPU，就是控制 GPU 的处理器，现阶段，GPU 有以下几个处理器：\n\nTo control GPU mean control the processors of GPU, right common GPU consist of these processors:\n\n1. Vertext processor\n\n2. Tessellation Control processor\n\n3. Tessellation Evaluation processor\n\n4. Geometry processor\n\n5. Fragment processor\n\n于是，shader 就分为：\n\nSo, here are the related shaders:\n\n1. Vertext shader\n\n2. Tessellation Control shader\n\n3. Tessellation Evaluation shader\n\n4. Geometry shader\n\n5. Fragment shader\n","slug":"OpenGLShaderBasics","published":1,"updated":"2019-02-12T00:37:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1l002clkgu35rfushp","content":"<h1 id=\"转-OpenGL-Shader-Basics\"><a href=\"#转-OpenGL-Shader-Basics\" class=\"headerlink\" title=\"[转] OpenGL Shader Basics\"></a>[转] OpenGL Shader Basics</h1><p>使用 OpenGL 创造的物体，在最终被绘制出来之前，有一个流水线处理过程，该过程被称为 graphics pipeline,或者 rendering pipeline，期间大部分工作由 GPU 执行，跟 GPU 紧密相关。</p>\n<p>The pipeline of OpenGL is used for display 2D/3D objects, it is called graphics pipeline or rendering pipeline, during the pipeline most of the work are done by GPU, the work of pipeline has high relevence with GPU.</p>\n<p>随着 GPU 的发展，现在的 GPU 加入了可编程处理器，开发人员可直接控制 GPU 的行为。所谓 Shader，就是控制 GPU 的一堆指令集，程序员写出 shader，输入到 GPU 中，GPU 执行。</p>\n<p>Along the development of GPU, the programable processor has become a common part of GPU, developer can control GPU directly by the programmable processor. Shader is a command set of GPU control, developer code the shader and send it to the GPU, and then GPU can execute the shader.</p>\n<p>早期的 Shader 是直接使用汇编。后来 OpenGL ARB 组织开发了一种新的编程语言，叫做 GLslang 或者 GLSL, OpenGL shading language.该语言类似于 C 风格，在官方网站上有详细的语法解释，这样，程序员们就可以很方便的写出可直接控制 GPU 的代码了。</p>\n<p>Shader was coded using assembly in the early time, then OpenGL ARB group developed a new program language named GLslang or GLSL(OpenGL shading language). The GLSL is similiar to C style, so the developer can easily program the shader to control GPU.</p>\n<p>所谓控制 GPU，就是控制 GPU 的处理器，现阶段，GPU 有以下几个处理器：</p>\n<p>To control GPU mean control the processors of GPU, right common GPU consist of these processors:</p>\n<ol>\n<li><p>Vertext processor</p>\n</li>\n<li><p>Tessellation Control processor</p>\n</li>\n<li><p>Tessellation Evaluation processor</p>\n</li>\n<li><p>Geometry processor</p>\n</li>\n<li><p>Fragment processor</p>\n</li>\n</ol>\n<p>于是，shader 就分为：</p>\n<p>So, here are the related shaders:</p>\n<ol>\n<li><p>Vertext shader</p>\n</li>\n<li><p>Tessellation Control shader</p>\n</li>\n<li><p>Tessellation Evaluation shader</p>\n</li>\n<li><p>Geometry shader</p>\n</li>\n<li><p>Fragment shader</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"转-OpenGL-Shader-Basics\"><a href=\"#转-OpenGL-Shader-Basics\" class=\"headerlink\" title=\"[转] OpenGL Shader Basics\"></a>[转] OpenGL Shader Basics</h1><p>使用 OpenGL 创造的物体，在最终被绘制出来之前，有一个流水线处理过程，该过程被称为 graphics pipeline,或者 rendering pipeline，期间大部分工作由 GPU 执行，跟 GPU 紧密相关。</p>\n<p>The pipeline of OpenGL is used for display 2D/3D objects, it is called graphics pipeline or rendering pipeline, during the pipeline most of the work are done by GPU, the work of pipeline has high relevence with GPU.</p>\n<p>随着 GPU 的发展，现在的 GPU 加入了可编程处理器，开发人员可直接控制 GPU 的行为。所谓 Shader，就是控制 GPU 的一堆指令集，程序员写出 shader，输入到 GPU 中，GPU 执行。</p>\n<p>Along the development of GPU, the programable processor has become a common part of GPU, developer can control GPU directly by the programmable processor. Shader is a command set of GPU control, developer code the shader and send it to the GPU, and then GPU can execute the shader.</p>\n<p>早期的 Shader 是直接使用汇编。后来 OpenGL ARB 组织开发了一种新的编程语言，叫做 GLslang 或者 GLSL, OpenGL shading language.该语言类似于 C 风格，在官方网站上有详细的语法解释，这样，程序员们就可以很方便的写出可直接控制 GPU 的代码了。</p>\n<p>Shader was coded using assembly in the early time, then OpenGL ARB group developed a new program language named GLslang or GLSL(OpenGL shading language). The GLSL is similiar to C style, so the developer can easily program the shader to control GPU.</p>\n<p>所谓控制 GPU，就是控制 GPU 的处理器，现阶段，GPU 有以下几个处理器：</p>\n<p>To control GPU mean control the processors of GPU, right common GPU consist of these processors:</p>\n<ol>\n<li><p>Vertext processor</p>\n</li>\n<li><p>Tessellation Control processor</p>\n</li>\n<li><p>Tessellation Evaluation processor</p>\n</li>\n<li><p>Geometry processor</p>\n</li>\n<li><p>Fragment processor</p>\n</li>\n</ol>\n<p>于是，shader 就分为：</p>\n<p>So, here are the related shaders:</p>\n<ol>\n<li><p>Vertext shader</p>\n</li>\n<li><p>Tessellation Control shader</p>\n</li>\n<li><p>Tessellation Evaluation shader</p>\n</li>\n<li><p>Geometry shader</p>\n</li>\n<li><p>Fragment shader</p>\n</li>\n</ol>\n"},{"title":"OpenGL pipeline","id":"276","date":"2015-08-03T05:56:25.000Z","_content":"# OpenGL流水线\n\n渲染：计算机根据模型创建图象。\n\n_**模型**_（或物体）是由_**几何图元**_构成的，而_**几何图元**_是通过_**顶点(顶点数据)**_来指定的。可以这样理解，顶点数据即几何图元的数学表示。\n\n最终渲染的图象由屏幕_**像素**_组成。_**像素（pixel）**_是显示硬件能够放置到屏幕上的最小的可视元素。有关像素的信息（如颜色）在系统内存中被组织为位面（bitplane）。位面构成了帧缓存（包含图形显示设备为控制屏幕上所有像素的颜色和亮度所需的信息）。\n\n1、使用几何图元建立模型，从而得到物体的数学描述。（OpenGL将点、直线、多边形、图形和位图视为图元）；\n\n2、在三维空间排列物体，选择观察场景的有利位置；\n\n3、计算所有物体的颜色。颜色可能是由应用程序指定的、根据光照条件确定的、将问题粘贴到物体上得到的，也可能是上述多种操作的结果；\n\n4、将物体的数学描述和相关的颜色信息转换为屏幕像素，这被称为**光栅化**。\n\n当我们把绘制的图形传递给OpenGL后，OpenGL还要做许多才能完成3D空间到屏幕的投影。这一系列的过程称为OpenGL渲染流水线。一般的渲染流水线过程有如下几步： 显示列表 求值程序 顶点操作 图元装配 像素操作 纹理装配 光栅化 片断操作\n\n[![open1](http://godlzr.com/wp-content/uploads/2015/08/open1.jpg)](http://godlzr.com/wp-content/uploads/2015/08/open1.jpg)\n\nOpenGL pipeline 可以分为两部分，一部分是对**顶点数据(Vertex data)**的操作，另一部分是对**像素数据(Pixel data)**的操作。\n\n1.首先，**顶点数据**和**像素数据**都可以保存在**显示列表(Display list)**当中，用来维护一定的执行顺序。\n\n2.**求值器(Evaluators)，**将几何图元用顶点数据来表示，求值器根据顶点计算出图元的数学表达方法，多数情况下是一种多项式映射，简单的理解为一个函数表达式，可以进一步计算该图元上的某顶点的信息(表面法线，纹理坐标，颜色，空间坐标)。\n\n3. **顶点操作**接着，对于顶点数据，可以做一系列的操作，包括几何变换，还有纹理光照等一系列的着色操作，这里就可以使用shader着色器，所以这一步也是vertex shader。然后将顶点变换为图元。\n\n4.**图元装配(primitive assembly)，**根据一定的透视规则裁剪图元并将单个图元装配成完整的几何图元。\n\n**像素操作(pixel operations) **即对像素做一些对应的操作.\n\n5.像素操作之后即**纹理装配(texture assembly)**，包括一系列的纹理贴图与定位。\n\n6.**光栅化(Rasterization)**, 将几何数据与像素数据合并转换为**片段(fragment)**，即帧缓冲中的像素， 把顶点连接起来并填充内部像素。\n\n7.**片段操作(fragment operation)**,一系列操作（这里也可以运用shader即**fragment shader**）之后生成最终的帧，存入**帧缓冲(frame buffer)。**\n\n简单来说，Data-->vertex shader (将数据转化为顶点)-->rasterization(连接顶点并填充三角形)-->fragment shader(根据几何图元加载颜色生成像素)-->output image(根据像素生成图片)-->在屏幕上显示","source":"_posts/OpenGLPipeline.md","raw":"---\ntitle: OpenGL pipeline\nid: 276\ncategories:\n  - Computer Graphics\ndate: 2015-08-03 01:56:25\ntags:\n  - OpenGL\n---\n# OpenGL流水线\n\n渲染：计算机根据模型创建图象。\n\n_**模型**_（或物体）是由_**几何图元**_构成的，而_**几何图元**_是通过_**顶点(顶点数据)**_来指定的。可以这样理解，顶点数据即几何图元的数学表示。\n\n最终渲染的图象由屏幕_**像素**_组成。_**像素（pixel）**_是显示硬件能够放置到屏幕上的最小的可视元素。有关像素的信息（如颜色）在系统内存中被组织为位面（bitplane）。位面构成了帧缓存（包含图形显示设备为控制屏幕上所有像素的颜色和亮度所需的信息）。\n\n1、使用几何图元建立模型，从而得到物体的数学描述。（OpenGL将点、直线、多边形、图形和位图视为图元）；\n\n2、在三维空间排列物体，选择观察场景的有利位置；\n\n3、计算所有物体的颜色。颜色可能是由应用程序指定的、根据光照条件确定的、将问题粘贴到物体上得到的，也可能是上述多种操作的结果；\n\n4、将物体的数学描述和相关的颜色信息转换为屏幕像素，这被称为**光栅化**。\n\n当我们把绘制的图形传递给OpenGL后，OpenGL还要做许多才能完成3D空间到屏幕的投影。这一系列的过程称为OpenGL渲染流水线。一般的渲染流水线过程有如下几步： 显示列表 求值程序 顶点操作 图元装配 像素操作 纹理装配 光栅化 片断操作\n\n[![open1](http://godlzr.com/wp-content/uploads/2015/08/open1.jpg)](http://godlzr.com/wp-content/uploads/2015/08/open1.jpg)\n\nOpenGL pipeline 可以分为两部分，一部分是对**顶点数据(Vertex data)**的操作，另一部分是对**像素数据(Pixel data)**的操作。\n\n1.首先，**顶点数据**和**像素数据**都可以保存在**显示列表(Display list)**当中，用来维护一定的执行顺序。\n\n2.**求值器(Evaluators)，**将几何图元用顶点数据来表示，求值器根据顶点计算出图元的数学表达方法，多数情况下是一种多项式映射，简单的理解为一个函数表达式，可以进一步计算该图元上的某顶点的信息(表面法线，纹理坐标，颜色，空间坐标)。\n\n3. **顶点操作**接着，对于顶点数据，可以做一系列的操作，包括几何变换，还有纹理光照等一系列的着色操作，这里就可以使用shader着色器，所以这一步也是vertex shader。然后将顶点变换为图元。\n\n4.**图元装配(primitive assembly)，**根据一定的透视规则裁剪图元并将单个图元装配成完整的几何图元。\n\n**像素操作(pixel operations) **即对像素做一些对应的操作.\n\n5.像素操作之后即**纹理装配(texture assembly)**，包括一系列的纹理贴图与定位。\n\n6.**光栅化(Rasterization)**, 将几何数据与像素数据合并转换为**片段(fragment)**，即帧缓冲中的像素， 把顶点连接起来并填充内部像素。\n\n7.**片段操作(fragment operation)**,一系列操作（这里也可以运用shader即**fragment shader**）之后生成最终的帧，存入**帧缓冲(frame buffer)。**\n\n简单来说，Data-->vertex shader (将数据转化为顶点)-->rasterization(连接顶点并填充三角形)-->fragment shader(根据几何图元加载颜色生成像素)-->output image(根据像素生成图片)-->在屏幕上显示","slug":"OpenGLPipeline","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1m002glkguc6vg76i6","content":"<h1 id=\"OpenGL流水线\"><a href=\"#OpenGL流水线\" class=\"headerlink\" title=\"OpenGL流水线\"></a>OpenGL流水线</h1><p>渲染：计算机根据模型创建图象。</p>\n<p><em><strong>模型</strong></em>（或物体）是由<em><strong>几何图元</strong></em>构成的，而<em><strong>几何图元</strong></em>是通过<em><strong>顶点(顶点数据)</strong></em>来指定的。可以这样理解，顶点数据即几何图元的数学表示。</p>\n<p>最终渲染的图象由屏幕<em><strong>像素</strong></em>组成。<em><strong>像素（pixel）</strong></em>是显示硬件能够放置到屏幕上的最小的可视元素。有关像素的信息（如颜色）在系统内存中被组织为位面（bitplane）。位面构成了帧缓存（包含图形显示设备为控制屏幕上所有像素的颜色和亮度所需的信息）。</p>\n<p>1、使用几何图元建立模型，从而得到物体的数学描述。（OpenGL将点、直线、多边形、图形和位图视为图元）；</p>\n<p>2、在三维空间排列物体，选择观察场景的有利位置；</p>\n<p>3、计算所有物体的颜色。颜色可能是由应用程序指定的、根据光照条件确定的、将问题粘贴到物体上得到的，也可能是上述多种操作的结果；</p>\n<p>4、将物体的数学描述和相关的颜色信息转换为屏幕像素，这被称为<strong>光栅化</strong>。</p>\n<p>当我们把绘制的图形传递给OpenGL后，OpenGL还要做许多才能完成3D空间到屏幕的投影。这一系列的过程称为OpenGL渲染流水线。一般的渲染流水线过程有如下几步： 显示列表 求值程序 顶点操作 图元装配 像素操作 纹理装配 光栅化 片断操作</p>\n<p><a href=\"http://godlzr.com/wp-content/uploads/2015/08/open1.jpg\"><img src=\"http://godlzr.com/wp-content/uploads/2015/08/open1.jpg\" alt=\"open1\"></a></p>\n<p>OpenGL pipeline 可以分为两部分，一部分是对<strong>顶点数据(Vertex data)</strong>的操作，另一部分是对<strong>像素数据(Pixel data)</strong>的操作。</p>\n<p>1.首先，<strong>顶点数据</strong>和<strong>像素数据</strong>都可以保存在<strong>显示列表(Display list)</strong>当中，用来维护一定的执行顺序。</p>\n<p>2.<strong>求值器(Evaluators)，</strong>将几何图元用顶点数据来表示，求值器根据顶点计算出图元的数学表达方法，多数情况下是一种多项式映射，简单的理解为一个函数表达式，可以进一步计算该图元上的某顶点的信息(表面法线，纹理坐标，颜色，空间坐标)。</p>\n<ol start=\"3\">\n<li><strong>顶点操作</strong>接着，对于顶点数据，可以做一系列的操作，包括几何变换，还有纹理光照等一系列的着色操作，这里就可以使用shader着色器，所以这一步也是vertex shader。然后将顶点变换为图元。</li>\n</ol>\n<p>4.<strong>图元装配(primitive assembly)，</strong>根据一定的透视规则裁剪图元并将单个图元装配成完整的几何图元。</p>\n<p><strong>像素操作(pixel operations) </strong>即对像素做一些对应的操作.</p>\n<p>5.像素操作之后即<strong>纹理装配(texture assembly)</strong>，包括一系列的纹理贴图与定位。</p>\n<p>6.<strong>光栅化(Rasterization)</strong>, 将几何数据与像素数据合并转换为<strong>片段(fragment)</strong>，即帧缓冲中的像素， 把顶点连接起来并填充内部像素。</p>\n<p>7.<strong>片段操作(fragment operation)</strong>,一系列操作（这里也可以运用shader即<strong>fragment shader</strong>）之后生成最终的帧，存入<strong>帧缓冲(frame buffer)。</strong></p>\n<p>简单来说，Data–&gt;vertex shader (将数据转化为顶点)–&gt;rasterization(连接顶点并填充三角形)–&gt;fragment shader(根据几何图元加载颜色生成像素)–&gt;output image(根据像素生成图片)–&gt;在屏幕上显示</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"OpenGL流水线\"><a href=\"#OpenGL流水线\" class=\"headerlink\" title=\"OpenGL流水线\"></a>OpenGL流水线</h1><p>渲染：计算机根据模型创建图象。</p>\n<p><em><strong>模型</strong></em>（或物体）是由<em><strong>几何图元</strong></em>构成的，而<em><strong>几何图元</strong></em>是通过<em><strong>顶点(顶点数据)</strong></em>来指定的。可以这样理解，顶点数据即几何图元的数学表示。</p>\n<p>最终渲染的图象由屏幕<em><strong>像素</strong></em>组成。<em><strong>像素（pixel）</strong></em>是显示硬件能够放置到屏幕上的最小的可视元素。有关像素的信息（如颜色）在系统内存中被组织为位面（bitplane）。位面构成了帧缓存（包含图形显示设备为控制屏幕上所有像素的颜色和亮度所需的信息）。</p>\n<p>1、使用几何图元建立模型，从而得到物体的数学描述。（OpenGL将点、直线、多边形、图形和位图视为图元）；</p>\n<p>2、在三维空间排列物体，选择观察场景的有利位置；</p>\n<p>3、计算所有物体的颜色。颜色可能是由应用程序指定的、根据光照条件确定的、将问题粘贴到物体上得到的，也可能是上述多种操作的结果；</p>\n<p>4、将物体的数学描述和相关的颜色信息转换为屏幕像素，这被称为<strong>光栅化</strong>。</p>\n<p>当我们把绘制的图形传递给OpenGL后，OpenGL还要做许多才能完成3D空间到屏幕的投影。这一系列的过程称为OpenGL渲染流水线。一般的渲染流水线过程有如下几步： 显示列表 求值程序 顶点操作 图元装配 像素操作 纹理装配 光栅化 片断操作</p>\n<p><a href=\"http://godlzr.com/wp-content/uploads/2015/08/open1.jpg\"><img src=\"http://godlzr.com/wp-content/uploads/2015/08/open1.jpg\" alt=\"open1\"></a></p>\n<p>OpenGL pipeline 可以分为两部分，一部分是对<strong>顶点数据(Vertex data)</strong>的操作，另一部分是对<strong>像素数据(Pixel data)</strong>的操作。</p>\n<p>1.首先，<strong>顶点数据</strong>和<strong>像素数据</strong>都可以保存在<strong>显示列表(Display list)</strong>当中，用来维护一定的执行顺序。</p>\n<p>2.<strong>求值器(Evaluators)，</strong>将几何图元用顶点数据来表示，求值器根据顶点计算出图元的数学表达方法，多数情况下是一种多项式映射，简单的理解为一个函数表达式，可以进一步计算该图元上的某顶点的信息(表面法线，纹理坐标，颜色，空间坐标)。</p>\n<ol start=\"3\">\n<li><strong>顶点操作</strong>接着，对于顶点数据，可以做一系列的操作，包括几何变换，还有纹理光照等一系列的着色操作，这里就可以使用shader着色器，所以这一步也是vertex shader。然后将顶点变换为图元。</li>\n</ol>\n<p>4.<strong>图元装配(primitive assembly)，</strong>根据一定的透视规则裁剪图元并将单个图元装配成完整的几何图元。</p>\n<p><strong>像素操作(pixel operations) </strong>即对像素做一些对应的操作.</p>\n<p>5.像素操作之后即<strong>纹理装配(texture assembly)</strong>，包括一系列的纹理贴图与定位。</p>\n<p>6.<strong>光栅化(Rasterization)</strong>, 将几何数据与像素数据合并转换为<strong>片段(fragment)</strong>，即帧缓冲中的像素， 把顶点连接起来并填充内部像素。</p>\n<p>7.<strong>片段操作(fragment operation)</strong>,一系列操作（这里也可以运用shader即<strong>fragment shader</strong>）之后生成最终的帧，存入<strong>帧缓冲(frame buffer)。</strong></p>\n<p>简单来说，Data–&gt;vertex shader (将数据转化为顶点)–&gt;rasterization(连接顶点并填充三角形)–&gt;fragment shader(根据几何图元加载颜色生成像素)–&gt;output image(根据像素生成图片)–&gt;在屏幕上显示</p>\n"},{"title":"Pointers as function return","id":"289","date":"2015-08-12T02:03:17.000Z","_content":"\n我们可以将指针作为返回值，但是要注意的是，如果是在栈中分配的内存空间，函数中内存空间在函数执行完之后就释放了，同理，函数中的局部变量也会释放，如果这段空间被其他代码占用，则该指针指向的内存单元所保存的值就不再是我们期望的了，这种做法很明显是危险的。\n\n使用指针作为返回值有两种情况，一种是该指针指向的是在heap中由程序员申请的内存空间，这种情况下程序员可清楚的知道内存的分配情况。另一种是全局变量，全局变量的内存空间在程序执行完之后才会释放，所以可以放心的访问。\n\n[![Screen Shot 2015-08-11 at 9.51.24 PM](http://godlzr.com/wp-content/uploads/2015/08/Screen-Shot-2015-08-11-at-9.51.24-PM.png)](http://godlzr.com/wp-content/uploads/2015/08/Screen-Shot-2015-08-11-at-9.51.24-PM.png)\n\nThis image is cropped from youtube channel mycodeschool, [<span class=\"watch-title \" dir=\"ltr\" id=\"eow-title\" style=\"margin: 0px; padding: 0px; border: 0px; background: transparent;\" title=\"Pointers as function returns in C/C++\">Pointers as function returns in C/C++</span>](https://www.youtube.com/watch?v=E8Yh4dw6Diw&amp;list=PL2_aWCzGMAwLZp6LMUKI3cc7pgGsasm2_&amp;index=14).","source":"_posts/PointersAsFuncReturn.md","raw":"---\ntitle: Pointers as function return\nid: 289\ncategories:\n  - C/C++\ndate: 2015-08-11 22:03:17\ntags:\n---\n\n我们可以将指针作为返回值，但是要注意的是，如果是在栈中分配的内存空间，函数中内存空间在函数执行完之后就释放了，同理，函数中的局部变量也会释放，如果这段空间被其他代码占用，则该指针指向的内存单元所保存的值就不再是我们期望的了，这种做法很明显是危险的。\n\n使用指针作为返回值有两种情况，一种是该指针指向的是在heap中由程序员申请的内存空间，这种情况下程序员可清楚的知道内存的分配情况。另一种是全局变量，全局变量的内存空间在程序执行完之后才会释放，所以可以放心的访问。\n\n[![Screen Shot 2015-08-11 at 9.51.24 PM](http://godlzr.com/wp-content/uploads/2015/08/Screen-Shot-2015-08-11-at-9.51.24-PM.png)](http://godlzr.com/wp-content/uploads/2015/08/Screen-Shot-2015-08-11-at-9.51.24-PM.png)\n\nThis image is cropped from youtube channel mycodeschool, [<span class=\"watch-title \" dir=\"ltr\" id=\"eow-title\" style=\"margin: 0px; padding: 0px; border: 0px; background: transparent;\" title=\"Pointers as function returns in C/C++\">Pointers as function returns in C/C++</span>](https://www.youtube.com/watch?v=E8Yh4dw6Diw&amp;list=PL2_aWCzGMAwLZp6LMUKI3cc7pgGsasm2_&amp;index=14).","slug":"PointersAsFuncReturn","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1m002jlkgu1n8ib12m","content":"<p>我们可以将指针作为返回值，但是要注意的是，如果是在栈中分配的内存空间，函数中内存空间在函数执行完之后就释放了，同理，函数中的局部变量也会释放，如果这段空间被其他代码占用，则该指针指向的内存单元所保存的值就不再是我们期望的了，这种做法很明显是危险的。</p>\n<p>使用指针作为返回值有两种情况，一种是该指针指向的是在heap中由程序员申请的内存空间，这种情况下程序员可清楚的知道内存的分配情况。另一种是全局变量，全局变量的内存空间在程序执行完之后才会释放，所以可以放心的访问。</p>\n<p><a href=\"http://godlzr.com/wp-content/uploads/2015/08/Screen-Shot-2015-08-11-at-9.51.24-PM.png\"><img src=\"http://godlzr.com/wp-content/uploads/2015/08/Screen-Shot-2015-08-11-at-9.51.24-PM.png\" alt=\"Screen Shot 2015-08-11 at 9.51.24 PM\"></a></p>\n<p>This image is cropped from youtube channel mycodeschool, <a href=\"https://www.youtube.com/watch?v=E8Yh4dw6Diw&amp;list=PL2_aWCzGMAwLZp6LMUKI3cc7pgGsasm2_&amp;index=14\" target=\"_blank\" rel=\"noopener\"><span class=\"watch-title \" dir=\"ltr\" id=\"eow-title\" style=\"margin: 0px; padding: 0px; border: 0px; background: transparent;\" title=\"Pointers as function returns in C/C++\">Pointers as function returns in C/C++</span></a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们可以将指针作为返回值，但是要注意的是，如果是在栈中分配的内存空间，函数中内存空间在函数执行完之后就释放了，同理，函数中的局部变量也会释放，如果这段空间被其他代码占用，则该指针指向的内存单元所保存的值就不再是我们期望的了，这种做法很明显是危险的。</p>\n<p>使用指针作为返回值有两种情况，一种是该指针指向的是在heap中由程序员申请的内存空间，这种情况下程序员可清楚的知道内存的分配情况。另一种是全局变量，全局变量的内存空间在程序执行完之后才会释放，所以可以放心的访问。</p>\n<p><a href=\"http://godlzr.com/wp-content/uploads/2015/08/Screen-Shot-2015-08-11-at-9.51.24-PM.png\"><img src=\"http://godlzr.com/wp-content/uploads/2015/08/Screen-Shot-2015-08-11-at-9.51.24-PM.png\" alt=\"Screen Shot 2015-08-11 at 9.51.24 PM\"></a></p>\n<p>This image is cropped from youtube channel mycodeschool, <a href=\"https://www.youtube.com/watch?v=E8Yh4dw6Diw&amp;list=PL2_aWCzGMAwLZp6LMUKI3cc7pgGsasm2_&amp;index=14\" target=\"_blank\" rel=\"noopener\"><span class=\"watch-title \" dir=\"ltr\" id=\"eow-title\" style=\"margin: 0px; padding: 0px; border: 0px; background: transparent;\" title=\"Pointers as function returns in C/C++\">Pointers as function returns in C/C++</span></a>.</p>\n"},{"title":"[Issue] QTCreater调试时提示ptrace不允许的操作","id":"191","date":"+022015-03-16T01:46:30.000Z","_content":"\n## 问题描述\n\n- 用 QTCreater 建立了一个纯 C++的项目，但是在 F5 调试时，竟然提示 ptrace 不允许的操作，修改工程配置为 Debug 也不管用，经过网上搜索，原来还需要修改一下系统 ptrace 的配置。\n\n## 解决办法\n\n- 临时性的解决方法\n\n```\n    $ sudo echo 0 /proc/sys/kernel/yama/ptrace_scope\n```\n\n- 这样不过重启电脑之后就又恢复成原来的样子了，一劳永逸的方法：\n\n```\n    $ sudo vi /etc/sysctl.d/10-ptrace.conf\n    $ kernel.yama.ptrace_scope = 0\n    重启电脑就好了，\n```\n\n- 据说在 Ubuntu 11.04 之后都会出现这种问题，貌似是为了安全\n\n## ptrace\n\n- 那么 ptrace 是个什么东西，可能是 Linux 下边调试时用到的？目前还不知道，以后要做一下研究\n","source":"_posts/QTCreatorNotAllowPtrace.md","raw":"---\ntitle: \"[Issue] QTCreater调试时提示ptrace不允许的操作\"\nid: 191\ncategories:\n  - Issues Solution\ndate: 22015-03-15 21:46:30\ntags:\n  - QT\n---\n\n## 问题描述\n\n- 用 QTCreater 建立了一个纯 C++的项目，但是在 F5 调试时，竟然提示 ptrace 不允许的操作，修改工程配置为 Debug 也不管用，经过网上搜索，原来还需要修改一下系统 ptrace 的配置。\n\n## 解决办法\n\n- 临时性的解决方法\n\n```\n    $ sudo echo 0 /proc/sys/kernel/yama/ptrace_scope\n```\n\n- 这样不过重启电脑之后就又恢复成原来的样子了，一劳永逸的方法：\n\n```\n    $ sudo vi /etc/sysctl.d/10-ptrace.conf\n    $ kernel.yama.ptrace_scope = 0\n    重启电脑就好了，\n```\n\n- 据说在 Ubuntu 11.04 之后都会出现这种问题，貌似是为了安全\n\n## ptrace\n\n- 那么 ptrace 是个什么东西，可能是 Linux 下边调试时用到的？目前还不知道，以后要做一下研究\n","slug":"QTCreatorNotAllowPtrace","published":1,"updated":"2019-02-12T00:35:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1n002mlkguyfr0lkos","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><ul>\n<li>用 QTCreater 建立了一个纯 C++的项目，但是在 F5 调试时，竟然提示 ptrace 不允许的操作，修改工程配置为 Debug 也不管用，经过网上搜索，原来还需要修改一下系统 ptrace 的配置。</li>\n</ul>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><ul>\n<li>临时性的解决方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo echo 0 /proc/sys/kernel/yama/ptrace_scope</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这样不过重启电脑之后就又恢复成原来的样子了，一劳永逸的方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo vi /etc/sysctl.d/10-ptrace.conf</span><br><span class=\"line\">$ kernel.yama.ptrace_scope = 0</span><br><span class=\"line\">重启电脑就好了，</span><br></pre></td></tr></table></figure>\n<ul>\n<li>据说在 Ubuntu 11.04 之后都会出现这种问题，貌似是为了安全</li>\n</ul>\n<h2 id=\"ptrace\"><a href=\"#ptrace\" class=\"headerlink\" title=\"ptrace\"></a>ptrace</h2><ul>\n<li>那么 ptrace 是个什么东西，可能是 Linux 下边调试时用到的？目前还不知道，以后要做一下研究</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><ul>\n<li>用 QTCreater 建立了一个纯 C++的项目，但是在 F5 调试时，竟然提示 ptrace 不允许的操作，修改工程配置为 Debug 也不管用，经过网上搜索，原来还需要修改一下系统 ptrace 的配置。</li>\n</ul>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><ul>\n<li>临时性的解决方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo echo 0 /proc/sys/kernel/yama/ptrace_scope</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这样不过重启电脑之后就又恢复成原来的样子了，一劳永逸的方法：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo vi /etc/sysctl.d/10-ptrace.conf</span><br><span class=\"line\">$ kernel.yama.ptrace_scope = 0</span><br><span class=\"line\">重启电脑就好了，</span><br></pre></td></tr></table></figure>\n<ul>\n<li>据说在 Ubuntu 11.04 之后都会出现这种问题，貌似是为了安全</li>\n</ul>\n<h2 id=\"ptrace\"><a href=\"#ptrace\" class=\"headerlink\" title=\"ptrace\"></a>ptrace</h2><ul>\n<li>那么 ptrace 是个什么东西，可能是 Linux 下边调试时用到的？目前还不知道，以后要做一下研究</li>\n</ul>\n"},{"title":"Sort Algorithms","id":"479","date":"2015-09-15T16:47:14.000Z","_content":"\n1. Bubble Sort O(n<sup>2</sup>) \n\n2. Simple Selection Sort O(n<sup>2</sup>)\n\n3. Straight Insertion Sort O(n<sup>2</sup>)\n\n4. Shell Sort O(n<sup>3/2</sup>)\n\n5. Heap Sort O(nlogn)\n\n6. Merging Sort O(nlogn)\n\n7. Quick Sort O(nlogn)\n\n---------------------------------------------------\n\n\t* Swapping\n\t** Selection\n\t***Insertion\n\t**** Merging","source":"_posts/SortAlgorithm.md","raw":"---\ntitle: Sort Algorithms\nid: 479\ncategories:\n  - Algorithm\ndate: 2015-09-15 12:47:14\ntags:\n---\n\n1. Bubble Sort O(n<sup>2</sup>) \n\n2. Simple Selection Sort O(n<sup>2</sup>)\n\n3. Straight Insertion Sort O(n<sup>2</sup>)\n\n4. Shell Sort O(n<sup>3/2</sup>)\n\n5. Heap Sort O(nlogn)\n\n6. Merging Sort O(nlogn)\n\n7. Quick Sort O(nlogn)\n\n---------------------------------------------------\n\n\t* Swapping\n\t** Selection\n\t***Insertion\n\t**** Merging","slug":"SortAlgorithm","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1o002qlkgug4tihlot","content":"<ol>\n<li><p>Bubble Sort O(n<sup>2</sup>) </p>\n</li>\n<li><p>Simple Selection Sort O(n<sup>2</sup>)</p>\n</li>\n<li><p>Straight Insertion Sort O(n<sup>2</sup>)</p>\n</li>\n<li><p>Shell Sort O(n<sup>3/2</sup>)</p>\n</li>\n<li><p>Heap Sort O(nlogn)</p>\n</li>\n<li><p>Merging Sort O(nlogn)</p>\n</li>\n<li><p>Quick Sort O(nlogn)</p>\n</li>\n</ol>\n<hr>\n<pre><code>* Swapping\n** Selection\n***Insertion\n**** Merging\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>Bubble Sort O(n<sup>2</sup>) </p>\n</li>\n<li><p>Simple Selection Sort O(n<sup>2</sup>)</p>\n</li>\n<li><p>Straight Insertion Sort O(n<sup>2</sup>)</p>\n</li>\n<li><p>Shell Sort O(n<sup>3/2</sup>)</p>\n</li>\n<li><p>Heap Sort O(nlogn)</p>\n</li>\n<li><p>Merging Sort O(nlogn)</p>\n</li>\n<li><p>Quick Sort O(nlogn)</p>\n</li>\n</ol>\n<hr>\n<pre><code>* Swapping\n** Selection\n***Insertion\n**** Merging\n</code></pre>"},{"title":"基于物理渲染的基础理论[Progressing...]","id":"497","date":"2016-06-24T03:10:30.000Z","_content":"\n# 基于物理渲染的基础理论\n\n---翻译自[Basic Theory of Physically-Based Rendering](https://www.marmoset.co/toolbag/learn/pbr-theory) By [Jeff Russell](https://twitter.com/j3ffdr)\n\n---【译】李仲锐\n\nPhyscially-based Rendering（PBR）基于物理渲染是令人兴奋的技术，因为缺少定义，近年来倾向于用实时渲染（Real-time Rendering）来指代。这项技术中杂糅了很多概念，所以经常让人困惑它的真实含义是什么。最简短的回答是:许多事物，和它有关于，这个回答显然不令人满意，所以我尝试用我的方法来在一定程度上解释PBR代表的含义和它有别于其他渲染方法的地方。这篇文章是为了那些非工程出身的读者，主要是艺术工作者而写的，其中不包含任何的数学知识与计算机代码。\n\n基于物理的着色（shading）系统与以往技术的最大不同在于对光线与物体表面行为属性的关注。一些以往的方法的着色能力已经足够先进，使那些近似而不精确的视觉效果可以被忽略，这些方法已被用于艺术相关的创作中。工程人员和艺术工作者应该理解这些方法改变与演进的动机。\n\n我们将会从一些基础开始，对于基础深刻的理解有助于我们开始探究PBR的新鲜技术。但是如果你能忍受我讲述你已经知道的部分，你将发现这些内容是值得一读的。你可能还会想去查看Joe Wilson的文章 《[Creating PBR artwork](http://www.marmoset.co/toolbag/learn/pbr-practice)》\n\n## Diffusion Reflection 漫反射和反射\n\n漫反射和反射 - 对应于漫射光和镜面反射光，是两个用来描述最为基本的物体表面和光线交汇情况分类。实践上，大多数人比较熟悉这些概念，但是可能不清楚其具体的物理区别。\n\nWhen light hits a surface boundary some of it will reflect that is, bounce off from the surface and leave heading in a direction on the opposing side of the surface normal. This behavior is very similar to a ball thrown against the ground or a wall it will bounce off at the opposite angle. On a smooth surface this will result in a mirror-like appearance. The word specular, often used to describe the effect, is derived from the latin for mirror (it seems specularity sounds less awkward than mirrorness).\n\nNot all light reflects from a surface, however. Usually some will penetrate into the interior of the illuminated object. There it will either be absorbed by the material (usually converting to heat) or scattered internally. Some of this scattered light may make its way back out of the surface, then becoming visible once more to eyeballs and cameras. This is known by many names: Diffuse Light, Diffusion, Subsurface Scattering all describe the same effect.\n\nThe absorption and scattering of diffuse light are often quite different for different wavelengths of light, which is what gives objects their color (e.g. if an object absorbs most light but scatters blue, it will appear blue). The scattering is often so uniformly chaotic that it can be said to appear the same from all directions quite different from the case of a mirror! A shader using this approximation really just needs one input: albedo, a color which describes the fractions of various colors of light that will scatter back out of a surface. Diffuse color is a phrase sometimes used synonymously.\n","source":"_posts/PBR.md","raw":"---\ntitle: 基于物理渲染的基础理论[Progressing...]\nid: 497\ncategories:\n  - Computer Vision/Graphics\ndate: 2016-06-23 23:10:30\ntags:\n---\n\n# 基于物理渲染的基础理论\n\n---翻译自[Basic Theory of Physically-Based Rendering](https://www.marmoset.co/toolbag/learn/pbr-theory) By [Jeff Russell](https://twitter.com/j3ffdr)\n\n---【译】李仲锐\n\nPhyscially-based Rendering（PBR）基于物理渲染是令人兴奋的技术，因为缺少定义，近年来倾向于用实时渲染（Real-time Rendering）来指代。这项技术中杂糅了很多概念，所以经常让人困惑它的真实含义是什么。最简短的回答是:许多事物，和它有关于，这个回答显然不令人满意，所以我尝试用我的方法来在一定程度上解释PBR代表的含义和它有别于其他渲染方法的地方。这篇文章是为了那些非工程出身的读者，主要是艺术工作者而写的，其中不包含任何的数学知识与计算机代码。\n\n基于物理的着色（shading）系统与以往技术的最大不同在于对光线与物体表面行为属性的关注。一些以往的方法的着色能力已经足够先进，使那些近似而不精确的视觉效果可以被忽略，这些方法已被用于艺术相关的创作中。工程人员和艺术工作者应该理解这些方法改变与演进的动机。\n\n我们将会从一些基础开始，对于基础深刻的理解有助于我们开始探究PBR的新鲜技术。但是如果你能忍受我讲述你已经知道的部分，你将发现这些内容是值得一读的。你可能还会想去查看Joe Wilson的文章 《[Creating PBR artwork](http://www.marmoset.co/toolbag/learn/pbr-practice)》\n\n## Diffusion Reflection 漫反射和反射\n\n漫反射和反射 - 对应于漫射光和镜面反射光，是两个用来描述最为基本的物体表面和光线交汇情况分类。实践上，大多数人比较熟悉这些概念，但是可能不清楚其具体的物理区别。\n\nWhen light hits a surface boundary some of it will reflect that is, bounce off from the surface and leave heading in a direction on the opposing side of the surface normal. This behavior is very similar to a ball thrown against the ground or a wall it will bounce off at the opposite angle. On a smooth surface this will result in a mirror-like appearance. The word specular, often used to describe the effect, is derived from the latin for mirror (it seems specularity sounds less awkward than mirrorness).\n\nNot all light reflects from a surface, however. Usually some will penetrate into the interior of the illuminated object. There it will either be absorbed by the material (usually converting to heat) or scattered internally. Some of this scattered light may make its way back out of the surface, then becoming visible once more to eyeballs and cameras. This is known by many names: Diffuse Light, Diffusion, Subsurface Scattering all describe the same effect.\n\nThe absorption and scattering of diffuse light are often quite different for different wavelengths of light, which is what gives objects their color (e.g. if an object absorbs most light but scatters blue, it will appear blue). The scattering is often so uniformly chaotic that it can be said to appear the same from all directions quite different from the case of a mirror! A shader using this approximation really just needs one input: albedo, a color which describes the fractions of various colors of light that will scatter back out of a surface. Diffuse color is a phrase sometimes used synonymously.\n","slug":"PBR","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1p002tlkgu7ytvywwq","content":"<h1 id=\"基于物理渲染的基础理论\"><a href=\"#基于物理渲染的基础理论\" class=\"headerlink\" title=\"基于物理渲染的基础理论\"></a>基于物理渲染的基础理论</h1><p>—翻译自<a href=\"https://www.marmoset.co/toolbag/learn/pbr-theory\" target=\"_blank\" rel=\"noopener\">Basic Theory of Physically-Based Rendering</a> By <a href=\"https://twitter.com/j3ffdr\" target=\"_blank\" rel=\"noopener\">Jeff Russell</a></p>\n<p>—【译】李仲锐</p>\n<p>Physcially-based Rendering（PBR）基于物理渲染是令人兴奋的技术，因为缺少定义，近年来倾向于用实时渲染（Real-time Rendering）来指代。这项技术中杂糅了很多概念，所以经常让人困惑它的真实含义是什么。最简短的回答是:许多事物，和它有关于，这个回答显然不令人满意，所以我尝试用我的方法来在一定程度上解释PBR代表的含义和它有别于其他渲染方法的地方。这篇文章是为了那些非工程出身的读者，主要是艺术工作者而写的，其中不包含任何的数学知识与计算机代码。</p>\n<p>基于物理的着色（shading）系统与以往技术的最大不同在于对光线与物体表面行为属性的关注。一些以往的方法的着色能力已经足够先进，使那些近似而不精确的视觉效果可以被忽略，这些方法已被用于艺术相关的创作中。工程人员和艺术工作者应该理解这些方法改变与演进的动机。</p>\n<p>我们将会从一些基础开始，对于基础深刻的理解有助于我们开始探究PBR的新鲜技术。但是如果你能忍受我讲述你已经知道的部分，你将发现这些内容是值得一读的。你可能还会想去查看Joe Wilson的文章 《<a href=\"http://www.marmoset.co/toolbag/learn/pbr-practice\" target=\"_blank\" rel=\"noopener\">Creating PBR artwork</a>》</p>\n<h2 id=\"Diffusion-Reflection-漫反射和反射\"><a href=\"#Diffusion-Reflection-漫反射和反射\" class=\"headerlink\" title=\"Diffusion Reflection 漫反射和反射\"></a>Diffusion Reflection 漫反射和反射</h2><p>漫反射和反射 - 对应于漫射光和镜面反射光，是两个用来描述最为基本的物体表面和光线交汇情况分类。实践上，大多数人比较熟悉这些概念，但是可能不清楚其具体的物理区别。</p>\n<p>When light hits a surface boundary some of it will reflect that is, bounce off from the surface and leave heading in a direction on the opposing side of the surface normal. This behavior is very similar to a ball thrown against the ground or a wall it will bounce off at the opposite angle. On a smooth surface this will result in a mirror-like appearance. The word specular, often used to describe the effect, is derived from the latin for mirror (it seems specularity sounds less awkward than mirrorness).</p>\n<p>Not all light reflects from a surface, however. Usually some will penetrate into the interior of the illuminated object. There it will either be absorbed by the material (usually converting to heat) or scattered internally. Some of this scattered light may make its way back out of the surface, then becoming visible once more to eyeballs and cameras. This is known by many names: Diffuse Light, Diffusion, Subsurface Scattering all describe the same effect.</p>\n<p>The absorption and scattering of diffuse light are often quite different for different wavelengths of light, which is what gives objects their color (e.g. if an object absorbs most light but scatters blue, it will appear blue). The scattering is often so uniformly chaotic that it can be said to appear the same from all directions quite different from the case of a mirror! A shader using this approximation really just needs one input: albedo, a color which describes the fractions of various colors of light that will scatter back out of a surface. Diffuse color is a phrase sometimes used synonymously.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基于物理渲染的基础理论\"><a href=\"#基于物理渲染的基础理论\" class=\"headerlink\" title=\"基于物理渲染的基础理论\"></a>基于物理渲染的基础理论</h1><p>—翻译自<a href=\"https://www.marmoset.co/toolbag/learn/pbr-theory\" target=\"_blank\" rel=\"noopener\">Basic Theory of Physically-Based Rendering</a> By <a href=\"https://twitter.com/j3ffdr\" target=\"_blank\" rel=\"noopener\">Jeff Russell</a></p>\n<p>—【译】李仲锐</p>\n<p>Physcially-based Rendering（PBR）基于物理渲染是令人兴奋的技术，因为缺少定义，近年来倾向于用实时渲染（Real-time Rendering）来指代。这项技术中杂糅了很多概念，所以经常让人困惑它的真实含义是什么。最简短的回答是:许多事物，和它有关于，这个回答显然不令人满意，所以我尝试用我的方法来在一定程度上解释PBR代表的含义和它有别于其他渲染方法的地方。这篇文章是为了那些非工程出身的读者，主要是艺术工作者而写的，其中不包含任何的数学知识与计算机代码。</p>\n<p>基于物理的着色（shading）系统与以往技术的最大不同在于对光线与物体表面行为属性的关注。一些以往的方法的着色能力已经足够先进，使那些近似而不精确的视觉效果可以被忽略，这些方法已被用于艺术相关的创作中。工程人员和艺术工作者应该理解这些方法改变与演进的动机。</p>\n<p>我们将会从一些基础开始，对于基础深刻的理解有助于我们开始探究PBR的新鲜技术。但是如果你能忍受我讲述你已经知道的部分，你将发现这些内容是值得一读的。你可能还会想去查看Joe Wilson的文章 《<a href=\"http://www.marmoset.co/toolbag/learn/pbr-practice\" target=\"_blank\" rel=\"noopener\">Creating PBR artwork</a>》</p>\n<h2 id=\"Diffusion-Reflection-漫反射和反射\"><a href=\"#Diffusion-Reflection-漫反射和反射\" class=\"headerlink\" title=\"Diffusion Reflection 漫反射和反射\"></a>Diffusion Reflection 漫反射和反射</h2><p>漫反射和反射 - 对应于漫射光和镜面反射光，是两个用来描述最为基本的物体表面和光线交汇情况分类。实践上，大多数人比较熟悉这些概念，但是可能不清楚其具体的物理区别。</p>\n<p>When light hits a surface boundary some of it will reflect that is, bounce off from the surface and leave heading in a direction on the opposing side of the surface normal. This behavior is very similar to a ball thrown against the ground or a wall it will bounce off at the opposite angle. On a smooth surface this will result in a mirror-like appearance. The word specular, often used to describe the effect, is derived from the latin for mirror (it seems specularity sounds less awkward than mirrorness).</p>\n<p>Not all light reflects from a surface, however. Usually some will penetrate into the interior of the illuminated object. There it will either be absorbed by the material (usually converting to heat) or scattered internally. Some of this scattered light may make its way back out of the surface, then becoming visible once more to eyeballs and cameras. This is known by many names: Diffuse Light, Diffusion, Subsurface Scattering all describe the same effect.</p>\n<p>The absorption and scattering of diffuse light are often quite different for different wavelengths of light, which is what gives objects their color (e.g. if an object absorbs most light but scatters blue, it will appear blue). The scattering is often so uniformly chaotic that it can be said to appear the same from all directions quite different from the case of a mirror! A shader using this approximation really just needs one input: albedo, a color which describes the fractions of various colors of light that will scatter back out of a surface. Diffuse color is a phrase sometimes used synonymously.</p>\n"},{"title":"[Issue] 开启UBUNTU php错误提示","id":"8","date":"2015-02-17T05:03:44.000Z","_content":"\nPHP 编码出错不提示，这对于开发来说，是很不方便的。下面讲解如何开启错误提示步骤：\n\n    1. 打开php.ini文件。\n\n    以我的ubuntu为例，这个文件在： /etc/php5/apache2 目录下。\n\n    2. 搜索并修改下行，把Off值改成On\n\n    display_errors = Off\n\n    3. 搜索下行\n\n    error_reporting = E_ALL &amp; ~E_NOTICE\n\n    error_reporting = E_ALL | E_STRICT\n\n    4. 修改Apache的 apache2.conf，\n\n    以我的 Ubuntu 为例， 这个文件在：/etc/apache2/&nbsp; 目录下。\n\n    在末端添加以下两行：\n\n    php_flag display_errors on\n\n    php_value error_reporting 2039\n\n    5. 重启Apache，就OK了。\n\n    重启命令： ：sudo /etc/init.d/apache2 restart\n\n    在修改配置文件时可能会遇到权限不够的问题，可在命令行中用\n\n    sudo chmod 777 (FILENAME)\n\n    进行修改。\n","source":"_posts/UbuntuPHPError.md","raw":"---\ntitle: \"[Issue] 开启UBUNTU php错误提示\"\nid: 8\ncategories: \n  - Issues Solution\ndate: 2015-02-17 00:03:44\ntags:\n---\n\nPHP 编码出错不提示，这对于开发来说，是很不方便的。下面讲解如何开启错误提示步骤：\n\n    1. 打开php.ini文件。\n\n    以我的ubuntu为例，这个文件在： /etc/php5/apache2 目录下。\n\n    2. 搜索并修改下行，把Off值改成On\n\n    display_errors = Off\n\n    3. 搜索下行\n\n    error_reporting = E_ALL &amp; ~E_NOTICE\n\n    error_reporting = E_ALL | E_STRICT\n\n    4. 修改Apache的 apache2.conf，\n\n    以我的 Ubuntu 为例， 这个文件在：/etc/apache2/&nbsp; 目录下。\n\n    在末端添加以下两行：\n\n    php_flag display_errors on\n\n    php_value error_reporting 2039\n\n    5. 重启Apache，就OK了。\n\n    重启命令： ：sudo /etc/init.d/apache2 restart\n\n    在修改配置文件时可能会遇到权限不够的问题，可在命令行中用\n\n    sudo chmod 777 (FILENAME)\n\n    进行修改。\n","slug":"UbuntuPHPError","published":1,"updated":"2019-02-12T00:36:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1q002wlkguif5orukz","content":"<p>PHP 编码出错不提示，这对于开发来说，是很不方便的。下面讲解如何开启错误提示步骤：</p>\n<pre><code>1. 打开php.ini文件。\n\n以我的ubuntu为例，这个文件在： /etc/php5/apache2 目录下。\n\n2. 搜索并修改下行，把Off值改成On\n\ndisplay_errors = Off\n\n3. 搜索下行\n\nerror_reporting = E_ALL &amp;amp; ~E_NOTICE\n\nerror_reporting = E_ALL | E_STRICT\n\n4. 修改Apache的 apache2.conf，\n\n以我的 Ubuntu 为例， 这个文件在：/etc/apache2/&amp;nbsp; 目录下。\n\n在末端添加以下两行：\n\nphp_flag display_errors on\n\nphp_value error_reporting 2039\n\n5. 重启Apache，就OK了。\n\n重启命令： ：sudo /etc/init.d/apache2 restart\n\n在修改配置文件时可能会遇到权限不够的问题，可在命令行中用\n\nsudo chmod 777 (FILENAME)\n\n进行修改。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>PHP 编码出错不提示，这对于开发来说，是很不方便的。下面讲解如何开启错误提示步骤：</p>\n<pre><code>1. 打开php.ini文件。\n\n以我的ubuntu为例，这个文件在： /etc/php5/apache2 目录下。\n\n2. 搜索并修改下行，把Off值改成On\n\ndisplay_errors = Off\n\n3. 搜索下行\n\nerror_reporting = E_ALL &amp;amp; ~E_NOTICE\n\nerror_reporting = E_ALL | E_STRICT\n\n4. 修改Apache的 apache2.conf，\n\n以我的 Ubuntu 为例， 这个文件在：/etc/apache2/&amp;nbsp; 目录下。\n\n在末端添加以下两行：\n\nphp_flag display_errors on\n\nphp_value error_reporting 2039\n\n5. 重启Apache，就OK了。\n\n重启命令： ：sudo /etc/init.d/apache2 restart\n\n在修改配置文件时可能会遇到权限不够的问题，可在命令行中用\n\nsudo chmod 777 (FILENAME)\n\n进行修改。\n</code></pre>"},{"title":"[Issue] 恢复Ubuntu启动项","id":"11","date":"2015-02-26T11:45:45.000Z","_content":"\n使用 ubuntu 的启动盘，然后改系统从光盘启动，进入临时 ubuntu 系统，选择试用 ubuntu。\n\n运行命令：sudo fdisk -l （这里不是数字 1，是字母 l），找到 ubuntu 所在分区。由于我的是装在 G 盘，所以显示为 sda8。\n\n运行命令：sudo -i 进入到 root 用户，方便后面的操作。\n\n运行命令：mkdir /media/tmpdir 建立临时文件夹，然后输入命令：mount /dev/sda8 /media/tmpdir 挂载系统。\n\n接下来输入命令: sudo grub-install --root-directory=/media/tmpdir/dev/sda （注意，这里就是 sda，后面不要写成 sda8），如果显示 no error report，则表示基本成功了。\n\n接下来，重启系统，不要进入[windows](http://www.2cto.com/os/windows/)，先进入 ubuntu，在终端中输入命令：sudo update-grub2 更新 grub 后方成功完成，这时候就可以重启进入任意一个系统了。\n\n以上经过 windows7 和 windows8 系统测试都没有问题，最终很完美的解决了启动项问题\n","source":"_posts/UbuntuRecover.md","raw":"---\ntitle: \"[Issue] 恢复Ubuntu启动项\"\nid: 11\ncategories:\n  - Issues Solution\ndate: 2015-02-26 06:45:45\ntags:\n  - Ubuntu\n---\n\n使用 ubuntu 的启动盘，然后改系统从光盘启动，进入临时 ubuntu 系统，选择试用 ubuntu。\n\n运行命令：sudo fdisk -l （这里不是数字 1，是字母 l），找到 ubuntu 所在分区。由于我的是装在 G 盘，所以显示为 sda8。\n\n运行命令：sudo -i 进入到 root 用户，方便后面的操作。\n\n运行命令：mkdir /media/tmpdir 建立临时文件夹，然后输入命令：mount /dev/sda8 /media/tmpdir 挂载系统。\n\n接下来输入命令: sudo grub-install --root-directory=/media/tmpdir/dev/sda （注意，这里就是 sda，后面不要写成 sda8），如果显示 no error report，则表示基本成功了。\n\n接下来，重启系统，不要进入[windows](http://www.2cto.com/os/windows/)，先进入 ubuntu，在终端中输入命令：sudo update-grub2 更新 grub 后方成功完成，这时候就可以重启进入任意一个系统了。\n\n以上经过 windows7 和 windows8 系统测试都没有问题，最终很完美的解决了启动项问题\n","slug":"UbuntuRecover","published":1,"updated":"2019-02-12T00:37:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1s0030lkguhd02vthz","content":"<p>使用 ubuntu 的启动盘，然后改系统从光盘启动，进入临时 ubuntu 系统，选择试用 ubuntu。</p>\n<p>运行命令：sudo fdisk -l （这里不是数字 1，是字母 l），找到 ubuntu 所在分区。由于我的是装在 G 盘，所以显示为 sda8。</p>\n<p>运行命令：sudo -i 进入到 root 用户，方便后面的操作。</p>\n<p>运行命令：mkdir /media/tmpdir 建立临时文件夹，然后输入命令：mount /dev/sda8 /media/tmpdir 挂载系统。</p>\n<p>接下来输入命令: sudo grub-install –root-directory=/media/tmpdir/dev/sda （注意，这里就是 sda，后面不要写成 sda8），如果显示 no error report，则表示基本成功了。</p>\n<p>接下来，重启系统，不要进入<a href=\"http://www.2cto.com/os/windows/\" target=\"_blank\" rel=\"noopener\">windows</a>，先进入 ubuntu，在终端中输入命令：sudo update-grub2 更新 grub 后方成功完成，这时候就可以重启进入任意一个系统了。</p>\n<p>以上经过 windows7 和 windows8 系统测试都没有问题，最终很完美的解决了启动项问题</p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用 ubuntu 的启动盘，然后改系统从光盘启动，进入临时 ubuntu 系统，选择试用 ubuntu。</p>\n<p>运行命令：sudo fdisk -l （这里不是数字 1，是字母 l），找到 ubuntu 所在分区。由于我的是装在 G 盘，所以显示为 sda8。</p>\n<p>运行命令：sudo -i 进入到 root 用户，方便后面的操作。</p>\n<p>运行命令：mkdir /media/tmpdir 建立临时文件夹，然后输入命令：mount /dev/sda8 /media/tmpdir 挂载系统。</p>\n<p>接下来输入命令: sudo grub-install –root-directory=/media/tmpdir/dev/sda （注意，这里就是 sda，后面不要写成 sda8），如果显示 no error report，则表示基本成功了。</p>\n<p>接下来，重启系统，不要进入<a href=\"http://www.2cto.com/os/windows/\" target=\"_blank\" rel=\"noopener\">windows</a>，先进入 ubuntu，在终端中输入命令：sudo update-grub2 更新 grub 后方成功完成，这时候就可以重启进入任意一个系统了。</p>\n<p>以上经过 windows7 和 windows8 系统测试都没有问题，最终很完美的解决了启动项问题</p>\n"},{"title":"OpenGL is a State Machine（OpenGL状态机）","id":"261","date":"2015-08-02T22:46:18.000Z","_content":"\n# OpenGL State Machine\n\n1. OpenGL is a state machine, so the first question is what is the state machine?\n\n\t- State machine: is a kind of machine which keep various of state in its memory. It can accept input and change the corresponding state in its memory, and it can also output its current state when getting inqurie. So for a time, and a state, it only have one value for this state. And it may get into a special state(stop state), and it stop to accept input, and turned off.\n\n\t- So OpenGL works as a state machine. First of all, OpenGL keep various of states values, such as current color, current viewing and projection transformations, line and polygon stipple patterns, polygon drawing modes, pixel-packing conventions, positions and characteristics of lights, and material properties of the objects being drawn, etc. Programmer puts it into various states (or modes) that then remain in effect until changing them. The current color is a state variable. You can set the current color to white, red, or any other color, and thereafter every object is drawn with that color until you set the current color to something else. The current color is only one of many state variables that OpenGL maintains. Many state variables refer to modes that are enabled or disabled with the command glEnable() or glDisable().\n\n2. Each state variable or mode has a default value, and at any point you can query the system for each variables current value. Typically, you use one of the six following commands to do this: \n\n\t-   glGetBooleanv(),  \n\t-   glGetDoublev(),\n\t-   glGetFloatv(),\n\t-   glGetIntegerv(), \n\t-   glGetPointerv(),\n\t-   or glIsEnabled().\n\n3. Which of these commands you select depends on what data type you want the answer to be given in. Some state variables have a more specific query command (such as glGetLight*(), glGetError(), or glGetPolygonStipple()). In addition, you can save a collection of state variables on an attribute stack with glPushAttrib() or glPushClientAttrib(), temporarily modify them, and later restore the values with glPopAttrib() or glPopClientAttrib(). For temporary state changes, you should use these commands rather than any of the query commands, since they`&#39;`re likely to be more efficient.\n\n\n4. So how to set the state of OpenGL? Although you need to use getXXX to check the current state of OpenGL, but there is no set function as setXXX to set or change the state of OpenGL. OpenGL provides many functions such as glColor*, glMaterial*, glEnable, glDisable, to give the programmer the control of state change. So there is no need to have setXXX functions for OpenGL. **Important: From the prespective of state machine, it changes its state itself based on the external input, and it is not allowed to change its state directly by the outside, this is the reason why no need of the kind of setXXX function for OpenGL.**","source":"_posts/OpenGLStateMachine.md","raw":"---\ntitle: OpenGL is a State Machine（OpenGL状态机）\nid: 261\ncategories:\n  - Computer Graphics\ndate: 2015-08-02 18:46:18\ntags:\n---\n\n# OpenGL State Machine\n\n1. OpenGL is a state machine, so the first question is what is the state machine?\n\n\t- State machine: is a kind of machine which keep various of state in its memory. It can accept input and change the corresponding state in its memory, and it can also output its current state when getting inqurie. So for a time, and a state, it only have one value for this state. And it may get into a special state(stop state), and it stop to accept input, and turned off.\n\n\t- So OpenGL works as a state machine. First of all, OpenGL keep various of states values, such as current color, current viewing and projection transformations, line and polygon stipple patterns, polygon drawing modes, pixel-packing conventions, positions and characteristics of lights, and material properties of the objects being drawn, etc. Programmer puts it into various states (or modes) that then remain in effect until changing them. The current color is a state variable. You can set the current color to white, red, or any other color, and thereafter every object is drawn with that color until you set the current color to something else. The current color is only one of many state variables that OpenGL maintains. Many state variables refer to modes that are enabled or disabled with the command glEnable() or glDisable().\n\n2. Each state variable or mode has a default value, and at any point you can query the system for each variables current value. Typically, you use one of the six following commands to do this: \n\n\t-   glGetBooleanv(),  \n\t-   glGetDoublev(),\n\t-   glGetFloatv(),\n\t-   glGetIntegerv(), \n\t-   glGetPointerv(),\n\t-   or glIsEnabled().\n\n3. Which of these commands you select depends on what data type you want the answer to be given in. Some state variables have a more specific query command (such as glGetLight*(), glGetError(), or glGetPolygonStipple()). In addition, you can save a collection of state variables on an attribute stack with glPushAttrib() or glPushClientAttrib(), temporarily modify them, and later restore the values with glPopAttrib() or glPopClientAttrib(). For temporary state changes, you should use these commands rather than any of the query commands, since they`&#39;`re likely to be more efficient.\n\n\n4. So how to set the state of OpenGL? Although you need to use getXXX to check the current state of OpenGL, but there is no set function as setXXX to set or change the state of OpenGL. OpenGL provides many functions such as glColor*, glMaterial*, glEnable, glDisable, to give the programmer the control of state change. So there is no need to have setXXX functions for OpenGL. **Important: From the prespective of state machine, it changes its state itself based on the external input, and it is not allowed to change its state directly by the outside, this is the reason why no need of the kind of setXXX function for OpenGL.**","slug":"OpenGLStateMachine","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1t0033lkgu920j9rh7","content":"<h1 id=\"OpenGL-State-Machine\"><a href=\"#OpenGL-State-Machine\" class=\"headerlink\" title=\"OpenGL State Machine\"></a>OpenGL State Machine</h1><ol>\n<li><p>OpenGL is a state machine, so the first question is what is the state machine?</p>\n<ul>\n<li><p>State machine: is a kind of machine which keep various of state in its memory. It can accept input and change the corresponding state in its memory, and it can also output its current state when getting inqurie. So for a time, and a state, it only have one value for this state. And it may get into a special state(stop state), and it stop to accept input, and turned off.</p>\n</li>\n<li><p>So OpenGL works as a state machine. First of all, OpenGL keep various of states values, such as current color, current viewing and projection transformations, line and polygon stipple patterns, polygon drawing modes, pixel-packing conventions, positions and characteristics of lights, and material properties of the objects being drawn, etc. Programmer puts it into various states (or modes) that then remain in effect until changing them. The current color is a state variable. You can set the current color to white, red, or any other color, and thereafter every object is drawn with that color until you set the current color to something else. The current color is only one of many state variables that OpenGL maintains. Many state variables refer to modes that are enabled or disabled with the command glEnable() or glDisable().</p>\n</li>\n</ul>\n</li>\n<li><p>Each state variable or mode has a default value, and at any point you can query the system for each variables current value. Typically, you use one of the six following commands to do this: </p>\n<ul>\n<li>glGetBooleanv(),  </li>\n<li>glGetDoublev(),</li>\n<li>glGetFloatv(),</li>\n<li>glGetIntegerv(), </li>\n<li>glGetPointerv(),</li>\n<li>or glIsEnabled().</li>\n</ul>\n</li>\n<li><p>Which of these commands you select depends on what data type you want the answer to be given in. Some state variables have a more specific query command (such as glGetLight*(), glGetError(), or glGetPolygonStipple()). In addition, you can save a collection of state variables on an attribute stack with glPushAttrib() or glPushClientAttrib(), temporarily modify them, and later restore the values with glPopAttrib() or glPopClientAttrib(). For temporary state changes, you should use these commands rather than any of the query commands, since they<code>&amp;#39;</code>re likely to be more efficient.</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>So how to set the state of OpenGL? Although you need to use getXXX to check the current state of OpenGL, but there is no set function as setXXX to set or change the state of OpenGL. OpenGL provides many functions such as glColor<em>, glMaterial</em>, glEnable, glDisable, to give the programmer the control of state change. So there is no need to have setXXX functions for OpenGL. <strong>Important: From the prespective of state machine, it changes its state itself based on the external input, and it is not allowed to change its state directly by the outside, this is the reason why no need of the kind of setXXX function for OpenGL.</strong></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"OpenGL-State-Machine\"><a href=\"#OpenGL-State-Machine\" class=\"headerlink\" title=\"OpenGL State Machine\"></a>OpenGL State Machine</h1><ol>\n<li><p>OpenGL is a state machine, so the first question is what is the state machine?</p>\n<ul>\n<li><p>State machine: is a kind of machine which keep various of state in its memory. It can accept input and change the corresponding state in its memory, and it can also output its current state when getting inqurie. So for a time, and a state, it only have one value for this state. And it may get into a special state(stop state), and it stop to accept input, and turned off.</p>\n</li>\n<li><p>So OpenGL works as a state machine. First of all, OpenGL keep various of states values, such as current color, current viewing and projection transformations, line and polygon stipple patterns, polygon drawing modes, pixel-packing conventions, positions and characteristics of lights, and material properties of the objects being drawn, etc. Programmer puts it into various states (or modes) that then remain in effect until changing them. The current color is a state variable. You can set the current color to white, red, or any other color, and thereafter every object is drawn with that color until you set the current color to something else. The current color is only one of many state variables that OpenGL maintains. Many state variables refer to modes that are enabled or disabled with the command glEnable() or glDisable().</p>\n</li>\n</ul>\n</li>\n<li><p>Each state variable or mode has a default value, and at any point you can query the system for each variables current value. Typically, you use one of the six following commands to do this: </p>\n<ul>\n<li>glGetBooleanv(),  </li>\n<li>glGetDoublev(),</li>\n<li>glGetFloatv(),</li>\n<li>glGetIntegerv(), </li>\n<li>glGetPointerv(),</li>\n<li>or glIsEnabled().</li>\n</ul>\n</li>\n<li><p>Which of these commands you select depends on what data type you want the answer to be given in. Some state variables have a more specific query command (such as glGetLight*(), glGetError(), or glGetPolygonStipple()). In addition, you can save a collection of state variables on an attribute stack with glPushAttrib() or glPushClientAttrib(), temporarily modify them, and later restore the values with glPopAttrib() or glPopClientAttrib(). For temporary state changes, you should use these commands rather than any of the query commands, since they<code>&amp;#39;</code>re likely to be more efficient.</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>So how to set the state of OpenGL? Although you need to use getXXX to check the current state of OpenGL, but there is no set function as setXXX to set or change the state of OpenGL. OpenGL provides many functions such as glColor<em>, glMaterial</em>, glEnable, glDisable, to give the programmer the control of state change. So there is no need to have setXXX functions for OpenGL. <strong>Important: From the prespective of state machine, it changes its state itself based on the external input, and it is not allowed to change its state directly by the outside, this is the reason why no need of the kind of setXXX function for OpenGL.</strong></li>\n</ol>\n"},{"title":"STL Vector与List区别","id":"157","date":"2015-07-13T03:39:40.000Z","_content":"## STL Vector 与 List 区别\n\nvector为存储的对象分配一块连续的地址空间，因此对vector中的元素随机访问效率很高。在vecotor中插入或者删除某个元素，需要将现有元素进行复制，移动。如果vector中存储的对象很大，或者构造函数复杂，则在对现有元素进行拷贝时开销较大，因为拷贝对象要调用拷贝构造函数。对于简单的小对象，vector的效率优于list。vector在每次扩张容量的时候，将容量扩展2倍，这样对于小对象来说，效率是很高的。\n\nlist中的对象是离散存储的，随机访问某个元素需要遍历list。在list中插入元素，尤其是在首尾插入元素，效率很高，只需要改变元素的指针。\n\n综上所述：\n\nvector适用：对象数量变化少，简单对象，随机访问元素频繁\n\nlist适用：对象数量变化大，对象复杂，插入和删除频繁\n\n最大的区别是,list是双向的，而vector是单向的。\n\n因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，一般应遵循下面的原则：\n\n1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector\n\n2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list\n\n3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。\n\n### vector\n\n表示一段连续的内存区域，每个元素被顺序存储在这段内存中，对vector的随机访问效率很高，但对非末尾元素的插和删除则效率非常低。\n\n### deque\n\n也表示一段连续的内存区域，但与vector不同的是它支持高效地在其首部插入和删除元素，它通过两级数组结构来实现，一级表示实际的容器，第二级指向容器的首和尾list表示非连续的内存区域并通过一对指向首尾元素的指针双向链接起来，插入删除效率高，随机访问效率低\n\n### STL\n提供了三个最基本的容器：vector,list,deque。\n\n* vector和built-in数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随即存取，即[]操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。\n\n* list就是数据结构中的双向链表(根据sgi stl源代码)，因此它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随即存取变的非常没有效率，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。\n\n* deque是一个double-ended queue，它的具体实现不太清楚，但知道它具有以下两个特点：它支持[]操作符，也就是支持随即存取，并且和vector的效率相差无几，它支持在两端的操作：push_back,push_front,pop_back,pop_front等，并且在两端操作上list的效率也差不多。\n\n因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，一般应遵循下面的原则：\n\n1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector\n\n2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list\n\n3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。","source":"_posts/STLVectorList.md","raw":"---\ntitle: STL Vector与List区别\nid: 157\ncategories:\n  - C/C++\ndate: 2015-07-12 23:39:40\ntags:\n  - C/C++\n  - STL\n---\n## STL Vector 与 List 区别\n\nvector为存储的对象分配一块连续的地址空间，因此对vector中的元素随机访问效率很高。在vecotor中插入或者删除某个元素，需要将现有元素进行复制，移动。如果vector中存储的对象很大，或者构造函数复杂，则在对现有元素进行拷贝时开销较大，因为拷贝对象要调用拷贝构造函数。对于简单的小对象，vector的效率优于list。vector在每次扩张容量的时候，将容量扩展2倍，这样对于小对象来说，效率是很高的。\n\nlist中的对象是离散存储的，随机访问某个元素需要遍历list。在list中插入元素，尤其是在首尾插入元素，效率很高，只需要改变元素的指针。\n\n综上所述：\n\nvector适用：对象数量变化少，简单对象，随机访问元素频繁\n\nlist适用：对象数量变化大，对象复杂，插入和删除频繁\n\n最大的区别是,list是双向的，而vector是单向的。\n\n因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，一般应遵循下面的原则：\n\n1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector\n\n2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list\n\n3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。\n\n### vector\n\n表示一段连续的内存区域，每个元素被顺序存储在这段内存中，对vector的随机访问效率很高，但对非末尾元素的插和删除则效率非常低。\n\n### deque\n\n也表示一段连续的内存区域，但与vector不同的是它支持高效地在其首部插入和删除元素，它通过两级数组结构来实现，一级表示实际的容器，第二级指向容器的首和尾list表示非连续的内存区域并通过一对指向首尾元素的指针双向链接起来，插入删除效率高，随机访问效率低\n\n### STL\n提供了三个最基本的容器：vector,list,deque。\n\n* vector和built-in数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随即存取，即[]操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。\n\n* list就是数据结构中的双向链表(根据sgi stl源代码)，因此它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随即存取变的非常没有效率，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。\n\n* deque是一个double-ended queue，它的具体实现不太清楚，但知道它具有以下两个特点：它支持[]操作符，也就是支持随即存取，并且和vector的效率相差无几，它支持在两端的操作：push_back,push_front,pop_back,pop_front等，并且在两端操作上list的效率也差不多。\n\n因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，一般应遵循下面的原则：\n\n1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector\n\n2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list\n\n3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。","slug":"STLVectorList","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1u0037lkgu7gte6zgc","content":"<h2 id=\"STL-Vector-与-List-区别\"><a href=\"#STL-Vector-与-List-区别\" class=\"headerlink\" title=\"STL Vector 与 List 区别\"></a>STL Vector 与 List 区别</h2><p>vector为存储的对象分配一块连续的地址空间，因此对vector中的元素随机访问效率很高。在vecotor中插入或者删除某个元素，需要将现有元素进行复制，移动。如果vector中存储的对象很大，或者构造函数复杂，则在对现有元素进行拷贝时开销较大，因为拷贝对象要调用拷贝构造函数。对于简单的小对象，vector的效率优于list。vector在每次扩张容量的时候，将容量扩展2倍，这样对于小对象来说，效率是很高的。</p>\n<p>list中的对象是离散存储的，随机访问某个元素需要遍历list。在list中插入元素，尤其是在首尾插入元素，效率很高，只需要改变元素的指针。</p>\n<p>综上所述：</p>\n<p>vector适用：对象数量变化少，简单对象，随机访问元素频繁</p>\n<p>list适用：对象数量变化大，对象复杂，插入和删除频繁</p>\n<p>最大的区别是,list是双向的，而vector是单向的。</p>\n<p>因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，一般应遵循下面的原则：</p>\n<p>1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector</p>\n<p>2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list</p>\n<p>3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。</p>\n<h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p>表示一段连续的内存区域，每个元素被顺序存储在这段内存中，对vector的随机访问效率很高，但对非末尾元素的插和删除则效率非常低。</p>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>也表示一段连续的内存区域，但与vector不同的是它支持高效地在其首部插入和删除元素，它通过两级数组结构来实现，一级表示实际的容器，第二级指向容器的首和尾list表示非连续的内存区域并通过一对指向首尾元素的指针双向链接起来，插入删除效率高，随机访问效率低</p>\n<h3 id=\"STL\"><a href=\"#STL\" class=\"headerlink\" title=\"STL\"></a>STL</h3><p>提供了三个最基本的容器：vector,list,deque。</p>\n<ul>\n<li><p>vector和built-in数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随即存取，即[]操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。</p>\n</li>\n<li><p>list就是数据结构中的双向链表(根据sgi stl源代码)，因此它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随即存取变的非常没有效率，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。</p>\n</li>\n<li><p>deque是一个double-ended queue，它的具体实现不太清楚，但知道它具有以下两个特点：它支持[]操作符，也就是支持随即存取，并且和vector的效率相差无几，它支持在两端的操作：push_back,push_front,pop_back,pop_front等，并且在两端操作上list的效率也差不多。</p>\n</li>\n</ul>\n<p>因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，一般应遵循下面的原则：</p>\n<p>1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector</p>\n<p>2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list</p>\n<p>3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"STL-Vector-与-List-区别\"><a href=\"#STL-Vector-与-List-区别\" class=\"headerlink\" title=\"STL Vector 与 List 区别\"></a>STL Vector 与 List 区别</h2><p>vector为存储的对象分配一块连续的地址空间，因此对vector中的元素随机访问效率很高。在vecotor中插入或者删除某个元素，需要将现有元素进行复制，移动。如果vector中存储的对象很大，或者构造函数复杂，则在对现有元素进行拷贝时开销较大，因为拷贝对象要调用拷贝构造函数。对于简单的小对象，vector的效率优于list。vector在每次扩张容量的时候，将容量扩展2倍，这样对于小对象来说，效率是很高的。</p>\n<p>list中的对象是离散存储的，随机访问某个元素需要遍历list。在list中插入元素，尤其是在首尾插入元素，效率很高，只需要改变元素的指针。</p>\n<p>综上所述：</p>\n<p>vector适用：对象数量变化少，简单对象，随机访问元素频繁</p>\n<p>list适用：对象数量变化大，对象复杂，插入和删除频繁</p>\n<p>最大的区别是,list是双向的，而vector是单向的。</p>\n<p>因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，一般应遵循下面的原则：</p>\n<p>1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector</p>\n<p>2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list</p>\n<p>3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。</p>\n<h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p>表示一段连续的内存区域，每个元素被顺序存储在这段内存中，对vector的随机访问效率很高，但对非末尾元素的插和删除则效率非常低。</p>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>也表示一段连续的内存区域，但与vector不同的是它支持高效地在其首部插入和删除元素，它通过两级数组结构来实现，一级表示实际的容器，第二级指向容器的首和尾list表示非连续的内存区域并通过一对指向首尾元素的指针双向链接起来，插入删除效率高，随机访问效率低</p>\n<h3 id=\"STL\"><a href=\"#STL\" class=\"headerlink\" title=\"STL\"></a>STL</h3><p>提供了三个最基本的容器：vector,list,deque。</p>\n<ul>\n<li><p>vector和built-in数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随即存取，即[]操作符，但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝，另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。</p>\n</li>\n<li><p>list就是数据结构中的双向链表(根据sgi stl源代码)，因此它的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随即存取变的非常没有效率，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。</p>\n</li>\n<li><p>deque是一个double-ended queue，它的具体实现不太清楚，但知道它具有以下两个特点：它支持[]操作符，也就是支持随即存取，并且和vector的效率相差无几，它支持在两端的操作：push_back,push_front,pop_back,pop_front等，并且在两端操作上list的效率也差不多。</p>\n</li>\n</ul>\n<p>因此在实际使用时，如何选择这三个容器中哪一个，应根据你的需要而定，一般应遵循下面的原则：</p>\n<p>1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector</p>\n<p>2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list</p>\n<p>3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。</p>\n"},{"title":"平淡日子里的刺","id":"508","date":"2015-10-13T01:20:06.000Z","_content":"\n词：韩寒\n曲：宋冬野\n\n在歌舞升平的城市\n忍不住回頭看我的城池\n在我手的 將要丟失\n\n她的幼稚 我的固執 都成為歷史\n破的城市 平淡日子\n她要尋找 生活的刺\n\n生活是這樣子 不如詩\n轉身撞到現實\n又只能如是\n她卻依然 對現實放肆\n等著 美麗的故事被腐蝕\n最後的好夢 漸漸消失\n放下玩具 舉起雙手 都沒有微辭\n\n她的幼稚 我的固執 都成為歷史\n破的城市 平淡日子\n她要尋找 生活的刺\n\n生活是這樣子 不如詩\n轉身撞到現實 又只能如是\n她卻依然 對現實放肆\n等著美麗的故事被腐蝕\n最後的好夢 漸漸消失\n放下玩具 舉起雙手\n都沒有微辭\n\n這是個很久遠的事\n在歌舞升平的城市\n在我手的 將要丟失\n\n<iframe height=400 width=600 src=\"https://www.youtube.com/embed/pIJp6PDCIC8\" frameborder=0 allowfullscreen></iframe>\n","source":"_posts/[Video]平淡日子里的刺.md","raw":"---\ntitle: \"平淡日子里的刺\"\nid: 508\ncategories: \n  - Music\ndate: 2015-10-12 21:20:06\ntags:\n---\n\n词：韩寒\n曲：宋冬野\n\n在歌舞升平的城市\n忍不住回頭看我的城池\n在我手的 將要丟失\n\n她的幼稚 我的固執 都成為歷史\n破的城市 平淡日子\n她要尋找 生活的刺\n\n生活是這樣子 不如詩\n轉身撞到現實\n又只能如是\n她卻依然 對現實放肆\n等著 美麗的故事被腐蝕\n最後的好夢 漸漸消失\n放下玩具 舉起雙手 都沒有微辭\n\n她的幼稚 我的固執 都成為歷史\n破的城市 平淡日子\n她要尋找 生活的刺\n\n生活是這樣子 不如詩\n轉身撞到現實 又只能如是\n她卻依然 對現實放肆\n等著美麗的故事被腐蝕\n最後的好夢 漸漸消失\n放下玩具 舉起雙手\n都沒有微辭\n\n這是個很久遠的事\n在歌舞升平的城市\n在我手的 將要丟失\n\n<iframe height=400 width=600 src=\"https://www.youtube.com/embed/pIJp6PDCIC8\" frameborder=0 allowfullscreen></iframe>\n","slug":"[Video]平淡日子里的刺","published":1,"updated":"2019-02-12T00:36:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1v003blkguxx341i0r","content":"<p>词：韩寒<br>曲：宋冬野</p>\n<p>在歌舞升平的城市<br>忍不住回頭看我的城池<br>在我手的 將要丟失</p>\n<p>她的幼稚 我的固執 都成為歷史<br>破的城市 平淡日子<br>她要尋找 生活的刺</p>\n<p>生活是這樣子 不如詩<br>轉身撞到現實<br>又只能如是<br>她卻依然 對現實放肆<br>等著 美麗的故事被腐蝕<br>最後的好夢 漸漸消失<br>放下玩具 舉起雙手 都沒有微辭</p>\n<p>她的幼稚 我的固執 都成為歷史<br>破的城市 平淡日子<br>她要尋找 生活的刺</p>\n<p>生活是這樣子 不如詩<br>轉身撞到現實 又只能如是<br>她卻依然 對現實放肆<br>等著美麗的故事被腐蝕<br>最後的好夢 漸漸消失<br>放下玩具 舉起雙手<br>都沒有微辭</p>\n<p>這是個很久遠的事<br>在歌舞升平的城市<br>在我手的 將要丟失</p>\n<iframe height=\"400\" width=\"600\" src=\"https://www.youtube.com/embed/pIJp6PDCIC8\" frameborder=\"0\" allowfullscreen></iframe>\n","site":{"data":{}},"excerpt":"","more":"<p>词：韩寒<br>曲：宋冬野</p>\n<p>在歌舞升平的城市<br>忍不住回頭看我的城池<br>在我手的 將要丟失</p>\n<p>她的幼稚 我的固執 都成為歷史<br>破的城市 平淡日子<br>她要尋找 生活的刺</p>\n<p>生活是這樣子 不如詩<br>轉身撞到現實<br>又只能如是<br>她卻依然 對現實放肆<br>等著 美麗的故事被腐蝕<br>最後的好夢 漸漸消失<br>放下玩具 舉起雙手 都沒有微辭</p>\n<p>她的幼稚 我的固執 都成為歷史<br>破的城市 平淡日子<br>她要尋找 生活的刺</p>\n<p>生活是這樣子 不如詩<br>轉身撞到現實 又只能如是<br>她卻依然 對現實放肆<br>等著美麗的故事被腐蝕<br>最後的好夢 漸漸消失<br>放下玩具 舉起雙手<br>都沒有微辭</p>\n<p>這是個很久遠的事<br>在歌舞升平的城市<br>在我手的 將要丟失</p>\n<iframe height=\"400\" width=\"600\" src=\"https://www.youtube.com/embed/pIJp6PDCIC8\" frameborder=\"0\" allowfullscreen></iframe>\n"},{"title":"[Issue] Xcode debugging cannot see the value of the local variable","id":"108","date":"2015-04-24T06:08:19.000Z","_content":"\n### Resolution:\n\n1.in Scheme Setting: set run to debug\n\n[![QQ20140401-2](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-2-300x149.png)](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-2.png)\n\n2.in build settings, set optim to O0\n\n[![QQ20140401-3](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-3-300x139.png)](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-3.png)\n\n3.build settings, Custom Compiler Flags change O2 to g.\n\n[![QQ20140401-1](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-1-300x90.png)](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-1.png)\n","source":"_posts/XcodeCantSeeLocalVariable.md","raw":"---\ntitle: \"[Issue] Xcode debugging cannot see the value of the local variable\"\nid: 108\ncategories:\n  - Issues Solution\ndate: 2015-04-24 02:08:19\ntags:\n---\n\n### Resolution:\n\n1.in Scheme Setting: set run to debug\n\n[![QQ20140401-2](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-2-300x149.png)](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-2.png)\n\n2.in build settings, set optim to O0\n\n[![QQ20140401-3](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-3-300x139.png)](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-3.png)\n\n3.build settings, Custom Compiler Flags change O2 to g.\n\n[![QQ20140401-1](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-1-300x90.png)](https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-1.png)\n","slug":"XcodeCantSeeLocalVariable","published":1,"updated":"2019-02-12T00:34:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1w003elkgufrfpm1aj","content":"<h3 id=\"Resolution\"><a href=\"#Resolution\" class=\"headerlink\" title=\"Resolution:\"></a>Resolution:</h3><p>1.in Scheme Setting: set run to debug</p>\n<p><a href=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-2-300x149.png\" alt=\"QQ20140401-2\"></a></p>\n<p>2.in build settings, set optim to O0</p>\n<p><a href=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-3.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-3-300x139.png\" alt=\"QQ20140401-3\"></a></p>\n<p>3.build settings, Custom Compiler Flags change O2 to g.</p>\n<p><a href=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-1-300x90.png\" alt=\"QQ20140401-1\"></a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Resolution\"><a href=\"#Resolution\" class=\"headerlink\" title=\"Resolution:\"></a>Resolution:</h3><p>1.in Scheme Setting: set run to debug</p>\n<p><a href=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-2.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-2-300x149.png\" alt=\"QQ20140401-2\"></a></p>\n<p>2.in build settings, set optim to O0</p>\n<p><a href=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-3.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-3-300x139.png\" alt=\"QQ20140401-3\"></a></p>\n<p>3.build settings, Custom Compiler Flags change O2 to g.</p>\n<p><a href=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://laoyur.com/wp-content/uploads/2014/04/QQ20140401-1-300x90.png\" alt=\"QQ20140401-1\"></a></p>\n"},{"title":"C/C++ Union，Struct, Enumerations","id":"166","date":"2015-07-20T07:24:55.000Z","_content":"\n**C Enumeration:**\n\nEnumeration is a set of the ordered elements. Each element corresponds to a number. If you don`t define the corresponding number for each element, they will corresponding from 0 to n by default. And you can define the corresponding number for the element, and the undefined element will corresponding to the number of previous element plus 1 since they are stored in the continuous memory addresses. The enum element are constant, they can`t be changed after definition.\n\n枚举类型是排序好的一组元素集合，每一个元素可对应一个数字，程序员可以给元素定义它的对应数字，默认的是从0开始一个一个逐次对应，没有定义对应数字的元素默认的对应数字比其前一个元素对应的数字大1，因为他们默认的是保存在地址连续的一串内存当中。\n\n*   枚举元素是常量，定义之后不能赋值。\n*   元素有值，编译时按定义时的顺序使它们的值为0，1，2...\n*   枚举值可以作比较\n*   一个整数不能直接赋值给枚举变量，要转换为相应的枚举类型。\n\n**C Union**\n\nIn C programming, sometimes, we need to store some different type of variable in a same memory block. That`s a kind of coverage technique, the value of the latter variable will cover the previous variable. This structure which allows several different types of variable share a same memory block is called **Union** in C.\n\n在进行某些算法的C语言编程的时候，需要使几种不同类型的变量存放到同一段内存单元中。也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，在C语言中，被称作**共用体**类型结构，简称共用体，也叫联合体。\n\n*   每一瞬间只能存放其中一种。\n*   存放的是最后一次存放的成员\n*   共用体变量的地址和其各成员的地址都是同一地址\n*   不能对共用体变量名赋值，也不能在初始化时赋值\n*   共用体变量不能作为函数参数\n*   可以在结构体中使用共用体变量\n\n**C Struct**\n\nIn C, struct is a kind of data structure, belong to aggregate data type. Struct can be defined as variable, pointer and array. It is a set of different types of data, these data elements are members of struct, and the members can be accessed by their names.\n\n在C语言中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。将不同类型的数据组合成一个整体以便引用，把它们组织成一个组合项, 在一个组合项中包含若干个类型不同的数据项。成为结构体。struct structName{int a = 0, char b =&quot;h&quot;, double c = 1.5;} structVariableName1, structVariableName2;\n\n**Difference between Union and Struct:**\n\n*   The memory size of struct equal the sum of the length of all members of the struct, each member have its own memory block.\n*   结构体变量所占内存长度是各成员的内存长度之和，每个成员分别占有其自己的内存单元。\n*   The memory size of union equal the memory length of member which has the longest size in the union\n*   共用体变量所占的内存长度等于最长的成员的长度.\n*   Sample:\n*   结构体共用体使用举例：\n\n```C++\n\tunion uq1 {\n\n\t\tlong value; /*这就是输入的那个32位数*/\n\n\t\tstruct {\n\n\t\t\tshort lowbit; /*这是低位*/\n\n\t\t\tshort highbit; /*这是高位*/\n\n\t\t} bit;\n\n\t};\n```\n\n\t整个共用体还是4字节没有改变. 解决那题,就象这样:\n\n```C++\n\tuq1 u;\n\n\tlong v;\n\n\tv=0x00FF00FF; /*就先假设输入的数是这个*/\n\n\tu.value=v;\n\n\tprintf(&high=%d,low=%dn&u.bit.highbit, u.bit.lowbit);\n```\n\n\t这题的结果应该是: high=255, low=255\n\n**C++ Struct**\n\nIn c strut can not have method member. But in c++, the struct is extended, it can have method member. The difference between c++ struct and class is that the method is public default in struct, but in class, the default type of method is private.\n\n在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private.\n\n**The difference between C++ struct and Class**\n\n*   （1）class中默认的成员访问权限是private的，而struct中则是public的。\n*   （2）从class继承默认是private继承，而从struct继承默认是public继承。\n*   （3）C++的结构体声明不必有struct关键字，而C语言的结构体声明必须带有关键字（使用typedef别名定义除外）。","source":"_posts/UnionStruct.md","raw":"---\ntitle: C/C++ Union，Struct, Enumerations\ntags:\n  - C/C++\nid: 166\ncategories:\n  - C/C++\ndate: 2015-07-20 03:24:55\n---\n\n**C Enumeration:**\n\nEnumeration is a set of the ordered elements. Each element corresponds to a number. If you don`t define the corresponding number for each element, they will corresponding from 0 to n by default. And you can define the corresponding number for the element, and the undefined element will corresponding to the number of previous element plus 1 since they are stored in the continuous memory addresses. The enum element are constant, they can`t be changed after definition.\n\n枚举类型是排序好的一组元素集合，每一个元素可对应一个数字，程序员可以给元素定义它的对应数字，默认的是从0开始一个一个逐次对应，没有定义对应数字的元素默认的对应数字比其前一个元素对应的数字大1，因为他们默认的是保存在地址连续的一串内存当中。\n\n*   枚举元素是常量，定义之后不能赋值。\n*   元素有值，编译时按定义时的顺序使它们的值为0，1，2...\n*   枚举值可以作比较\n*   一个整数不能直接赋值给枚举变量，要转换为相应的枚举类型。\n\n**C Union**\n\nIn C programming, sometimes, we need to store some different type of variable in a same memory block. That`s a kind of coverage technique, the value of the latter variable will cover the previous variable. This structure which allows several different types of variable share a same memory block is called **Union** in C.\n\n在进行某些算法的C语言编程的时候，需要使几种不同类型的变量存放到同一段内存单元中。也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，在C语言中，被称作**共用体**类型结构，简称共用体，也叫联合体。\n\n*   每一瞬间只能存放其中一种。\n*   存放的是最后一次存放的成员\n*   共用体变量的地址和其各成员的地址都是同一地址\n*   不能对共用体变量名赋值，也不能在初始化时赋值\n*   共用体变量不能作为函数参数\n*   可以在结构体中使用共用体变量\n\n**C Struct**\n\nIn C, struct is a kind of data structure, belong to aggregate data type. Struct can be defined as variable, pointer and array. It is a set of different types of data, these data elements are members of struct, and the members can be accessed by their names.\n\n在C语言中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。将不同类型的数据组合成一个整体以便引用，把它们组织成一个组合项, 在一个组合项中包含若干个类型不同的数据项。成为结构体。struct structName{int a = 0, char b =&quot;h&quot;, double c = 1.5;} structVariableName1, structVariableName2;\n\n**Difference between Union and Struct:**\n\n*   The memory size of struct equal the sum of the length of all members of the struct, each member have its own memory block.\n*   结构体变量所占内存长度是各成员的内存长度之和，每个成员分别占有其自己的内存单元。\n*   The memory size of union equal the memory length of member which has the longest size in the union\n*   共用体变量所占的内存长度等于最长的成员的长度.\n*   Sample:\n*   结构体共用体使用举例：\n\n```C++\n\tunion uq1 {\n\n\t\tlong value; /*这就是输入的那个32位数*/\n\n\t\tstruct {\n\n\t\t\tshort lowbit; /*这是低位*/\n\n\t\t\tshort highbit; /*这是高位*/\n\n\t\t} bit;\n\n\t};\n```\n\n\t整个共用体还是4字节没有改变. 解决那题,就象这样:\n\n```C++\n\tuq1 u;\n\n\tlong v;\n\n\tv=0x00FF00FF; /*就先假设输入的数是这个*/\n\n\tu.value=v;\n\n\tprintf(&high=%d,low=%dn&u.bit.highbit, u.bit.lowbit);\n```\n\n\t这题的结果应该是: high=255, low=255\n\n**C++ Struct**\n\nIn c strut can not have method member. But in c++, the struct is extended, it can have method member. The difference between c++ struct and class is that the method is public default in struct, but in class, the default type of method is private.\n\n在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private.\n\n**The difference between C++ struct and Class**\n\n*   （1）class中默认的成员访问权限是private的，而struct中则是public的。\n*   （2）从class继承默认是private继承，而从struct继承默认是public继承。\n*   （3）C++的结构体声明不必有struct关键字，而C语言的结构体声明必须带有关键字（使用typedef别名定义除外）。","slug":"UnionStruct","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1x003ilkguyj18b04h","content":"<p><strong>C Enumeration:</strong></p>\n<p>Enumeration is a set of the ordered elements. Each element corresponds to a number. If you don<code>t define the corresponding number for each element, they will corresponding from 0 to n by default. And you can define the corresponding number for the element, and the undefined element will corresponding to the number of previous element plus 1 since they are stored in the continuous memory addresses. The enum element are constant, they can</code>t be changed after definition.</p>\n<p>枚举类型是排序好的一组元素集合，每一个元素可对应一个数字，程序员可以给元素定义它的对应数字，默认的是从0开始一个一个逐次对应，没有定义对应数字的元素默认的对应数字比其前一个元素对应的数字大1，因为他们默认的是保存在地址连续的一串内存当中。</p>\n<ul>\n<li>枚举元素是常量，定义之后不能赋值。</li>\n<li>元素有值，编译时按定义时的顺序使它们的值为0，1，2…</li>\n<li>枚举值可以作比较</li>\n<li>一个整数不能直接赋值给枚举变量，要转换为相应的枚举类型。</li>\n</ul>\n<p><strong>C Union</strong></p>\n<p>In C programming, sometimes, we need to store some different type of variable in a same memory block. That`s a kind of coverage technique, the value of the latter variable will cover the previous variable. This structure which allows several different types of variable share a same memory block is called <strong>Union</strong> in C.</p>\n<p>在进行某些算法的C语言编程的时候，需要使几种不同类型的变量存放到同一段内存单元中。也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，在C语言中，被称作<strong>共用体</strong>类型结构，简称共用体，也叫联合体。</p>\n<ul>\n<li>每一瞬间只能存放其中一种。</li>\n<li>存放的是最后一次存放的成员</li>\n<li>共用体变量的地址和其各成员的地址都是同一地址</li>\n<li>不能对共用体变量名赋值，也不能在初始化时赋值</li>\n<li>共用体变量不能作为函数参数</li>\n<li>可以在结构体中使用共用体变量</li>\n</ul>\n<p><strong>C Struct</strong></p>\n<p>In C, struct is a kind of data structure, belong to aggregate data type. Struct can be defined as variable, pointer and array. It is a set of different types of data, these data elements are members of struct, and the members can be accessed by their names.</p>\n<p>在C语言中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。将不同类型的数据组合成一个整体以便引用，把它们组织成一个组合项, 在一个组合项中包含若干个类型不同的数据项。成为结构体。struct structName{int a = 0, char b =&quot;h&quot;, double c = 1.5;} structVariableName1, structVariableName2;</p>\n<p><strong>Difference between Union and Struct:</strong></p>\n<ul>\n<li>The memory size of struct equal the sum of the length of all members of the struct, each member have its own memory block.</li>\n<li>结构体变量所占内存长度是各成员的内存长度之和，每个成员分别占有其自己的内存单元。</li>\n<li>The memory size of union equal the memory length of member which has the longest size in the union</li>\n<li>共用体变量所占的内存长度等于最长的成员的长度.</li>\n<li>Sample:</li>\n<li>结构体共用体使用举例：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">union</span> uq1 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> value; <span class=\"comment\">/*这就是输入的那个32位数*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">short</span> lowbit; <span class=\"comment\">/*这是低位*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">short</span> highbit; <span class=\"comment\">/*这是高位*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; bit;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<pre><code>整个共用体还是4字节没有改变. 解决那题,就象这样:\n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uq1 u;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> v;</span><br><span class=\"line\"></span><br><span class=\"line\">v=<span class=\"number\">0x00FF00FF</span>; <span class=\"comment\">/*就先假设输入的数是这个*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">u.value=v;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(&amp;high=%d,low=%dn&amp;u.bit.highbit, u.bit.lowbit);</span><br></pre></td></tr></table></figure>\n<pre><code>这题的结果应该是: high=255, low=255\n</code></pre><p><strong>C++ Struct</strong></p>\n<p>In c strut can not have method member. But in c++, the struct is extended, it can have method member. The difference between c++ struct and class is that the method is public default in struct, but in class, the default type of method is private.</p>\n<p>在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private.</p>\n<p><strong>The difference between C++ struct and Class</strong></p>\n<ul>\n<li>（1）class中默认的成员访问权限是private的，而struct中则是public的。</li>\n<li>（2）从class继承默认是private继承，而从struct继承默认是public继承。</li>\n<li>（3）C++的结构体声明不必有struct关键字，而C语言的结构体声明必须带有关键字（使用typedef别名定义除外）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>C Enumeration:</strong></p>\n<p>Enumeration is a set of the ordered elements. Each element corresponds to a number. If you don<code>t define the corresponding number for each element, they will corresponding from 0 to n by default. And you can define the corresponding number for the element, and the undefined element will corresponding to the number of previous element plus 1 since they are stored in the continuous memory addresses. The enum element are constant, they can</code>t be changed after definition.</p>\n<p>枚举类型是排序好的一组元素集合，每一个元素可对应一个数字，程序员可以给元素定义它的对应数字，默认的是从0开始一个一个逐次对应，没有定义对应数字的元素默认的对应数字比其前一个元素对应的数字大1，因为他们默认的是保存在地址连续的一串内存当中。</p>\n<ul>\n<li>枚举元素是常量，定义之后不能赋值。</li>\n<li>元素有值，编译时按定义时的顺序使它们的值为0，1，2…</li>\n<li>枚举值可以作比较</li>\n<li>一个整数不能直接赋值给枚举变量，要转换为相应的枚举类型。</li>\n</ul>\n<p><strong>C Union</strong></p>\n<p>In C programming, sometimes, we need to store some different type of variable in a same memory block. That`s a kind of coverage technique, the value of the latter variable will cover the previous variable. This structure which allows several different types of variable share a same memory block is called <strong>Union</strong> in C.</p>\n<p>在进行某些算法的C语言编程的时候，需要使几种不同类型的变量存放到同一段内存单元中。也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，在C语言中，被称作<strong>共用体</strong>类型结构，简称共用体，也叫联合体。</p>\n<ul>\n<li>每一瞬间只能存放其中一种。</li>\n<li>存放的是最后一次存放的成员</li>\n<li>共用体变量的地址和其各成员的地址都是同一地址</li>\n<li>不能对共用体变量名赋值，也不能在初始化时赋值</li>\n<li>共用体变量不能作为函数参数</li>\n<li>可以在结构体中使用共用体变量</li>\n</ul>\n<p><strong>C Struct</strong></p>\n<p>In C, struct is a kind of data structure, belong to aggregate data type. Struct can be defined as variable, pointer and array. It is a set of different types of data, these data elements are members of struct, and the members can be accessed by their names.</p>\n<p>在C语言中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。将不同类型的数据组合成一个整体以便引用，把它们组织成一个组合项, 在一个组合项中包含若干个类型不同的数据项。成为结构体。struct structName{int a = 0, char b =&quot;h&quot;, double c = 1.5;} structVariableName1, structVariableName2;</p>\n<p><strong>Difference between Union and Struct:</strong></p>\n<ul>\n<li>The memory size of struct equal the sum of the length of all members of the struct, each member have its own memory block.</li>\n<li>结构体变量所占内存长度是各成员的内存长度之和，每个成员分别占有其自己的内存单元。</li>\n<li>The memory size of union equal the memory length of member which has the longest size in the union</li>\n<li>共用体变量所占的内存长度等于最长的成员的长度.</li>\n<li>Sample:</li>\n<li>结构体共用体使用举例：</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">union</span> uq1 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> value; <span class=\"comment\">/*这就是输入的那个32位数*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">short</span> lowbit; <span class=\"comment\">/*这是低位*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">short</span> highbit; <span class=\"comment\">/*这是高位*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; bit;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<pre><code>整个共用体还是4字节没有改变. 解决那题,就象这样:\n</code></pre><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uq1 u;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> v;</span><br><span class=\"line\"></span><br><span class=\"line\">v=<span class=\"number\">0x00FF00FF</span>; <span class=\"comment\">/*就先假设输入的数是这个*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">u.value=v;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(&amp;high=%d,low=%dn&amp;u.bit.highbit, u.bit.lowbit);</span><br></pre></td></tr></table></figure>\n<pre><code>这题的结果应该是: high=255, low=255\n</code></pre><p><strong>C++ Struct</strong></p>\n<p>In c strut can not have method member. But in c++, the struct is extended, it can have method member. The difference between c++ struct and class is that the method is public default in struct, but in class, the default type of method is private.</p>\n<p>在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private.</p>\n<p><strong>The difference between C++ struct and Class</strong></p>\n<ul>\n<li>（1）class中默认的成员访问权限是private的，而struct中则是public的。</li>\n<li>（2）从class继承默认是private继承，而从struct继承默认是public继承。</li>\n<li>（3）C++的结构体声明不必有struct关键字，而C语言的结构体声明必须带有关键字（使用typedef别名定义除外）。</li>\n</ul>\n"},{"title":"我想和你虚度时光","id":"486","date":"2015-09-17T23:13:46.000Z","_content":"\n诗：李元胜\n曲：程璧 莫西子詩\n\n我想和你虛度時光，比如低頭看魚\n比如把茶杯留在桌子上，離開\n浪費它們好看的陰影\n\n我還想連落日一起浪費，比如散步\n一直消磨到星光滿天\n我還要浪費風起的時候\n坐在走廊發呆，直到你眼中烏雲\n全部被吹到窗外\n\n我已經虛度了世界，它經過我\n疲倦，又像從未被愛過\n但是明天我還要這樣，虛度，我還要這樣\n滿目的花草，生活應該像它們一樣美好\n一樣無意義，像被虛度的電影\n比如靠在欄杆上，低頭看水的鏡子\n直到所有被虛度的事物\n在我們身後，長出薄薄的翅膀\n\n我已經虛度了世界，它經過我\n疲倦，又像從未被愛過\n但是明天我還要這樣，虛度，我還要這樣\n我想和你互相浪費\n一起虛度短的沉默，長的無意義\n一起消磨精緻而蒼老的宇宙\n\n\n<iframe height=460 width=600 src=\"https://www.youtube.com/embed/AK6pJmeqR6M\" frameborder=0 allowfullscreen></iframe>","source":"_posts/[Video]我想和你虚度时光.md","raw":"---\ntitle: 我想和你虚度时光\nid: 486\ncategories:\n  - Music\ndate: 2015-09-17 19:13:46\ntags:\n---\n\n诗：李元胜\n曲：程璧 莫西子詩\n\n我想和你虛度時光，比如低頭看魚\n比如把茶杯留在桌子上，離開\n浪費它們好看的陰影\n\n我還想連落日一起浪費，比如散步\n一直消磨到星光滿天\n我還要浪費風起的時候\n坐在走廊發呆，直到你眼中烏雲\n全部被吹到窗外\n\n我已經虛度了世界，它經過我\n疲倦，又像從未被愛過\n但是明天我還要這樣，虛度，我還要這樣\n滿目的花草，生活應該像它們一樣美好\n一樣無意義，像被虛度的電影\n比如靠在欄杆上，低頭看水的鏡子\n直到所有被虛度的事物\n在我們身後，長出薄薄的翅膀\n\n我已經虛度了世界，它經過我\n疲倦，又像從未被愛過\n但是明天我還要這樣，虛度，我還要這樣\n我想和你互相浪費\n一起虛度短的沉默，長的無意義\n一起消磨精緻而蒼老的宇宙\n\n\n<iframe height=460 width=600 src=\"https://www.youtube.com/embed/AK6pJmeqR6M\" frameborder=0 allowfullscreen></iframe>","slug":"[Video]我想和你虚度时光","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1y003klkgufttts7zu","content":"<p>诗：李元胜<br>曲：程璧 莫西子詩</p>\n<p>我想和你虛度時光，比如低頭看魚<br>比如把茶杯留在桌子上，離開<br>浪費它們好看的陰影</p>\n<p>我還想連落日一起浪費，比如散步<br>一直消磨到星光滿天<br>我還要浪費風起的時候<br>坐在走廊發呆，直到你眼中烏雲<br>全部被吹到窗外</p>\n<p>我已經虛度了世界，它經過我<br>疲倦，又像從未被愛過<br>但是明天我還要這樣，虛度，我還要這樣<br>滿目的花草，生活應該像它們一樣美好<br>一樣無意義，像被虛度的電影<br>比如靠在欄杆上，低頭看水的鏡子<br>直到所有被虛度的事物<br>在我們身後，長出薄薄的翅膀</p>\n<p>我已經虛度了世界，它經過我<br>疲倦，又像從未被愛過<br>但是明天我還要這樣，虛度，我還要這樣<br>我想和你互相浪費<br>一起虛度短的沉默，長的無意義<br>一起消磨精緻而蒼老的宇宙</p>\n<iframe height=\"460\" width=\"600\" src=\"https://www.youtube.com/embed/AK6pJmeqR6M\" frameborder=\"0\" allowfullscreen></iframe>","site":{"data":{}},"excerpt":"","more":"<p>诗：李元胜<br>曲：程璧 莫西子詩</p>\n<p>我想和你虛度時光，比如低頭看魚<br>比如把茶杯留在桌子上，離開<br>浪費它們好看的陰影</p>\n<p>我還想連落日一起浪費，比如散步<br>一直消磨到星光滿天<br>我還要浪費風起的時候<br>坐在走廊發呆，直到你眼中烏雲<br>全部被吹到窗外</p>\n<p>我已經虛度了世界，它經過我<br>疲倦，又像從未被愛過<br>但是明天我還要這樣，虛度，我還要這樣<br>滿目的花草，生活應該像它們一樣美好<br>一樣無意義，像被虛度的電影<br>比如靠在欄杆上，低頭看水的鏡子<br>直到所有被虛度的事物<br>在我們身後，長出薄薄的翅膀</p>\n<p>我已經虛度了世界，它經過我<br>疲倦，又像從未被愛過<br>但是明天我還要這樣，虛度，我還要這樣<br>我想和你互相浪費<br>一起虛度短的沉默，長的無意義<br>一起消磨精緻而蒼老的宇宙</p>\n<iframe height=\"460\" width=\"600\" src=\"https://www.youtube.com/embed/AK6pJmeqR6M\" frameborder=\"0\" allowfullscreen></iframe>"},{"title":"牡丹亭外-陈升","id":"512","date":"2015-11-04T02:06:35.000Z","_content":"\n词曲：陈升\n\n为救李郎离家园 谁料皇榜中状元\n中状元 着红袍\n帽插宫花好啊 好新鲜\n李郎一梦已过往 风流人儿如今在何方\n从古到今说来慌 不过是情而已\n\n这人间苦什么 怕不能遇见你\n这世界有点假 可我莫名爱上她\n黄粱一梦二十年 依旧是不懂爱也不懂情\n写歌的人假正经啊 听歌的人最无情\n\n牡丹亭外雨纷纷 谁是归人说不准\n是归人啊你说分明 你把我心放哪儿\n黄粱一梦二十年 依旧是不懂爱也不懂情\n写歌的人假正经啊 听歌的人最无情\n\n可我最爱是天然 风流人儿如今在何方\n不管是谁啊 躲不过 还是情而已\n你问我怕什么 怕不能遇见你\n是否你走过了我身边 恍恍惑惑一瞬间\n黄粱一梦二十年 依旧是不懂爱也不懂情\n写歌的人断了魂啊 听歌的人最无情\n\n为救李郎离家园 谁料皇榜中状元 \n中状元 着红袍\n帽插宫花好啊 好新鲜\n\n<iframe height=400 width=600 src=\"https://www.youtube.com/embed/8jo0Xg9iZAQ\" frameborder=0 allowfullscreen></iframe>","source":"_posts/[Video]牡丹亭外.md","raw":"---\ntitle: 牡丹亭外-陈升\nid: 512\ncategories:\n  - Music\ndate: 2015-11-03 21:06:35\ntags:\n---\n\n词曲：陈升\n\n为救李郎离家园 谁料皇榜中状元\n中状元 着红袍\n帽插宫花好啊 好新鲜\n李郎一梦已过往 风流人儿如今在何方\n从古到今说来慌 不过是情而已\n\n这人间苦什么 怕不能遇见你\n这世界有点假 可我莫名爱上她\n黄粱一梦二十年 依旧是不懂爱也不懂情\n写歌的人假正经啊 听歌的人最无情\n\n牡丹亭外雨纷纷 谁是归人说不准\n是归人啊你说分明 你把我心放哪儿\n黄粱一梦二十年 依旧是不懂爱也不懂情\n写歌的人假正经啊 听歌的人最无情\n\n可我最爱是天然 风流人儿如今在何方\n不管是谁啊 躲不过 还是情而已\n你问我怕什么 怕不能遇见你\n是否你走过了我身边 恍恍惑惑一瞬间\n黄粱一梦二十年 依旧是不懂爱也不懂情\n写歌的人断了魂啊 听歌的人最无情\n\n为救李郎离家园 谁料皇榜中状元 \n中状元 着红袍\n帽插宫花好啊 好新鲜\n\n<iframe height=400 width=600 src=\"https://www.youtube.com/embed/8jo0Xg9iZAQ\" frameborder=0 allowfullscreen></iframe>","slug":"[Video]牡丹亭外","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk1z003nlkguw517trii","content":"<p>词曲：陈升</p>\n<p>为救李郎离家园 谁料皇榜中状元<br>中状元 着红袍<br>帽插宫花好啊 好新鲜<br>李郎一梦已过往 风流人儿如今在何方<br>从古到今说来慌 不过是情而已</p>\n<p>这人间苦什么 怕不能遇见你<br>这世界有点假 可我莫名爱上她<br>黄粱一梦二十年 依旧是不懂爱也不懂情<br>写歌的人假正经啊 听歌的人最无情</p>\n<p>牡丹亭外雨纷纷 谁是归人说不准<br>是归人啊你说分明 你把我心放哪儿<br>黄粱一梦二十年 依旧是不懂爱也不懂情<br>写歌的人假正经啊 听歌的人最无情</p>\n<p>可我最爱是天然 风流人儿如今在何方<br>不管是谁啊 躲不过 还是情而已<br>你问我怕什么 怕不能遇见你<br>是否你走过了我身边 恍恍惑惑一瞬间<br>黄粱一梦二十年 依旧是不懂爱也不懂情<br>写歌的人断了魂啊 听歌的人最无情</p>\n<p>为救李郎离家园 谁料皇榜中状元<br>中状元 着红袍<br>帽插宫花好啊 好新鲜</p>\n<iframe height=\"400\" width=\"600\" src=\"https://www.youtube.com/embed/8jo0Xg9iZAQ\" frameborder=\"0\" allowfullscreen></iframe>","site":{"data":{}},"excerpt":"","more":"<p>词曲：陈升</p>\n<p>为救李郎离家园 谁料皇榜中状元<br>中状元 着红袍<br>帽插宫花好啊 好新鲜<br>李郎一梦已过往 风流人儿如今在何方<br>从古到今说来慌 不过是情而已</p>\n<p>这人间苦什么 怕不能遇见你<br>这世界有点假 可我莫名爱上她<br>黄粱一梦二十年 依旧是不懂爱也不懂情<br>写歌的人假正经啊 听歌的人最无情</p>\n<p>牡丹亭外雨纷纷 谁是归人说不准<br>是归人啊你说分明 你把我心放哪儿<br>黄粱一梦二十年 依旧是不懂爱也不懂情<br>写歌的人假正经啊 听歌的人最无情</p>\n<p>可我最爱是天然 风流人儿如今在何方<br>不管是谁啊 躲不过 还是情而已<br>你问我怕什么 怕不能遇见你<br>是否你走过了我身边 恍恍惑惑一瞬间<br>黄粱一梦二十年 依旧是不懂爱也不懂情<br>写歌的人断了魂啊 听歌的人最无情</p>\n<p>为救李郎离家园 谁料皇榜中状元<br>中状元 着红袍<br>帽插宫花好啊 好新鲜</p>\n<iframe height=\"400\" width=\"600\" src=\"https://www.youtube.com/embed/8jo0Xg9iZAQ\" frameborder=\"0\" allowfullscreen></iframe>"},{"title":"Vi Commands","id":"121","date":"2015-05-27T01:14:20.000Z","_content":"\n## 基本命令\n\n### 进入vi的命令\n\tvi filename :打开或新建文件，并将光标置于第一行首\n\tvi +n filename ：打开文件，并将光标置于第n行首\n\tvi + filename ：打开文件，并将光标置于最后一行首\n\tvi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处\n\tvi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename\n\tvi filename....filename ：打开多个文件，依次进行编辑\n\n### 移动光标类命令\n\th ：光标左移一个字符\n\tl ：光标右移一个字符\n\tspace：光标右移一个字符\n\tBackspace：光标左移一个字符\n\tk或Ctrl+p：光标上移一行\n\tj或Ctrl+n ：光标下移一行\n\tEnter ：光标下移一行\n\tw或W ：光标右移一个字至字首\n\tb或B ：光标左移一个字至字首\n\te或E ：光标右移一个字至字尾\n\t) ：光标移至句尾\n\t( ：光标移至句首\n\t}：光标移至段落开头\n\t{：光标移至段落结尾\n\tnG：光标移至第n行首\n\tn+：光标下移n行\n\tn-：光标上移n行\n\tn$：光标移至第n行尾\n\tH ：光标移至屏幕顶行\n\tM ：光标移至屏幕中间行\n\tL ：光标移至屏幕最后行\n\t0：（注意是数字零）光标移至当前行首\n\t$：光标移至当前行尾\n\n### 屏幕翻滚类命令\n\tCtrl+u：向文件首翻半屏\n\tCtrl+d：向文件尾翻半屏\n\tCtrl+f：向文件尾翻一屏\n\tCtrl＋b；向文件首翻一屏\n\tnz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。\n\n### 插入文本类命令\n\ti ：在光标前\n\tI ：在当前行首\n\ta：光标后\n\tA：在当前行尾\n\to：在当前行之下新开一行\n\tO：在当前行之上新开一行\n\tr：替换当前字符\n\tR：替换当前字符及其后的字符，直至按ESC键\n\ts：从当前光标位置处开始，以输入的文本替代指定数目的字符\n\tS：删除指定数目的行，并以所输入文本代替之\n\tncw或nCW：修改指定数目的字\n\tnCC：修改指定数目的行\n\n### 删除命令\n\tndw或ndW：删除光标处开始及其后的n-1个字\n\tdo：删至行首\n\td$：删至行尾\n\tndd：删除当前行及其后n-1行\n\tx或X：删除一个字符，x删除光标后的，而X删除光标前的\n\tCtrl+u：删除输入方式下所输入的文本\n\n### 搜索及替换命令\n\t/pattern：从光标开始处向文件尾搜索pattern\n\t?pattern：从光标开始处向文件首搜索pattern\n\tn：在同一方向重复上一次搜索命令\n\tN：在反方向上重复上一次搜索命令\n\t：s/p1/p2/g：将当前行中所有p1均用p2替代\n\t：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代\n\t：g/p1/s//p2/g：将文件中所有p1均用p2替换\n\n### 选项设置\n\tall：列出所有选项设置情况\n\tterm：设置终端类型\n\tignorance：在搜索中忽略大小写\n\tlist：显示制表位(Ctrl+I)和行尾标志（$)\n\tnumber：显示行号\n\treport：显示由面向行的命令修改过的数目\n\tterse：显示简短的警告信息\n\twarn：在转到别的文件时若没保存当前文件则显示NO write信息\n\tnomagic：允许在搜索模式中，使用前面不带“”的特殊字符\n\tnowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始\n\tmesg：允许vi显示其他用户用write写到自己终端上的信息\n\n### 最后行方式命令\n\t：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下\n\t：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下\n\t：n1,n2 d ：将n1行到n2行之间的内容删除\n\t：w ：保存当前文件\n\t：e filename：打开文件filename进行编辑\n\t：x：保存当前文件并退出\n\t：q：退出vi\n\t：q!：不保存文件并退出vi\n\t：!command：执行shell命令command\n\t：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入\n\t：r!command：将命令command的输出结果放到当前行\n\n### 寄存器操作\n\t\"?nyy：将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字\n\t\"?nyw：将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字\n\t\"?nyl：将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字\n\t\"?p：取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字\n\tndd：将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中。\n\n##VI的使用\n\n一、插入文本\n\n\ti ：在当前字符前插入文本　\n\tI ：在行首插入文本 　　　 　\n\ta ：在当前字符后添加文本　　\n\tA ：在行末添加文本　　　　　\n\to ：在当前行后面插入一空行　\n\tO ：在当前行前面插入一空行　\n\tR ：以改写方式输入文本　　　\n\n二、移动光标\n\n\t│j或下箭头 │向下移动一行　　　　　│\n\t│k或上箭头 │向上移动一行　　　　　│\n\t│h或左箭头 │左移一个字符　　　　　│\n\t│l或右箭头 │右移一个字符　　　　　│\n\t│w 　　　　│右移一个词　　　　　　│\n\t│W 　　　　│右移一个以空格分隔的词│\n\t│b 　　　　│左移一个词　　　　　　│\n\t│B 　　　　│左移一个以空格分隔的词│\n\t│0 　　　　│移到行首　　　　　　　│\n\t│Ctrl-F　　│向前翻页　　　　　　　│\n\t│Ctrl-B　　│向后翻页　　　　　　　│\n\t│nG　　　　│到第n行 　　　　　　　│\n\t│G 　　　　│到最后一行　　　　　　│\n\n三、替换文本\n\n\t│$ 　　　　│到行尾　　　│\n\t│( 　　　　│到句子的开头│\n\t│) 　　　　│到句子的末尾│\n\t│{　 　　　│到段落的开头│\n\t│}　　 　　│到段落的末尾│\n\n四、删除文本\n\n\t│命令　│描述 　　　　　　 　　│\n\t│r 　　│替换一个字符 　　　　 │\n\t│c 　　│修改文本直到按下Esc健 │\n\t│cw　　│修改下一个词 　　　 　│\n\t│cnw　 │修改接下来的n个词 　　│\n\n五、文本编辑\n\n\t│yy　│将一行文本移到缺省缓冲区中 　　　　 　　　　│\n\t│yn　│将下一个词移到缺省缓冲区中 　　 　　　　　　│\n\t│ynw │将后面的n个词移到缺省缓冲区中　\n\t——————————————————————————————————————-————│\n\t│p 　│如果缺省缓冲区中包含一行文本，则在当前　　　│\n\t│　　│行后面插入一个空行井将缺省缓冲区中的声　　　│\n\t│　　│容粘贴到这一行中；如果缺省缓冲区中包含　　　│\n\t│　　│多个词，把这些词粘贴到光标的右边．　　　　　\n\t--------------------------------------------\n\t│P 　│如果缺省缓冲区中包含一行文本，则正当前 　 　│\n\t│ 　 │行前面插入一个空行井将缺省缓冲区中的内 　 　│\n\t│　　│容粘贴到这一行中；如果缺省缓冲区中包含 　　 │\n\t│ 　 │多个词，把这些词粘贴到光标的左边│\n\n六、保存退出\n\n\t│zz　　　　　　│保存并退出　　　　　　　　　　│\n\t│:w filename │写入文件　　　　　　　　　 　 │\n\t│:W　　　　　  │写入文件　　　　　　　　　　　│\n\t│:x　　　　　　│保存(如果当前文件修改过)并退出│\n\t│:q!　　　　　 │不保存文件，直接退出　　 　　 │\n\t│:q　　　　　　│退出vi　　　　　　　　　　　　│\n\n## VI常用技巧\n\nVI命令可以说是Unix/Linux世界里最常用的编辑文件的命令了，但是因为它的命令集众多，很多人都不习惯使用它，其实您只需要掌握基本命令，然后加以灵活运用，就会发现它的优势，并会逐渐喜欢使用这种方法。本文旨在介绍VI的一些最常用命令和高级应用技巧。\n\n### 基本命令介绍\n\n#### 光标命令\n\nk、j、h、l——上、下、左、右光标移动命令。虽然您可以在Linux中使用键盘右边的4个光标键，但是记住这4个命令还是非常有用的。这4个键正是右手在键盘上放置的基本位置。\nnG——跳转命令。n为行数，该命令立即使光标跳到指定行。\nCtrl+G——光标所在位置的行数和列数报告。\nw、b——使光标向前或向后跳过一个单词。\n#### 编辑命令\ni、a、r——在光标的前、后以及所在处插入字符命令(i=insert、a=append、r=replace)。\ncw、dw——改变(置换)/删除光标所在处的单词的命令 (c=change、d=delete)。\nx、d$、dd——删除一个字符、删除光标所在处到行尾的所有字符以及删除整行的命令。\n#### 查找命令\n---- /string、?string——从光标所在处向后或向前查找相应的字符串的命令。\n#### 拷贝复制命令\n---- yy、p——拷贝一行到剪贴板或取出剪贴板中内容的命令。\n\n### 常见问题及应用技巧\n\n#### 在一个新文件中读/etc/passwd中的内容，取出用户名部分。\n---- vi file\n---- :r /etc/passwd 在打开的文件file中光标所在处读入/etc/passwd\n---- :%s/:.*//g 删除/etc/passwd中用户名后面的从冒号开始直到行尾的所有部分。\n---- 您也可以在指定的行号后读入文件内容，例如使用命令“:3r /etc/passwd”从新文件的第3行开始读入 /etc/passwd的所有内容。\n---- 我们还可以使用以下方法删掉文件中所有的空行及以#开始的注释行。\n---- #cat squid.conf.default | grep -v ^$ | grep -v ^#\n\n#### 在打开一个文件编辑后才知道登录的用户对该文件没有写的权限，不能存盘，需要将所做修改存入临时文件。\n---- vi file\n---- :w /tmp/1 保存所做的所有修改，也可以将其中的某一部分修改保存到临时文件，例如仅仅把第20～59行之间的内容存盘成文件/tmp/1，我们可以键入如下命令。\n---- vi file\n---- :20,59w /tmp/1\n\n#### 用VI编辑一个文件，但需要删除大段的内容。\n---- 首先利用编辑命令“vi file”打开文件，然后将光标移到需要删除的行处按Ctrl+G显示行号，再到结尾处再按Ctrl+G，显示文件结尾的行号。\n---- :23,1045d 假定2次得到的行号为23和1045，则把这期间的内容全删除，也可以在要删除的开始行和结束行中用ma、mb命令标记，然后利用“:a,bd”命令删除。\n\n#### 在整个文件的各行或某几行的行首或行尾加一些字符串。\n---- vi file\n---- :3,$s/^/some string / 在文件的第一行至最后一行的行首插入“some string”。\n---- :%s/$/some string/g 在整个文件每一行的行尾添加“some string”。\n---- :%s/string1/string2/g 在整个文件中替换“string1”成“string2”。\n---- :3,7s/string1/string2/ 仅替换文件中的第3行到第7行中的“string1”成“string2”。\n---- 注意: 其中s为substitute，%表示所有行，g表示global。\n\n#### 同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中。\n---- vi file1 file2\n---- yy 在文件1的光标处拷贝所在行\n---- :n 切换到文件2 (n=next)\n---- p 在文件2的光标所在处粘贴所拷贝的行\n---- :n 切换回文件1\n\n#### 替换文件中的路径。\n---- 使用命令“:%s#/usr/bin#/bin#g”可以把文件中所有路径/usr/bin换成/bin。也可以使用命令“:%s//usr/bin//bin/g”实现，其中“”是转义字符，表明其后的“/”字符是具有实际意义的字符，不是分隔符。","source":"_posts/ViCommands.md","raw":"---\ntitle: Vi Commands\nid: 121\ncategories:\n  - Ubuntu\ndate: 2015-05-26 21:14:20\ntags:\n---\n\n## 基本命令\n\n### 进入vi的命令\n\tvi filename :打开或新建文件，并将光标置于第一行首\n\tvi +n filename ：打开文件，并将光标置于第n行首\n\tvi + filename ：打开文件，并将光标置于最后一行首\n\tvi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处\n\tvi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename\n\tvi filename....filename ：打开多个文件，依次进行编辑\n\n### 移动光标类命令\n\th ：光标左移一个字符\n\tl ：光标右移一个字符\n\tspace：光标右移一个字符\n\tBackspace：光标左移一个字符\n\tk或Ctrl+p：光标上移一行\n\tj或Ctrl+n ：光标下移一行\n\tEnter ：光标下移一行\n\tw或W ：光标右移一个字至字首\n\tb或B ：光标左移一个字至字首\n\te或E ：光标右移一个字至字尾\n\t) ：光标移至句尾\n\t( ：光标移至句首\n\t}：光标移至段落开头\n\t{：光标移至段落结尾\n\tnG：光标移至第n行首\n\tn+：光标下移n行\n\tn-：光标上移n行\n\tn$：光标移至第n行尾\n\tH ：光标移至屏幕顶行\n\tM ：光标移至屏幕中间行\n\tL ：光标移至屏幕最后行\n\t0：（注意是数字零）光标移至当前行首\n\t$：光标移至当前行尾\n\n### 屏幕翻滚类命令\n\tCtrl+u：向文件首翻半屏\n\tCtrl+d：向文件尾翻半屏\n\tCtrl+f：向文件尾翻一屏\n\tCtrl＋b；向文件首翻一屏\n\tnz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。\n\n### 插入文本类命令\n\ti ：在光标前\n\tI ：在当前行首\n\ta：光标后\n\tA：在当前行尾\n\to：在当前行之下新开一行\n\tO：在当前行之上新开一行\n\tr：替换当前字符\n\tR：替换当前字符及其后的字符，直至按ESC键\n\ts：从当前光标位置处开始，以输入的文本替代指定数目的字符\n\tS：删除指定数目的行，并以所输入文本代替之\n\tncw或nCW：修改指定数目的字\n\tnCC：修改指定数目的行\n\n### 删除命令\n\tndw或ndW：删除光标处开始及其后的n-1个字\n\tdo：删至行首\n\td$：删至行尾\n\tndd：删除当前行及其后n-1行\n\tx或X：删除一个字符，x删除光标后的，而X删除光标前的\n\tCtrl+u：删除输入方式下所输入的文本\n\n### 搜索及替换命令\n\t/pattern：从光标开始处向文件尾搜索pattern\n\t?pattern：从光标开始处向文件首搜索pattern\n\tn：在同一方向重复上一次搜索命令\n\tN：在反方向上重复上一次搜索命令\n\t：s/p1/p2/g：将当前行中所有p1均用p2替代\n\t：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代\n\t：g/p1/s//p2/g：将文件中所有p1均用p2替换\n\n### 选项设置\n\tall：列出所有选项设置情况\n\tterm：设置终端类型\n\tignorance：在搜索中忽略大小写\n\tlist：显示制表位(Ctrl+I)和行尾标志（$)\n\tnumber：显示行号\n\treport：显示由面向行的命令修改过的数目\n\tterse：显示简短的警告信息\n\twarn：在转到别的文件时若没保存当前文件则显示NO write信息\n\tnomagic：允许在搜索模式中，使用前面不带“”的特殊字符\n\tnowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始\n\tmesg：允许vi显示其他用户用write写到自己终端上的信息\n\n### 最后行方式命令\n\t：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下\n\t：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下\n\t：n1,n2 d ：将n1行到n2行之间的内容删除\n\t：w ：保存当前文件\n\t：e filename：打开文件filename进行编辑\n\t：x：保存当前文件并退出\n\t：q：退出vi\n\t：q!：不保存文件并退出vi\n\t：!command：执行shell命令command\n\t：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入\n\t：r!command：将命令command的输出结果放到当前行\n\n### 寄存器操作\n\t\"?nyy：将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字\n\t\"?nyw：将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字\n\t\"?nyl：将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字\n\t\"?p：取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字\n\tndd：将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中。\n\n##VI的使用\n\n一、插入文本\n\n\ti ：在当前字符前插入文本　\n\tI ：在行首插入文本 　　　 　\n\ta ：在当前字符后添加文本　　\n\tA ：在行末添加文本　　　　　\n\to ：在当前行后面插入一空行　\n\tO ：在当前行前面插入一空行　\n\tR ：以改写方式输入文本　　　\n\n二、移动光标\n\n\t│j或下箭头 │向下移动一行　　　　　│\n\t│k或上箭头 │向上移动一行　　　　　│\n\t│h或左箭头 │左移一个字符　　　　　│\n\t│l或右箭头 │右移一个字符　　　　　│\n\t│w 　　　　│右移一个词　　　　　　│\n\t│W 　　　　│右移一个以空格分隔的词│\n\t│b 　　　　│左移一个词　　　　　　│\n\t│B 　　　　│左移一个以空格分隔的词│\n\t│0 　　　　│移到行首　　　　　　　│\n\t│Ctrl-F　　│向前翻页　　　　　　　│\n\t│Ctrl-B　　│向后翻页　　　　　　　│\n\t│nG　　　　│到第n行 　　　　　　　│\n\t│G 　　　　│到最后一行　　　　　　│\n\n三、替换文本\n\n\t│$ 　　　　│到行尾　　　│\n\t│( 　　　　│到句子的开头│\n\t│) 　　　　│到句子的末尾│\n\t│{　 　　　│到段落的开头│\n\t│}　　 　　│到段落的末尾│\n\n四、删除文本\n\n\t│命令　│描述 　　　　　　 　　│\n\t│r 　　│替换一个字符 　　　　 │\n\t│c 　　│修改文本直到按下Esc健 │\n\t│cw　　│修改下一个词 　　　 　│\n\t│cnw　 │修改接下来的n个词 　　│\n\n五、文本编辑\n\n\t│yy　│将一行文本移到缺省缓冲区中 　　　　 　　　　│\n\t│yn　│将下一个词移到缺省缓冲区中 　　 　　　　　　│\n\t│ynw │将后面的n个词移到缺省缓冲区中　\n\t——————————————————————————————————————-————│\n\t│p 　│如果缺省缓冲区中包含一行文本，则在当前　　　│\n\t│　　│行后面插入一个空行井将缺省缓冲区中的声　　　│\n\t│　　│容粘贴到这一行中；如果缺省缓冲区中包含　　　│\n\t│　　│多个词，把这些词粘贴到光标的右边．　　　　　\n\t--------------------------------------------\n\t│P 　│如果缺省缓冲区中包含一行文本，则正当前 　 　│\n\t│ 　 │行前面插入一个空行井将缺省缓冲区中的内 　 　│\n\t│　　│容粘贴到这一行中；如果缺省缓冲区中包含 　　 │\n\t│ 　 │多个词，把这些词粘贴到光标的左边│\n\n六、保存退出\n\n\t│zz　　　　　　│保存并退出　　　　　　　　　　│\n\t│:w filename │写入文件　　　　　　　　　 　 │\n\t│:W　　　　　  │写入文件　　　　　　　　　　　│\n\t│:x　　　　　　│保存(如果当前文件修改过)并退出│\n\t│:q!　　　　　 │不保存文件，直接退出　　 　　 │\n\t│:q　　　　　　│退出vi　　　　　　　　　　　　│\n\n## VI常用技巧\n\nVI命令可以说是Unix/Linux世界里最常用的编辑文件的命令了，但是因为它的命令集众多，很多人都不习惯使用它，其实您只需要掌握基本命令，然后加以灵活运用，就会发现它的优势，并会逐渐喜欢使用这种方法。本文旨在介绍VI的一些最常用命令和高级应用技巧。\n\n### 基本命令介绍\n\n#### 光标命令\n\nk、j、h、l——上、下、左、右光标移动命令。虽然您可以在Linux中使用键盘右边的4个光标键，但是记住这4个命令还是非常有用的。这4个键正是右手在键盘上放置的基本位置。\nnG——跳转命令。n为行数，该命令立即使光标跳到指定行。\nCtrl+G——光标所在位置的行数和列数报告。\nw、b——使光标向前或向后跳过一个单词。\n#### 编辑命令\ni、a、r——在光标的前、后以及所在处插入字符命令(i=insert、a=append、r=replace)。\ncw、dw——改变(置换)/删除光标所在处的单词的命令 (c=change、d=delete)。\nx、d$、dd——删除一个字符、删除光标所在处到行尾的所有字符以及删除整行的命令。\n#### 查找命令\n---- /string、?string——从光标所在处向后或向前查找相应的字符串的命令。\n#### 拷贝复制命令\n---- yy、p——拷贝一行到剪贴板或取出剪贴板中内容的命令。\n\n### 常见问题及应用技巧\n\n#### 在一个新文件中读/etc/passwd中的内容，取出用户名部分。\n---- vi file\n---- :r /etc/passwd 在打开的文件file中光标所在处读入/etc/passwd\n---- :%s/:.*//g 删除/etc/passwd中用户名后面的从冒号开始直到行尾的所有部分。\n---- 您也可以在指定的行号后读入文件内容，例如使用命令“:3r /etc/passwd”从新文件的第3行开始读入 /etc/passwd的所有内容。\n---- 我们还可以使用以下方法删掉文件中所有的空行及以#开始的注释行。\n---- #cat squid.conf.default | grep -v ^$ | grep -v ^#\n\n#### 在打开一个文件编辑后才知道登录的用户对该文件没有写的权限，不能存盘，需要将所做修改存入临时文件。\n---- vi file\n---- :w /tmp/1 保存所做的所有修改，也可以将其中的某一部分修改保存到临时文件，例如仅仅把第20～59行之间的内容存盘成文件/tmp/1，我们可以键入如下命令。\n---- vi file\n---- :20,59w /tmp/1\n\n#### 用VI编辑一个文件，但需要删除大段的内容。\n---- 首先利用编辑命令“vi file”打开文件，然后将光标移到需要删除的行处按Ctrl+G显示行号，再到结尾处再按Ctrl+G，显示文件结尾的行号。\n---- :23,1045d 假定2次得到的行号为23和1045，则把这期间的内容全删除，也可以在要删除的开始行和结束行中用ma、mb命令标记，然后利用“:a,bd”命令删除。\n\n#### 在整个文件的各行或某几行的行首或行尾加一些字符串。\n---- vi file\n---- :3,$s/^/some string / 在文件的第一行至最后一行的行首插入“some string”。\n---- :%s/$/some string/g 在整个文件每一行的行尾添加“some string”。\n---- :%s/string1/string2/g 在整个文件中替换“string1”成“string2”。\n---- :3,7s/string1/string2/ 仅替换文件中的第3行到第7行中的“string1”成“string2”。\n---- 注意: 其中s为substitute，%表示所有行，g表示global。\n\n#### 同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中。\n---- vi file1 file2\n---- yy 在文件1的光标处拷贝所在行\n---- :n 切换到文件2 (n=next)\n---- p 在文件2的光标所在处粘贴所拷贝的行\n---- :n 切换回文件1\n\n#### 替换文件中的路径。\n---- 使用命令“:%s#/usr/bin#/bin#g”可以把文件中所有路径/usr/bin换成/bin。也可以使用命令“:%s//usr/bin//bin/g”实现，其中“”是转义字符，表明其后的“/”字符是具有实际意义的字符，不是分隔符。","slug":"ViCommands","published":1,"updated":"2019-02-10T17:11:09.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs1amk20003rlkgutt05aypx","content":"<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><h3 id=\"进入vi的命令\"><a href=\"#进入vi的命令\" class=\"headerlink\" title=\"进入vi的命令\"></a>进入vi的命令</h3><pre><code>vi filename :打开或新建文件，并将光标置于第一行首\nvi +n filename ：打开文件，并将光标置于第n行首\nvi + filename ：打开文件，并将光标置于最后一行首\nvi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处\nvi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename\nvi filename....filename ：打开多个文件，依次进行编辑\n</code></pre><h3 id=\"移动光标类命令\"><a href=\"#移动光标类命令\" class=\"headerlink\" title=\"移动光标类命令\"></a>移动光标类命令</h3><pre><code>h ：光标左移一个字符\nl ：光标右移一个字符\nspace：光标右移一个字符\nBackspace：光标左移一个字符\nk或Ctrl+p：光标上移一行\nj或Ctrl+n ：光标下移一行\nEnter ：光标下移一行\nw或W ：光标右移一个字至字首\nb或B ：光标左移一个字至字首\ne或E ：光标右移一个字至字尾\n) ：光标移至句尾\n( ：光标移至句首\n}：光标移至段落开头\n{：光标移至段落结尾\nnG：光标移至第n行首\nn+：光标下移n行\nn-：光标上移n行\nn$：光标移至第n行尾\nH ：光标移至屏幕顶行\nM ：光标移至屏幕中间行\nL ：光标移至屏幕最后行\n0：（注意是数字零）光标移至当前行首\n$：光标移至当前行尾\n</code></pre><h3 id=\"屏幕翻滚类命令\"><a href=\"#屏幕翻滚类命令\" class=\"headerlink\" title=\"屏幕翻滚类命令\"></a>屏幕翻滚类命令</h3><pre><code>Ctrl+u：向文件首翻半屏\nCtrl+d：向文件尾翻半屏\nCtrl+f：向文件尾翻一屏\nCtrl＋b；向文件首翻一屏\nnz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。\n</code></pre><h3 id=\"插入文本类命令\"><a href=\"#插入文本类命令\" class=\"headerlink\" title=\"插入文本类命令\"></a>插入文本类命令</h3><pre><code>i ：在光标前\nI ：在当前行首\na：光标后\nA：在当前行尾\no：在当前行之下新开一行\nO：在当前行之上新开一行\nr：替换当前字符\nR：替换当前字符及其后的字符，直至按ESC键\ns：从当前光标位置处开始，以输入的文本替代指定数目的字符\nS：删除指定数目的行，并以所输入文本代替之\nncw或nCW：修改指定数目的字\nnCC：修改指定数目的行\n</code></pre><h3 id=\"删除命令\"><a href=\"#删除命令\" class=\"headerlink\" title=\"删除命令\"></a>删除命令</h3><pre><code>ndw或ndW：删除光标处开始及其后的n-1个字\ndo：删至行首\nd$：删至行尾\nndd：删除当前行及其后n-1行\nx或X：删除一个字符，x删除光标后的，而X删除光标前的\nCtrl+u：删除输入方式下所输入的文本\n</code></pre><h3 id=\"搜索及替换命令\"><a href=\"#搜索及替换命令\" class=\"headerlink\" title=\"搜索及替换命令\"></a>搜索及替换命令</h3><pre><code>/pattern：从光标开始处向文件尾搜索pattern\n?pattern：从光标开始处向文件首搜索pattern\nn：在同一方向重复上一次搜索命令\nN：在反方向上重复上一次搜索命令\n：s/p1/p2/g：将当前行中所有p1均用p2替代\n：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代\n：g/p1/s//p2/g：将文件中所有p1均用p2替换\n</code></pre><h3 id=\"选项设置\"><a href=\"#选项设置\" class=\"headerlink\" title=\"选项设置\"></a>选项设置</h3><pre><code>all：列出所有选项设置情况\nterm：设置终端类型\nignorance：在搜索中忽略大小写\nlist：显示制表位(Ctrl+I)和行尾标志（$)\nnumber：显示行号\nreport：显示由面向行的命令修改过的数目\nterse：显示简短的警告信息\nwarn：在转到别的文件时若没保存当前文件则显示NO write信息\nnomagic：允许在搜索模式中，使用前面不带“”的特殊字符\nnowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始\nmesg：允许vi显示其他用户用write写到自己终端上的信息\n</code></pre><h3 id=\"最后行方式命令\"><a href=\"#最后行方式命令\" class=\"headerlink\" title=\"最后行方式命令\"></a>最后行方式命令</h3><pre><code>：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下\n：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下\n：n1,n2 d ：将n1行到n2行之间的内容删除\n：w ：保存当前文件\n：e filename：打开文件filename进行编辑\n：x：保存当前文件并退出\n：q：退出vi\n：q!：不保存文件并退出vi\n：!command：执行shell命令command\n：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入\n：r!command：将命令command的输出结果放到当前行\n</code></pre><h3 id=\"寄存器操作\"><a href=\"#寄存器操作\" class=\"headerlink\" title=\"寄存器操作\"></a>寄存器操作</h3><pre><code>&quot;?nyy：将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字\n&quot;?nyw：将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字\n&quot;?nyl：将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字\n&quot;?p：取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字\nndd：将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中。\n</code></pre><p>##VI的使用</p>\n<p>一、插入文本</p>\n<pre><code>i ：在当前字符前插入文本　\nI ：在行首插入文本 　　　 　\na ：在当前字符后添加文本　　\nA ：在行末添加文本　　　　　\no ：在当前行后面插入一空行　\nO ：在当前行前面插入一空行　\nR ：以改写方式输入文本　　　\n</code></pre><p>二、移动光标</p>\n<pre><code>│j或下箭头 │向下移动一行　　　　　│\n│k或上箭头 │向上移动一行　　　　　│\n│h或左箭头 │左移一个字符　　　　　│\n│l或右箭头 │右移一个字符　　　　　│\n│w 　　　　│右移一个词　　　　　　│\n│W 　　　　│右移一个以空格分隔的词│\n│b 　　　　│左移一个词　　　　　　│\n│B 　　　　│左移一个以空格分隔的词│\n│0 　　　　│移到行首　　　　　　　│\n│Ctrl-F　　│向前翻页　　　　　　　│\n│Ctrl-B　　│向后翻页　　　　　　　│\n│nG　　　　│到第n行 　　　　　　　│\n│G 　　　　│到最后一行　　　　　　│\n</code></pre><p>三、替换文本</p>\n<pre><code>│$ 　　　　│到行尾　　　│\n│( 　　　　│到句子的开头│\n│) 　　　　│到句子的末尾│\n│{　 　　　│到段落的开头│\n│}　　 　　│到段落的末尾│\n</code></pre><p>四、删除文本</p>\n<pre><code>│命令　│描述 　　　　　　 　　│\n│r 　　│替换一个字符 　　　　 │\n│c 　　│修改文本直到按下Esc健 │\n│cw　　│修改下一个词 　　　 　│\n│cnw　 │修改接下来的n个词 　　│\n</code></pre><p>五、文本编辑</p>\n<pre><code>│yy　│将一行文本移到缺省缓冲区中 　　　　 　　　　│\n│yn　│将下一个词移到缺省缓冲区中 　　 　　　　　　│\n│ynw │将后面的n个词移到缺省缓冲区中　\n——————————————————————————————————————-————│\n│p 　│如果缺省缓冲区中包含一行文本，则在当前　　　│\n│　　│行后面插入一个空行井将缺省缓冲区中的声　　　│\n│　　│容粘贴到这一行中；如果缺省缓冲区中包含　　　│\n│　　│多个词，把这些词粘贴到光标的右边．　　　　　\n--------------------------------------------\n│P 　│如果缺省缓冲区中包含一行文本，则正当前 　 　│\n│ 　 │行前面插入一个空行井将缺省缓冲区中的内 　 　│\n│　　│容粘贴到这一行中；如果缺省缓冲区中包含 　　 │\n│ 　 │多个词，把这些词粘贴到光标的左边│\n</code></pre><p>六、保存退出</p>\n<pre><code>│zz　　　　　　│保存并退出　　　　　　　　　　│\n│:w filename │写入文件　　　　　　　　　 　 │\n│:W　　　　　  │写入文件　　　　　　　　　　　│\n│:x　　　　　　│保存(如果当前文件修改过)并退出│\n│:q!　　　　　 │不保存文件，直接退出　　 　　 │\n│:q　　　　　　│退出vi　　　　　　　　　　　　│\n</code></pre><h2 id=\"VI常用技巧\"><a href=\"#VI常用技巧\" class=\"headerlink\" title=\"VI常用技巧\"></a>VI常用技巧</h2><p>VI命令可以说是Unix/Linux世界里最常用的编辑文件的命令了，但是因为它的命令集众多，很多人都不习惯使用它，其实您只需要掌握基本命令，然后加以灵活运用，就会发现它的优势，并会逐渐喜欢使用这种方法。本文旨在介绍VI的一些最常用命令和高级应用技巧。</p>\n<h3 id=\"基本命令介绍\"><a href=\"#基本命令介绍\" class=\"headerlink\" title=\"基本命令介绍\"></a>基本命令介绍</h3><h4 id=\"光标命令\"><a href=\"#光标命令\" class=\"headerlink\" title=\"光标命令\"></a>光标命令</h4><p>k、j、h、l——上、下、左、右光标移动命令。虽然您可以在Linux中使用键盘右边的4个光标键，但是记住这4个命令还是非常有用的。这4个键正是右手在键盘上放置的基本位置。<br>nG——跳转命令。n为行数，该命令立即使光标跳到指定行。<br>Ctrl+G——光标所在位置的行数和列数报告。<br>w、b——使光标向前或向后跳过一个单词。</p>\n<h4 id=\"编辑命令\"><a href=\"#编辑命令\" class=\"headerlink\" title=\"编辑命令\"></a>编辑命令</h4><p>i、a、r——在光标的前、后以及所在处插入字符命令(i=insert、a=append、r=replace)。<br>cw、dw——改变(置换)/删除光标所在处的单词的命令 (c=change、d=delete)。<br>x、d$、dd——删除一个字符、删除光标所在处到行尾的所有字符以及删除整行的命令。</p>\n<h4 id=\"查找命令\"><a href=\"#查找命令\" class=\"headerlink\" title=\"查找命令\"></a>查找命令</h4><p>—- /string、?string——从光标所在处向后或向前查找相应的字符串的命令。</p>\n<h4 id=\"拷贝复制命令\"><a href=\"#拷贝复制命令\" class=\"headerlink\" title=\"拷贝复制命令\"></a>拷贝复制命令</h4><p>—- yy、p——拷贝一行到剪贴板或取出剪贴板中内容的命令。</p>\n<h3 id=\"常见问题及应用技巧\"><a href=\"#常见问题及应用技巧\" class=\"headerlink\" title=\"常见问题及应用技巧\"></a>常见问题及应用技巧</h3><h4 id=\"在一个新文件中读-etc-passwd中的内容，取出用户名部分。\"><a href=\"#在一个新文件中读-etc-passwd中的内容，取出用户名部分。\" class=\"headerlink\" title=\"在一个新文件中读/etc/passwd中的内容，取出用户名部分。\"></a>在一个新文件中读/etc/passwd中的内容，取出用户名部分。</h4><p>—- vi file<br>—- :r /etc/passwd 在打开的文件file中光标所在处读入/etc/passwd<br>—- :%s/:.*//g 删除/etc/passwd中用户名后面的从冒号开始直到行尾的所有部分。<br>—- 您也可以在指定的行号后读入文件内容，例如使用命令“:3r /etc/passwd”从新文件的第3行开始读入 /etc/passwd的所有内容。<br>—- 我们还可以使用以下方法删掉文件中所有的空行及以#开始的注释行。<br>—- #cat squid.conf.default | grep -v ^$ | grep -v ^#</p>\n<h4 id=\"在打开一个文件编辑后才知道登录的用户对该文件没有写的权限，不能存盘，需要将所做修改存入临时文件。\"><a href=\"#在打开一个文件编辑后才知道登录的用户对该文件没有写的权限，不能存盘，需要将所做修改存入临时文件。\" class=\"headerlink\" title=\"在打开一个文件编辑后才知道登录的用户对该文件没有写的权限，不能存盘，需要将所做修改存入临时文件。\"></a>在打开一个文件编辑后才知道登录的用户对该文件没有写的权限，不能存盘，需要将所做修改存入临时文件。</h4><p>—- vi file<br>—- :w /tmp/1 保存所做的所有修改，也可以将其中的某一部分修改保存到临时文件，例如仅仅把第20～59行之间的内容存盘成文件/tmp/1，我们可以键入如下命令。<br>—- vi file<br>—- :20,59w /tmp/1</p>\n<h4 id=\"用VI编辑一个文件，但需要删除大段的内容。\"><a href=\"#用VI编辑一个文件，但需要删除大段的内容。\" class=\"headerlink\" title=\"用VI编辑一个文件，但需要删除大段的内容。\"></a>用VI编辑一个文件，但需要删除大段的内容。</h4><p>—- 首先利用编辑命令“vi file”打开文件，然后将光标移到需要删除的行处按Ctrl+G显示行号，再到结尾处再按Ctrl+G，显示文件结尾的行号。<br>—- :23,1045d 假定2次得到的行号为23和1045，则把这期间的内容全删除，也可以在要删除的开始行和结束行中用ma、mb命令标记，然后利用“:a,bd”命令删除。</p>\n<h4 id=\"在整个文件的各行或某几行的行首或行尾加一些字符串。\"><a href=\"#在整个文件的各行或某几行的行首或行尾加一些字符串。\" class=\"headerlink\" title=\"在整个文件的各行或某几行的行首或行尾加一些字符串。\"></a>在整个文件的各行或某几行的行首或行尾加一些字符串。</h4><p>—- vi file<br>—- :3,$s/^/some string / 在文件的第一行至最后一行的行首插入“some string”。<br>—- :%s/$/some string/g 在整个文件每一行的行尾添加“some string”。<br>—- :%s/string1/string2/g 在整个文件中替换“string1”成“string2”。<br>—- :3,7s/string1/string2/ 仅替换文件中的第3行到第7行中的“string1”成“string2”。<br>—- 注意: 其中s为substitute，%表示所有行，g表示global。</p>\n<h4 id=\"同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中。\"><a href=\"#同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中。\" class=\"headerlink\" title=\"同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中。\"></a>同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中。</h4><p>—- vi file1 file2<br>—- yy 在文件1的光标处拷贝所在行<br>—- :n 切换到文件2 (n=next)<br>—- p 在文件2的光标所在处粘贴所拷贝的行<br>—- :n 切换回文件1</p>\n<h4 id=\"替换文件中的路径。\"><a href=\"#替换文件中的路径。\" class=\"headerlink\" title=\"替换文件中的路径。\"></a>替换文件中的路径。</h4><p>—- 使用命令“:%s#/usr/bin#/bin#g”可以把文件中所有路径/usr/bin换成/bin。也可以使用命令“:%s//usr/bin//bin/g”实现，其中“”是转义字符，表明其后的“/”字符是具有实际意义的字符，不是分隔符。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><h3 id=\"进入vi的命令\"><a href=\"#进入vi的命令\" class=\"headerlink\" title=\"进入vi的命令\"></a>进入vi的命令</h3><pre><code>vi filename :打开或新建文件，并将光标置于第一行首\nvi +n filename ：打开文件，并将光标置于第n行首\nvi + filename ：打开文件，并将光标置于最后一行首\nvi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处\nvi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename\nvi filename....filename ：打开多个文件，依次进行编辑\n</code></pre><h3 id=\"移动光标类命令\"><a href=\"#移动光标类命令\" class=\"headerlink\" title=\"移动光标类命令\"></a>移动光标类命令</h3><pre><code>h ：光标左移一个字符\nl ：光标右移一个字符\nspace：光标右移一个字符\nBackspace：光标左移一个字符\nk或Ctrl+p：光标上移一行\nj或Ctrl+n ：光标下移一行\nEnter ：光标下移一行\nw或W ：光标右移一个字至字首\nb或B ：光标左移一个字至字首\ne或E ：光标右移一个字至字尾\n) ：光标移至句尾\n( ：光标移至句首\n}：光标移至段落开头\n{：光标移至段落结尾\nnG：光标移至第n行首\nn+：光标下移n行\nn-：光标上移n行\nn$：光标移至第n行尾\nH ：光标移至屏幕顶行\nM ：光标移至屏幕中间行\nL ：光标移至屏幕最后行\n0：（注意是数字零）光标移至当前行首\n$：光标移至当前行尾\n</code></pre><h3 id=\"屏幕翻滚类命令\"><a href=\"#屏幕翻滚类命令\" class=\"headerlink\" title=\"屏幕翻滚类命令\"></a>屏幕翻滚类命令</h3><pre><code>Ctrl+u：向文件首翻半屏\nCtrl+d：向文件尾翻半屏\nCtrl+f：向文件尾翻一屏\nCtrl＋b；向文件首翻一屏\nnz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。\n</code></pre><h3 id=\"插入文本类命令\"><a href=\"#插入文本类命令\" class=\"headerlink\" title=\"插入文本类命令\"></a>插入文本类命令</h3><pre><code>i ：在光标前\nI ：在当前行首\na：光标后\nA：在当前行尾\no：在当前行之下新开一行\nO：在当前行之上新开一行\nr：替换当前字符\nR：替换当前字符及其后的字符，直至按ESC键\ns：从当前光标位置处开始，以输入的文本替代指定数目的字符\nS：删除指定数目的行，并以所输入文本代替之\nncw或nCW：修改指定数目的字\nnCC：修改指定数目的行\n</code></pre><h3 id=\"删除命令\"><a href=\"#删除命令\" class=\"headerlink\" title=\"删除命令\"></a>删除命令</h3><pre><code>ndw或ndW：删除光标处开始及其后的n-1个字\ndo：删至行首\nd$：删至行尾\nndd：删除当前行及其后n-1行\nx或X：删除一个字符，x删除光标后的，而X删除光标前的\nCtrl+u：删除输入方式下所输入的文本\n</code></pre><h3 id=\"搜索及替换命令\"><a href=\"#搜索及替换命令\" class=\"headerlink\" title=\"搜索及替换命令\"></a>搜索及替换命令</h3><pre><code>/pattern：从光标开始处向文件尾搜索pattern\n?pattern：从光标开始处向文件首搜索pattern\nn：在同一方向重复上一次搜索命令\nN：在反方向上重复上一次搜索命令\n：s/p1/p2/g：将当前行中所有p1均用p2替代\n：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代\n：g/p1/s//p2/g：将文件中所有p1均用p2替换\n</code></pre><h3 id=\"选项设置\"><a href=\"#选项设置\" class=\"headerlink\" title=\"选项设置\"></a>选项设置</h3><pre><code>all：列出所有选项设置情况\nterm：设置终端类型\nignorance：在搜索中忽略大小写\nlist：显示制表位(Ctrl+I)和行尾标志（$)\nnumber：显示行号\nreport：显示由面向行的命令修改过的数目\nterse：显示简短的警告信息\nwarn：在转到别的文件时若没保存当前文件则显示NO write信息\nnomagic：允许在搜索模式中，使用前面不带“”的特殊字符\nnowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始\nmesg：允许vi显示其他用户用write写到自己终端上的信息\n</code></pre><h3 id=\"最后行方式命令\"><a href=\"#最后行方式命令\" class=\"headerlink\" title=\"最后行方式命令\"></a>最后行方式命令</h3><pre><code>：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下\n：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下\n：n1,n2 d ：将n1行到n2行之间的内容删除\n：w ：保存当前文件\n：e filename：打开文件filename进行编辑\n：x：保存当前文件并退出\n：q：退出vi\n：q!：不保存文件并退出vi\n：!command：执行shell命令command\n：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入\n：r!command：将命令command的输出结果放到当前行\n</code></pre><h3 id=\"寄存器操作\"><a href=\"#寄存器操作\" class=\"headerlink\" title=\"寄存器操作\"></a>寄存器操作</h3><pre><code>&quot;?nyy：将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字\n&quot;?nyw：将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字\n&quot;?nyl：将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字\n&quot;?p：取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字\nndd：将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中。\n</code></pre><p>##VI的使用</p>\n<p>一、插入文本</p>\n<pre><code>i ：在当前字符前插入文本　\nI ：在行首插入文本 　　　 　\na ：在当前字符后添加文本　　\nA ：在行末添加文本　　　　　\no ：在当前行后面插入一空行　\nO ：在当前行前面插入一空行　\nR ：以改写方式输入文本　　　\n</code></pre><p>二、移动光标</p>\n<pre><code>│j或下箭头 │向下移动一行　　　　　│\n│k或上箭头 │向上移动一行　　　　　│\n│h或左箭头 │左移一个字符　　　　　│\n│l或右箭头 │右移一个字符　　　　　│\n│w 　　　　│右移一个词　　　　　　│\n│W 　　　　│右移一个以空格分隔的词│\n│b 　　　　│左移一个词　　　　　　│\n│B 　　　　│左移一个以空格分隔的词│\n│0 　　　　│移到行首　　　　　　　│\n│Ctrl-F　　│向前翻页　　　　　　　│\n│Ctrl-B　　│向后翻页　　　　　　　│\n│nG　　　　│到第n行 　　　　　　　│\n│G 　　　　│到最后一行　　　　　　│\n</code></pre><p>三、替换文本</p>\n<pre><code>│$ 　　　　│到行尾　　　│\n│( 　　　　│到句子的开头│\n│) 　　　　│到句子的末尾│\n│{　 　　　│到段落的开头│\n│}　　 　　│到段落的末尾│\n</code></pre><p>四、删除文本</p>\n<pre><code>│命令　│描述 　　　　　　 　　│\n│r 　　│替换一个字符 　　　　 │\n│c 　　│修改文本直到按下Esc健 │\n│cw　　│修改下一个词 　　　 　│\n│cnw　 │修改接下来的n个词 　　│\n</code></pre><p>五、文本编辑</p>\n<pre><code>│yy　│将一行文本移到缺省缓冲区中 　　　　 　　　　│\n│yn　│将下一个词移到缺省缓冲区中 　　 　　　　　　│\n│ynw │将后面的n个词移到缺省缓冲区中　\n——————————————————————————————————————-————│\n│p 　│如果缺省缓冲区中包含一行文本，则在当前　　　│\n│　　│行后面插入一个空行井将缺省缓冲区中的声　　　│\n│　　│容粘贴到这一行中；如果缺省缓冲区中包含　　　│\n│　　│多个词，把这些词粘贴到光标的右边．　　　　　\n--------------------------------------------\n│P 　│如果缺省缓冲区中包含一行文本，则正当前 　 　│\n│ 　 │行前面插入一个空行井将缺省缓冲区中的内 　 　│\n│　　│容粘贴到这一行中；如果缺省缓冲区中包含 　　 │\n│ 　 │多个词，把这些词粘贴到光标的左边│\n</code></pre><p>六、保存退出</p>\n<pre><code>│zz　　　　　　│保存并退出　　　　　　　　　　│\n│:w filename │写入文件　　　　　　　　　 　 │\n│:W　　　　　  │写入文件　　　　　　　　　　　│\n│:x　　　　　　│保存(如果当前文件修改过)并退出│\n│:q!　　　　　 │不保存文件，直接退出　　 　　 │\n│:q　　　　　　│退出vi　　　　　　　　　　　　│\n</code></pre><h2 id=\"VI常用技巧\"><a href=\"#VI常用技巧\" class=\"headerlink\" title=\"VI常用技巧\"></a>VI常用技巧</h2><p>VI命令可以说是Unix/Linux世界里最常用的编辑文件的命令了，但是因为它的命令集众多，很多人都不习惯使用它，其实您只需要掌握基本命令，然后加以灵活运用，就会发现它的优势，并会逐渐喜欢使用这种方法。本文旨在介绍VI的一些最常用命令和高级应用技巧。</p>\n<h3 id=\"基本命令介绍\"><a href=\"#基本命令介绍\" class=\"headerlink\" title=\"基本命令介绍\"></a>基本命令介绍</h3><h4 id=\"光标命令\"><a href=\"#光标命令\" class=\"headerlink\" title=\"光标命令\"></a>光标命令</h4><p>k、j、h、l——上、下、左、右光标移动命令。虽然您可以在Linux中使用键盘右边的4个光标键，但是记住这4个命令还是非常有用的。这4个键正是右手在键盘上放置的基本位置。<br>nG——跳转命令。n为行数，该命令立即使光标跳到指定行。<br>Ctrl+G——光标所在位置的行数和列数报告。<br>w、b——使光标向前或向后跳过一个单词。</p>\n<h4 id=\"编辑命令\"><a href=\"#编辑命令\" class=\"headerlink\" title=\"编辑命令\"></a>编辑命令</h4><p>i、a、r——在光标的前、后以及所在处插入字符命令(i=insert、a=append、r=replace)。<br>cw、dw——改变(置换)/删除光标所在处的单词的命令 (c=change、d=delete)。<br>x、d$、dd——删除一个字符、删除光标所在处到行尾的所有字符以及删除整行的命令。</p>\n<h4 id=\"查找命令\"><a href=\"#查找命令\" class=\"headerlink\" title=\"查找命令\"></a>查找命令</h4><p>—- /string、?string——从光标所在处向后或向前查找相应的字符串的命令。</p>\n<h4 id=\"拷贝复制命令\"><a href=\"#拷贝复制命令\" class=\"headerlink\" title=\"拷贝复制命令\"></a>拷贝复制命令</h4><p>—- yy、p——拷贝一行到剪贴板或取出剪贴板中内容的命令。</p>\n<h3 id=\"常见问题及应用技巧\"><a href=\"#常见问题及应用技巧\" class=\"headerlink\" title=\"常见问题及应用技巧\"></a>常见问题及应用技巧</h3><h4 id=\"在一个新文件中读-etc-passwd中的内容，取出用户名部分。\"><a href=\"#在一个新文件中读-etc-passwd中的内容，取出用户名部分。\" class=\"headerlink\" title=\"在一个新文件中读/etc/passwd中的内容，取出用户名部分。\"></a>在一个新文件中读/etc/passwd中的内容，取出用户名部分。</h4><p>—- vi file<br>—- :r /etc/passwd 在打开的文件file中光标所在处读入/etc/passwd<br>—- :%s/:.*//g 删除/etc/passwd中用户名后面的从冒号开始直到行尾的所有部分。<br>—- 您也可以在指定的行号后读入文件内容，例如使用命令“:3r /etc/passwd”从新文件的第3行开始读入 /etc/passwd的所有内容。<br>—- 我们还可以使用以下方法删掉文件中所有的空行及以#开始的注释行。<br>—- #cat squid.conf.default | grep -v ^$ | grep -v ^#</p>\n<h4 id=\"在打开一个文件编辑后才知道登录的用户对该文件没有写的权限，不能存盘，需要将所做修改存入临时文件。\"><a href=\"#在打开一个文件编辑后才知道登录的用户对该文件没有写的权限，不能存盘，需要将所做修改存入临时文件。\" class=\"headerlink\" title=\"在打开一个文件编辑后才知道登录的用户对该文件没有写的权限，不能存盘，需要将所做修改存入临时文件。\"></a>在打开一个文件编辑后才知道登录的用户对该文件没有写的权限，不能存盘，需要将所做修改存入临时文件。</h4><p>—- vi file<br>—- :w /tmp/1 保存所做的所有修改，也可以将其中的某一部分修改保存到临时文件，例如仅仅把第20～59行之间的内容存盘成文件/tmp/1，我们可以键入如下命令。<br>—- vi file<br>—- :20,59w /tmp/1</p>\n<h4 id=\"用VI编辑一个文件，但需要删除大段的内容。\"><a href=\"#用VI编辑一个文件，但需要删除大段的内容。\" class=\"headerlink\" title=\"用VI编辑一个文件，但需要删除大段的内容。\"></a>用VI编辑一个文件，但需要删除大段的内容。</h4><p>—- 首先利用编辑命令“vi file”打开文件，然后将光标移到需要删除的行处按Ctrl+G显示行号，再到结尾处再按Ctrl+G，显示文件结尾的行号。<br>—- :23,1045d 假定2次得到的行号为23和1045，则把这期间的内容全删除，也可以在要删除的开始行和结束行中用ma、mb命令标记，然后利用“:a,bd”命令删除。</p>\n<h4 id=\"在整个文件的各行或某几行的行首或行尾加一些字符串。\"><a href=\"#在整个文件的各行或某几行的行首或行尾加一些字符串。\" class=\"headerlink\" title=\"在整个文件的各行或某几行的行首或行尾加一些字符串。\"></a>在整个文件的各行或某几行的行首或行尾加一些字符串。</h4><p>—- vi file<br>—- :3,$s/^/some string / 在文件的第一行至最后一行的行首插入“some string”。<br>—- :%s/$/some string/g 在整个文件每一行的行尾添加“some string”。<br>—- :%s/string1/string2/g 在整个文件中替换“string1”成“string2”。<br>—- :3,7s/string1/string2/ 仅替换文件中的第3行到第7行中的“string1”成“string2”。<br>—- 注意: 其中s为substitute，%表示所有行，g表示global。</p>\n<h4 id=\"同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中。\"><a href=\"#同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中。\" class=\"headerlink\" title=\"同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中。\"></a>同时编辑2个文件，拷贝一个文件中的文本并粘贴到另一个文件中。</h4><p>—- vi file1 file2<br>—- yy 在文件1的光标处拷贝所在行<br>—- :n 切换到文件2 (n=next)<br>—- p 在文件2的光标所在处粘贴所拷贝的行<br>—- :n 切换回文件1</p>\n<h4 id=\"替换文件中的路径。\"><a href=\"#替换文件中的路径。\" class=\"headerlink\" title=\"替换文件中的路径。\"></a>替换文件中的路径。</h4><p>—- 使用命令“:%s#/usr/bin#/bin#g”可以把文件中所有路径/usr/bin换成/bin。也可以使用命令“:%s//usr/bin//bin/g”实现，其中“”是转义字符，表明其后的“/”字符是具有实际意义的字符，不是分隔符。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjs1amk0w000alkgu12quj9vg","category_id":"cjs1amk0t0007lkguvbnd5c6o","_id":"cjs1amk0z000glkguymbmkmk6"},{"post_id":"cjs1amk0r0003lkguszcp8qx4","category_id":"cjs1amk0t0007lkguvbnd5c6o","_id":"cjs1amk11000klkgulwam8an3"},{"post_id":"cjs1amk0s0005lkgu8r8duqdw","category_id":"cjs1amk0x000clkguvdyvwhjr","_id":"cjs1amk12000nlkgu4ocevkm0"},{"post_id":"cjs1amk0z000flkgujz72qjwj","category_id":"cjs1amk0t0007lkguvbnd5c6o","_id":"cjs1amk13000qlkgu3gl7dyzk"},{"post_id":"cjs1amk11000jlkgu150f55y5","category_id":"cjs1amk0t0007lkguvbnd5c6o","_id":"cjs1amk14000tlkgupl8bax7j"},{"post_id":"cjs1amk0u0008lkguxn6fi9tl","category_id":"cjs1amk0t0007lkguvbnd5c6o","_id":"cjs1amk15000wlkguajmlmlln"},{"post_id":"cjs1amk0x000blkgupshhd8sn","category_id":"cjs1amk0x000clkguvdyvwhjr","_id":"cjs1amk16000zlkguzh8esym4"},{"post_id":"cjs1amk0y000dlkgu8quts1w8","category_id":"cjs1amk14000slkguyny6jt96","_id":"cjs1amk170015lkgusovsa094"},{"post_id":"cjs1amk11000llkgun8zxxgkw","category_id":"cjs1amk160010lkgupk1jsx5b","_id":"cjs1amk190019lkguxarnyvdt"},{"post_id":"cjs1amk180018lkguonrkhrkr","category_id":"cjs1amk170016lkguxff5wgdt","_id":"cjs1amk1b001elkgu6xirsnqi"},{"post_id":"cjs1amk13000rlkgurx044huo","category_id":"cjs1amk170016lkguxff5wgdt","_id":"cjs1amk1c001hlkgu5yywdlwb"},{"post_id":"cjs1amk19001clkgug144uxjd","category_id":"cjs1amk160010lkgupk1jsx5b","_id":"cjs1amk1c001jlkguo4uv5iz7"},{"post_id":"cjs1amk14000ulkguwi7ofcfp","category_id":"cjs1amk19001blkguoyw799ir","_id":"cjs1amk1e001mlkgujbijs98y"},{"post_id":"cjs1amk1b001glkguunwxoe6z","category_id":"cjs1amk160010lkgupk1jsx5b","_id":"cjs1amk1e001olkguyxhrtcoe"},{"post_id":"cjs1amk15000xlkgufttah9o8","category_id":"cjs1amk19001blkguoyw799ir","_id":"cjs1amk1f001slkgumplkdowy"},{"post_id":"cjs1amk1d001llkguvhr5ede2","category_id":"cjs1amk14000slkguyny6jt96","_id":"cjs1amk1g001ulkgu35i2i8d4"},{"post_id":"cjs1amk160011lkgu2my6pz27","category_id":"cjs1amk1c001klkgu6d8dmjpm","_id":"cjs1amk1h001ylkgu6y2f3jry"},{"post_id":"cjs1amk1e001nlkguf3qqt3le","category_id":"cjs1amk0x000clkguvdyvwhjr","_id":"cjs1amk1i0020lkgu1s9vrj3p"},{"post_id":"cjs1amk170013lkguqx6o5tsf","category_id":"cjs1amk19001blkguoyw799ir","_id":"cjs1amk1j0023lkguw57q55r0"},{"post_id":"cjs1amk170017lkgu9ftusx2f","category_id":"cjs1amk19001blkguoyw799ir","_id":"cjs1amk1k0028lkguiqqypzt6"},{"post_id":"cjs1amk1i0022lkgu38ysg2nd","category_id":"cjs1amk160010lkgupk1jsx5b","_id":"cjs1amk1l002dlkguhw6gp35k"},{"post_id":"cjs1amk19001alkgurejooph9","category_id":"cjs1amk19001blkguoyw799ir","_id":"cjs1amk1m002hlkguvv5dq9kj"},{"post_id":"cjs1amk1k0029lkgu2w0ru3t6","category_id":"cjs1amk160010lkgupk1jsx5b","_id":"cjs1amk1n002klkgulz4ykxcq"},{"post_id":"cjs1amk1a001dlkgugrw1zcox","category_id":"cjs1amk1k0027lkguxdohqpwa","_id":"cjs1amk1o002nlkguqhinwitp"},{"post_id":"cjs1amk1m002glkguc6vg76i6","category_id":"cjs1amk160010lkgupk1jsx5b","_id":"cjs1amk1o002rlkguwxhy5swi"},{"post_id":"cjs1amk1m002jlkgu1n8ib12m","category_id":"cjs1amk0x000clkguvdyvwhjr","_id":"cjs1amk1p002ulkgu1cxim9rl"},{"post_id":"cjs1amk1c001ilkgu5fuasmu1","category_id":"cjs1amk1l002flkguyuomfg7z","_id":"cjs1amk1s002xlkguv8cm9fh2"},{"post_id":"cjs1amk1n002mlkguyfr0lkos","category_id":"cjs1amk14000slkguyny6jt96","_id":"cjs1amk1t0031lkgu60o615xp"},{"post_id":"cjs1amk1f001rlkgu6kwmwji8","category_id":"cjs1amk1o002olkgu322zbhrj","_id":"cjs1amk1u0034lkgu6tl60978"},{"post_id":"cjs1amk1q002wlkguif5orukz","category_id":"cjs1amk14000slkguyny6jt96","_id":"cjs1amk1v0038lkgu15ap6rb6"},{"post_id":"cjs1amk1f001tlkgurtjfg5dx","category_id":"cjs1amk1p002vlkguxr1oz5c1","_id":"cjs1amk1w003clkguqfd93zru"},{"post_id":"cjs1amk1s0030lkguhd02vthz","category_id":"cjs1amk14000slkguyny6jt96","_id":"cjs1amk1x003flkgu5m168uip"},{"post_id":"cjs1amk1t0033lkgu920j9rh7","category_id":"cjs1amk160010lkgupk1jsx5b","_id":"cjs1amk1y003jlkgumtgxxvyu"},{"post_id":"cjs1amk1h001wlkguroibsjmz","category_id":"cjs1amk1o002olkgu322zbhrj","_id":"cjs1amk1y003llkguy5rptmh6"},{"post_id":"cjs1amk1u0037lkgu7gte6zgc","category_id":"cjs1amk0x000clkguvdyvwhjr","_id":"cjs1amk1z003olkguwu32b39g"},{"post_id":"cjs1amk1h001zlkguwytra1zw","category_id":"cjs1amk1v0039lkguogmb84sr","_id":"cjs1amk20003slkgu72pwevqw"},{"post_id":"cjs1amk1w003elkgufrfpm1aj","category_id":"cjs1amk14000slkguyny6jt96","_id":"cjs1amk21003ulkgudqpakb3q"},{"post_id":"cjs1amk1x003ilkguyj18b04h","category_id":"cjs1amk0x000clkguvdyvwhjr","_id":"cjs1amk21003wlkguyy14ctpl"},{"post_id":"cjs1amk1j0025lkguzighjuic","category_id":"cjs1amk1x003hlkguuka7dld5","_id":"cjs1amk21003xlkgulca8cwuf"},{"post_id":"cjs1amk20003rlkgutt05aypx","category_id":"cjs1amk1p002vlkguxr1oz5c1","_id":"cjs1amk21003zlkguhhm4vg0d"},{"post_id":"cjs1amk1l002clkgu35rfushp","category_id":"cjs1amk1z003plkguhxfgbcn2","_id":"cjs1amk210040lkgu7hq9sp0a"},{"post_id":"cjs1amk1o002qlkgug4tihlot","category_id":"cjs1amk21003vlkguyigouna6","_id":"cjs1amk220042lkgudequxs7c"},{"post_id":"cjs1amk1p002tlkgu7ytvywwq","category_id":"cjs1amk21003ylkgunftyv0k4","_id":"cjs1amk220043lkgu36amr752"},{"post_id":"cjs1amk1v003blkguxx341i0r","category_id":"cjs1amk220041lkguqao7rzi4","_id":"cjs1amk230046lkgui19tw56l"},{"post_id":"cjs1amk1y003klkgufttts7zu","category_id":"cjs1amk220041lkguqao7rzi4","_id":"cjs1amk230047lkgumqh7arb1"},{"post_id":"cjs1amk1z003nlkguw517trii","category_id":"cjs1amk220041lkguqao7rzi4","_id":"cjs1amk230048lkgupute858w"}],"PostTag":[{"post_id":"cjs1amk0s0005lkgu8r8duqdw","tag_id":"cjs1amk0v0009lkgurlvaiw0z","_id":"cjs1amk0z000elkgu6weigx2x"},{"post_id":"cjs1amk0y000dlkgu8quts1w8","tag_id":"cjs1amk10000ilkgusfrzwfz9","_id":"cjs1amk16000ylkguc6omvbu2"},{"post_id":"cjs1amk0y000dlkgu8quts1w8","tag_id":"cjs1amk13000plkgu3lc0s81c","_id":"cjs1amk160012lkguwtnnqyuj"},{"post_id":"cjs1amk13000olkgue4fiqjv4","tag_id":"cjs1amk15000vlkgucddeh914","_id":"cjs1amk170014lkgucnv6s074"},{"post_id":"cjs1amk1d001llkguvhr5ede2","tag_id":"cjs1amk1f001qlkgui4fdhc78","_id":"cjs1amk1j0026lkgu2ocfsxgb"},{"post_id":"cjs1amk1d001llkguvhr5ede2","tag_id":"cjs1amk1h001xlkgud97w4ujx","_id":"cjs1amk1k002alkgu7bcazq0r"},{"post_id":"cjs1amk1f001rlkgu6kwmwji8","tag_id":"cjs1amk1j0024lkgutk21ttmq","_id":"cjs1amk1l002elkguc7681ahn"},{"post_id":"cjs1amk1h001wlkguroibsjmz","tag_id":"cjs1amk1j0024lkgutk21ttmq","_id":"cjs1amk1n002llkgunuij5qgc"},{"post_id":"cjs1amk1j0025lkguzighjuic","tag_id":"cjs1amk1m002ilkgugawx7rr8","_id":"cjs1amk1p002slkguqzed3u7o"},{"post_id":"cjs1amk1k0029lkgu2w0ru3t6","tag_id":"cjs1amk1o002plkguqr0oh4lo","_id":"cjs1amk1s002zlkgujpq8exta"},{"post_id":"cjs1amk1s0030lkguhd02vthz","tag_id":"cjs1amk1h001xlkgud97w4ujx","_id":"cjs1amk1u0036lkguvll9uhi2"},{"post_id":"cjs1amk1m002glkguc6vg76i6","tag_id":"cjs1amk1o002plkguqr0oh4lo","_id":"cjs1amk1v003alkgu91iev730"},{"post_id":"cjs1amk1n002mlkguyfr0lkos","tag_id":"cjs1amk1u0035lkgu6a6v20lu","_id":"cjs1amk1x003glkgualgdozci"},{"post_id":"cjs1amk1x003ilkguyj18b04h","tag_id":"cjs1amk0v0009lkgurlvaiw0z","_id":"cjs1amk1z003mlkguc5lyja31"},{"post_id":"cjs1amk1u0037lkgu7gte6zgc","tag_id":"cjs1amk0v0009lkgurlvaiw0z","_id":"cjs1amk1z003qlkguv2hdbnfb"},{"post_id":"cjs1amk1u0037lkgu7gte6zgc","tag_id":"cjs1amk1w003dlkguy4fkdmbb","_id":"cjs1amk20003tlkguiatrc21y"}],"Tag":[{"name":"C/C++","_id":"cjs1amk0v0009lkgurlvaiw0z"},{"name":"Eclipse","_id":"cjs1amk10000ilkgusfrzwfz9"},{"name":"MacOS","_id":"cjs1amk13000plkgu3lc0s81c"},{"name":"others","_id":"cjs1amk15000vlkgucddeh914"},{"name":"GoogleTest","_id":"cjs1amk1f001qlkgui4fdhc78"},{"name":"Ubuntu","_id":"cjs1amk1h001xlkgud97w4ujx"},{"name":"Java","_id":"cjs1amk1j0024lkgutk21ttmq"},{"name":"Networking and Protocol","_id":"cjs1amk1m002ilkgugawx7rr8"},{"name":"OpenGL","_id":"cjs1amk1o002plkguqr0oh4lo"},{"name":"QT","_id":"cjs1amk1u0035lkgu6a6v20lu"},{"name":"STL","_id":"cjs1amk1w003dlkguy4fkdmbb"}]}}